diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 266fd660ec0c..7846a890baf8 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -216,6 +216,7 @@ source_set("browser") {
     "//third_party/brotli:dec",
     "//third_party/icu",
     "//third_party/inspector_protocol:crdtp",
+    "//third_party/libmcrx:mcrx",
     "//third_party/libyuv",
     "//third_party/re2",
     "//third_party/sqlite",
@@ -1131,6 +1132,16 @@ source_set("browser") {
     "message_port_provider.cc",
     "mime_registry_impl.cc",
     "mime_registry_impl.h",
+    "multicast/libmcrx_wrapper_impl.cc",
+    "multicast/libmcrx_wrapper.h",
+    "multicast/multicast_receiver_manager.cc",
+    "multicast/multicast_receiver_manager.h",
+    "multicast/multicast_receiver_opener_impl.cc",
+    "multicast/multicast_receiver_opener_impl.h",
+    "multicast/multicast_receiver.cc",
+    "multicast/multicast_receiver.h",
+    "multicast/multicast_generator/libmcrx_multicast_generator.cc",
+    "multicast/multicast_generator/libmcrx_multicast_generator.h",
     "mojo_binder_policy_applier.cc",
     "mojo_binder_policy_applier.h",
     "mojo_binder_policy_map_impl.cc",
diff --git a/content/browser/browser_interface_binders.cc b/content/browser/browser_interface_binders.cc
index a45f9d3db09d..930d2e4605e3 100644
--- a/content/browser/browser_interface_binders.cc
+++ b/content/browser/browser_interface_binders.cc
@@ -111,6 +111,7 @@
 #include "third_party/blink/public/mojom/mediasession/media_session.mojom.h"
 #include "third_party/blink/public/mojom/mediastream/media_devices.mojom.h"
 #include "third_party/blink/public/mojom/mediastream/media_stream.mojom.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom.h"
 #include "third_party/blink/public/mojom/native_io/native_io.mojom.h"
 #include "third_party/blink/public/mojom/notifications/notification_service.mojom.h"
 #include "third_party/blink/public/mojom/payments/payment_app.mojom.h"
@@ -709,6 +710,10 @@ void PopulateFrameBinders(RenderFrameHostImpl* host, mojo::BinderMap* map) {
       base::BindRepeating(&RenderFrameHostImpl::CreateQuicTransportConnector,
                           base::Unretained(host)));
 
+  map->Add<network::mojom::MulticastReceiverOpener>(
+      base::BindRepeating(&RenderFrameHostImpl::CreateMulticastReceiverOpener,
+                          base::Unretained(host)));
+
   map->Add<blink::test::mojom::VirtualAuthenticatorManager>(
       base::BindRepeating(&RenderFrameHostImpl::GetVirtualAuthenticatorManager,
                           base::Unretained(host)));
@@ -968,6 +973,9 @@ void PopulateDedicatedWorkerBinders(DedicatedWorkerHost* host,
   map->Add<blink::mojom::QuicTransportConnector>(
       base::BindRepeating(&DedicatedWorkerHost::CreateQuicTransportConnector,
                           base::Unretained(host)));
+  map->Add<network::mojom::MulticastReceiverOpener>(
+      base::BindRepeating(&DedicatedWorkerHost::CreateMulticastReceiverOpener,
+                          base::Unretained(host)));
   map->Add<blink::mojom::WakeLockService>(base::BindRepeating(
       &DedicatedWorkerHost::CreateWakeLockService, base::Unretained(host)));
   map->Add<blink::mojom::ContentSecurityNotifier>(
@@ -1055,6 +1063,8 @@ void PopulateSharedWorkerBinders(SharedWorkerHost* host, mojo::BinderMap* map) {
   }
   map->Add<blink::mojom::QuicTransportConnector>(base::BindRepeating(
       &SharedWorkerHost::CreateQuicTransportConnector, base::Unretained(host)));
+  map->Add<network::mojom::MulticastReceiverOpener>(base::BindRepeating(
+      &SharedWorkerHost::CreateMulticastReceiverOpener, base::Unretained(host)));
   map->Add<blink::mojom::CacheStorage>(base::BindRepeating(
       &SharedWorkerHost::BindCacheStorage, base::Unretained(host)));
 #if BUILDFLAG(ENABLE_REPORTING)
@@ -1138,6 +1148,9 @@ void PopulateServiceWorkerBinders(ServiceWorkerHost* host,
   map->Add<blink::mojom::QuicTransportConnector>(
       base::BindRepeating(&ServiceWorkerHost::CreateQuicTransportConnector,
                           base::Unretained(host)));
+  map->Add<network::mojom::MulticastReceiverOpener>(base::BindRepeating(
+      &ServiceWorkerHost::CreateMulticastReceiverOpener,
+      base::Unretained(host)));
   map->Add<blink::mojom::CacheStorage>(base::BindRepeating(
       &ServiceWorkerHost::BindCacheStorage, base::Unretained(host)));
   map->Add<blink::mojom::BadgeService>(
diff --git a/content/browser/multicast/libmcrx_wrapper.h b/content/browser/multicast/libmcrx_wrapper.h
new file mode 100644
index 000000000000..ca1b417cdc70
--- /dev/null
+++ b/content/browser/multicast/libmcrx_wrapper.h
@@ -0,0 +1,91 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_LIBMCRX_WRAPPER_H_
+#define CONTENT_BROWSER_LIBMCRX_WRAPPER_H_
+
+#include <memory>
+
+#include "third_party/libmcrx/include/mcrx/libmcrx.h"
+
+namespace network {
+
+class LibMcrxPacketReceiver {
+  public:
+    virtual int OnPacketReceived(struct mcrx_packet* packet) = 0;
+
+    virtual ~LibMcrxPacketReceiver() = default;
+};
+
+class LibMcrxLogger {
+  public:
+    virtual void Log(const char *str) = 0;
+
+    virtual ~LibMcrxLogger() = default;
+};
+
+// C++ wrapper for libmcrx
+class LibMcrxWrapper {
+  public:
+    // Context related calls
+
+    virtual enum mcrx_error_code mcrx_ctx_new(
+        struct mcrx_ctx **ctxp) = 0;
+
+    virtual void mcrx_ctx_set_log_priority(
+        struct mcrx_ctx *ctx,
+        enum mcrx_log_priority priority) = 0;
+
+    virtual void mcrx_ctx_set_log_string_fn(
+        struct mcrx_ctx *ctx,
+        LibMcrxLogger* logger) = 0;
+
+    virtual void mcrx_ctx_roust(
+        struct mcrx_ctx *ctx) = 0;
+
+    virtual enum mcrx_error_code mcrx_ctx_receive_packets(
+        struct mcrx_ctx *ctx) = 0;
+
+    // Subscription related calls
+
+    virtual enum mcrx_error_code mcrx_subscription_config_pton(
+        struct mcrx_subscription_config* config,
+        const char* source,
+        const char* group) = 0;
+
+    virtual void mcrx_subscription_unref(
+        struct mcrx_subscription* sub) = 0;
+
+    virtual enum mcrx_error_code mcrx_subscription_new(
+        struct mcrx_ctx* ctx,
+        const struct mcrx_subscription_config* config,
+        struct mcrx_subscription** subp) = 0;
+
+    virtual void mcrx_subscription_set_receive_cb(
+        struct mcrx_subscription* sub,
+        LibMcrxPacketReceiver* packet_receiver) = 0;
+
+    virtual enum mcrx_error_code mcrx_subscription_join(
+        struct mcrx_subscription* sub) = 0;
+
+    virtual enum mcrx_error_code mcrx_subscription_leave(
+        struct mcrx_subscription* sub) = 0;
+
+    // Packet related calls
+
+    virtual uint16_t mcrx_packet_get_contents(
+        struct mcrx_packet* pkt,
+        uint8_t** data) = 0;
+
+    virtual void mcrx_packet_unref(struct mcrx_packet* pkt) = 0;
+
+    // Factory method
+    static std::unique_ptr<LibMcrxWrapper> CreateInstance();
+
+    virtual ~LibMcrxWrapper() = default;
+};
+
+}  // namespace network
+
+#endif  // CONTENT_BROWSER_LIBMCRX_WRAPPER_H_
diff --git a/content/browser/multicast/libmcrx_wrapper_impl.cc b/content/browser/multicast/libmcrx_wrapper_impl.cc
new file mode 100644
index 000000000000..a7a94e6e8a25
--- /dev/null
+++ b/content/browser/multicast/libmcrx_wrapper_impl.cc
@@ -0,0 +1,133 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/multicast/libmcrx_wrapper.h"
+
+#include "base/logging.h"
+#include "base/check.h"
+
+namespace network {
+
+class LibMcrxWrapperImpl final : public LibMcrxWrapper {
+  public:
+    enum mcrx_error_code mcrx_ctx_new(
+        struct mcrx_ctx **ctxp) override {
+      auto ret = ::mcrx_ctx_new(ctxp);
+
+      // TODO(cworm): We need this timeout for two reason:
+      //   1) |mcrx_ctx_roust| is not implemented in libmcrx, so there is
+      //      no way to wakeup the blocking call to
+      //      |::mcrx_ctx_receive_packets|. Instead we just wake up every 500ms.
+      //   2) |MulticastReceiverManager| currently does not call
+      //      |mcrx_ctx_roust| when the browser is about to exit.
+      //      What is the good way to make it do that?
+      if (ret == 0) {
+        DCHECK(*ctxp);
+        ::mcrx_ctx_set_wait_ms(*ctxp, 500);
+      }
+      return ret;
+    }
+
+    void mcrx_ctx_set_log_priority(
+        struct mcrx_ctx *ctx,
+        enum mcrx_log_priority priority) override {
+      ::mcrx_ctx_set_log_priority(ctx, priority);
+    }
+
+    void mcrx_ctx_set_log_string_fn(
+        struct mcrx_ctx *ctx,
+        LibMcrxLogger* logger) override {
+      ::mcrx_ctx_set_userdata(ctx, reinterpret_cast<intptr_t>(logger));
+      ::mcrx_ctx_set_log_string_fn(ctx, &LibMcrxWrapperImpl::McrxLog);
+    }
+
+    void mcrx_ctx_roust(
+        struct mcrx_ctx *ctx) override {
+      // TODO: not yet implemented in libmcrx
+      // We set a timeout instead, see |mcrx_ctx_receive_packets|
+    }
+
+    enum mcrx_error_code mcrx_ctx_receive_packets(
+        struct mcrx_ctx *ctx) override {
+      return ::mcrx_ctx_receive_packets(ctx);
+    }
+
+    enum mcrx_error_code mcrx_subscription_config_pton(
+        struct mcrx_subscription_config* config,
+        const char* source,
+        const char* group) override {
+      return ::mcrx_subscription_config_pton(config, source, group);
+    }
+
+    void mcrx_subscription_unref(
+        struct mcrx_subscription* sub) override {
+      ::mcrx_subscription_unref(sub);
+    }
+
+    enum mcrx_error_code mcrx_subscription_new(
+        struct mcrx_ctx* ctx,
+        const struct mcrx_subscription_config* config,
+        struct mcrx_subscription** subp) override {
+      return ::mcrx_subscription_new(ctx, config, subp);
+    }
+
+    void mcrx_subscription_set_receive_cb(
+        struct mcrx_subscription* sub,
+        LibMcrxPacketReceiver* packet_receiver) override {
+      ::mcrx_subscription_set_userdata(sub,
+          reinterpret_cast<intptr_t>(packet_receiver));
+      ::mcrx_subscription_set_receive_cb(sub,
+          &LibMcrxWrapperImpl::OnPacketReceived);
+    }
+
+    enum mcrx_error_code mcrx_subscription_join(
+        struct mcrx_subscription* sub) override {
+      return ::mcrx_subscription_join(sub);
+    }
+
+    enum mcrx_error_code mcrx_subscription_leave(
+        struct mcrx_subscription* sub) override {
+      return ::mcrx_subscription_leave(sub);
+    }
+
+    uint16_t mcrx_packet_get_contents(
+        struct mcrx_packet* pkt,
+        uint8_t** data) override {
+      return ::mcrx_packet_get_contents(pkt, data);
+    }
+
+    void mcrx_packet_unref(struct mcrx_packet* pkt) override {
+      ::mcrx_packet_unref(pkt);
+    }
+
+    static int OnPacketReceived(mcrx_packet* packet) {
+      mcrx_subscription* sub = mcrx_packet_get_subscription(packet);
+      LibMcrxPacketReceiver* receiver =
+          reinterpret_cast<LibMcrxPacketReceiver*>(
+            mcrx_subscription_get_userdata(sub));
+
+      return receiver->OnPacketReceived(packet);
+    }
+
+    static void McrxLog(struct mcrx_ctx *ctx,
+                        int priority,
+                        const char *file,
+                        int line,
+                        const char *fn,
+                        const char *str) {
+      LibMcrxLogger* logger =
+          reinterpret_cast<LibMcrxLogger*>(
+            mcrx_ctx_get_userdata(ctx));
+
+      return logger->Log(str);
+    }
+
+    ~LibMcrxWrapperImpl() override = default;
+};
+
+std::unique_ptr<LibMcrxWrapper> LibMcrxWrapper::CreateInstance() {
+  return std::make_unique<LibMcrxWrapperImpl>();
+}
+
+}  // namespace network
diff --git a/content/browser/multicast/multicast_form.html b/content/browser/multicast/multicast_form.html
new file mode 100644
index 000000000000..ca338d673d43
--- /dev/null
+++ b/content/browser/multicast/multicast_form.html
@@ -0,0 +1,73 @@
+<HTML>
+<HEAD>
+<TITLE>Test Multicast</TITLE>
+<SCRIPT LANGUAGE="JavaScript">
+function startTest (form) {
+// Multicast flow to join:
+
+let multicastFlow = {
+  source: form.source.value,
+  group: form.group.value,
+  port: parseInt(form.port.value),
+  dorms: form.dorm.value
+};
+
+console.log("multicastFlow cfg: " + multicastFlow);
+// Construct MulticastReceiver and subscribe to the multicast flow on the
+// network:
+
+let multicastReceiver=new MulticastReceiver(multicastFlow);
+var rx_packets = 0;
+var rx_bytes = 0;
+
+// Read multicast UDP packets:
+
+let multicastReader=multicastReceiver.readable.getReader();
+
+document.getElementById("receive_packets").innerHTML = rx_packets;
+document.getElementById("receive_bytes").innerHTML = rx_bytes;
+
+async function readMulticastData() {
+  for(;;) {
+    let { done, value } = await multicastReader.read();
+    if(done) {
+      return;
+    } else {
+      // value is an UInt8Array with the payload of one UDP packet.
+      console.log("Got multicast packet with size "+value.length);
+      rx_packets++;
+      rx_bytes += value.length;
+      document.getElementById("receive_packets").innerHTML = rx_packets;
+      document.getElementById("receive_bytes").innerHTML = rx_bytes;
+    }
+  }
+}
+
+readMulticastData().then( () => {
+  console.log("Cancel was called.");
+}).catch( error => {
+  console.log(error,"Error. Closecode is "+multicastReader.closecode);
+});
+
+// Cancel after 20 seconds:
+
+setTimeout( () => {
+  console.log("Canceling multicast");
+  multicastReader.cancel();
+},parseInt(form.timeout)*1000);
+}
+</SCRIPT>
+</HEAD>
+<BODY>
+<FORM NAME="myform" ACTION="" METHOD="GET">Enter Multicast Setting: <BR>
+Source: <INPUT TYPE="text" NAME="source" VALUE="23.212.185.5"><P>
+Group: <INPUT TYPE="text" NAME="group" VALUE="232.1.1.1"><P>
+Port: <INPUT TYPE="text" NAME="port" VALUE="5001"><P>
+Dorm: <INPUT TYPE="text" NAME="dorm" VALUE="disrupt-dorms.edgesuite.net"><P>
+Play Timeout in seconds: <INPUT TYPE="text" NAME="timeout in seconds" VALUE="20"><P>
+<INPUT TYPE="button" NAME="join" Value="Start Test" onClick="startTest(this.form)">
+</FORM>
+</BODY>
+Received packets: <p id="receive_packets"></p>
+Received bytes: <p id="receive_bytes"></p>
+</HTML>
diff --git a/content/browser/multicast/multicast_generator/libmcrx_multicast_generator.cc b/content/browser/multicast/multicast_generator/libmcrx_multicast_generator.cc
new file mode 100644
index 000000000000..d227d5c79015
--- /dev/null
+++ b/content/browser/multicast/multicast_generator/libmcrx_multicast_generator.cc
@@ -0,0 +1,195 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifdef MULTICAST_API_PROFILING // API profiling - maybe we should delete this?
+
+#include "content/browser/multicast/multicast_generator/libmcrx_multicast_generator.h"
+
+#include "base/logging.h"
+
+#include <string>
+#include <vector>
+#include <math.h>
+
+#include <unistd.h>
+#include <time.h>
+
+namespace network {
+
+namespace multicast_generator {
+
+class LibMcrxMulticastGenerator final : public LibMcrxWrapper {
+  public:
+    // |packet_size| - size of packet in bytes
+    // |stream_bitrate| - bitrate in bits per sencond
+    // |packet_burst| - number of packets sent at a time. Default is 1
+    LibMcrxMulticastGenerator(
+        int32_t packet_size,
+        int64_t stream_bitrate,
+        int32_t packet_burst)
+      : packet_size_(packet_size),
+        packet_burst_(packet_burst) {
+      packet_=std::vector<uint8_t>(packet_size,0);
+
+      // Calculate time duration between packets in seconds.
+      // We know:
+      //   stream_byterate = packet_size / packet_interval_duration
+      //   stream_byterate = stream_bitrate / 8
+      // So:
+      //   packet_interval_duration = 8 * packet_size / stream_bitrate
+      packet_distance_ = 8.0 * packet_size / stream_bitrate;
+
+      if(!(packet_distance_ > 0.0000001 && packet_distance_<2000)) {
+        DLOG(WARNING) << "Packet distance " << packet_distance_ << "seconds "
+          << "is out of range; we take it to be 1 hour";
+        packet_distance_=60*60;
+      }
+    }
+
+    enum mcrx_error_code mcrx_ctx_new(
+        struct mcrx_ctx **ctxp) override {
+      *ctxp = reinterpret_cast<struct mcrx_ctx *>(42);
+      return mcrx_error_code::MCRX_ERR_OK;
+    }
+
+    void mcrx_ctx_set_log_priority(
+        struct mcrx_ctx *ctx,
+        enum mcrx_log_priority priority) override {
+      // Do nothing
+    }
+
+    void mcrx_ctx_set_log_string_fn(
+        struct mcrx_ctx *ctx,
+        LibMcrxLogger* logger) override {
+      // Do nothing
+    }
+
+    void mcrx_ctx_roust(
+        struct mcrx_ctx *ctx) override {
+      woken_up_=true;
+    }
+
+    enum mcrx_error_code mcrx_ctx_receive_packets(
+        struct mcrx_ctx *ctx) override {
+      // Set start time if not done already
+      if(isnan(start_time_)) {
+        start_time_=CurrentTime();
+      }
+
+      struct mcrx_packet* pkt = reinterpret_cast<struct mcrx_packet*>(42);
+
+      // We need to exit after at most 0.5s because MulticastReceiverManager
+      // does not wake us up on browser exit.
+      double exit_time=CurrentTime()+0.5;
+
+      while(!woken_up_) {
+        // Calculate times
+        double now=CurrentTime();
+        double time_to_next_packet=next_packet_seq_*packet_distance_-
+          (now-start_time_);
+        double time_to_exit=exit_time-now;
+
+        if(time_to_exit<time_to_next_packet) {
+          if(time_to_exit>0)
+            usleep(time_to_exit*1000000+1); // Round up.
+          break;
+        }
+
+        if(time_to_next_packet>0)
+          usleep(time_to_next_packet*1000000+1); // Round up.
+
+        for(int i=0; i<packet_burst_; i++, next_packet_seq_++) {
+          packet_receiver_->OnPacketReceived(pkt);
+        }
+      }
+      woken_up_=false;
+
+      return mcrx_error_code::MCRX_ERR_OK;
+    }
+
+    enum mcrx_error_code mcrx_subscription_config_pton(
+        struct mcrx_subscription_config* config,
+        const char* source,
+        const char* group) override {
+      return mcrx_error_code::MCRX_ERR_OK;
+    }
+
+    void mcrx_subscription_unref(
+        struct mcrx_subscription* sub) override {
+      // Do nothing
+    }
+
+    enum mcrx_error_code mcrx_subscription_new(
+        struct mcrx_ctx* ctx,
+        const struct mcrx_subscription_config* config,
+        struct mcrx_subscription** subp) override {
+      *subp = reinterpret_cast<struct mcrx_subscription *>(42);
+      return mcrx_error_code::MCRX_ERR_OK;
+    }
+
+    void mcrx_subscription_set_receive_cb(
+        struct mcrx_subscription* sub,
+        LibMcrxPacketReceiver* packet_receiver) override {
+      packet_receiver_ = packet_receiver;
+    }
+
+    enum mcrx_error_code mcrx_subscription_join(
+        struct mcrx_subscription* sub) override {
+      return mcrx_error_code::MCRX_ERR_OK;
+    }
+
+    enum mcrx_error_code mcrx_subscription_leave(
+        struct mcrx_subscription* sub) override {
+      return mcrx_error_code::MCRX_ERR_OK;
+    }
+
+    uint16_t mcrx_packet_get_contents(
+        struct mcrx_packet* pkt,
+        uint8_t** data) override {
+      *data = &packet_[0];
+      return packet_size_;
+    }
+
+    void mcrx_packet_unref(struct mcrx_packet* pkt) override {
+      // Do nothing
+    }
+
+    ~LibMcrxMulticastGenerator() override = default;
+
+  private:
+    // Reads the current time in seconds.
+    double CurrentTime() {
+      struct timespec time;
+      if (clock_gettime(CLOCK_MONOTONIC, &time) < 0) {
+        abort();
+      }
+      return time.tv_sec + time.tv_nsec / 1000000000.0;
+    }
+
+    // Set a construction:
+    int32_t packet_size_;
+    int32_t packet_burst_;
+    std::vector<uint8_t> packet_;
+
+    std::atomic<bool> woken_up_{false};
+    double start_time_{NAN};
+    int64_t next_packet_seq_{0};
+    double packet_distance_;
+
+    LibMcrxPacketReceiver* packet_receiver_;
+};
+
+std::unique_ptr<LibMcrxWrapper> CreateMulticastGenerator(
+    uint32_t packet_size,
+    uint64_t stream_bitrate,
+    uint32_t packet_burst) {
+  return std::make_unique<LibMcrxMulticastGenerator>(
+      packet_size, stream_bitrate, packet_burst);
+}
+
+}  // namespace multicast_generator
+
+}  // namespace network
+
+#endif // MULTICAST_API_PROFILING
diff --git a/content/browser/multicast/multicast_generator/libmcrx_multicast_generator.h b/content/browser/multicast/multicast_generator/libmcrx_multicast_generator.h
new file mode 100644
index 000000000000..903490ea689c
--- /dev/null
+++ b/content/browser/multicast/multicast_generator/libmcrx_multicast_generator.h
@@ -0,0 +1,29 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifdef MULTICAST_API_PROFILING // API profiling - maybe we should delete this?
+
+#ifndef CONTENT_BROWSER_MULTICAST_MULTICAST_GENERATOR_LIBMCRX_MULTICAST_GENERATOR_H_
+#define CONTENT_BROWSER_MULTICAST_MULTICAST_GENERATOR_LIBMCRX_MULTICAST_GENERATOR_H_
+
+#include "content/browser/multicast/libmcrx_wrapper.h"
+
+#include <memory>
+
+namespace network {
+
+namespace multicast_generator {
+
+extern std::unique_ptr<LibMcrxWrapper> CreateMulticastGenerator(
+    uint32_t packet_size,
+    uint64_t stream_bitrate,
+    uint32_t packet_burst);
+
+}  // namespace multicast_generator
+
+}  // namesapace network
+
+#endif  // CONTENT_BROWSER_MULTICAST_MULTICAST_GENERATOR_LIBMCRX_MULTICAST_GENERATOR_H_
+
+#endif // MULTICAST_API_PROFILING
diff --git a/content/browser/multicast/multicast_receiver.cc b/content/browser/multicast/multicast_receiver.cc
new file mode 100644
index 000000000000..008eaba7b310
--- /dev/null
+++ b/content/browser/multicast/multicast_receiver.cc
@@ -0,0 +1,179 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/multicast/multicast_receiver.h"
+
+#include "base/task/post_task.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/browser/multicast/libmcrx_wrapper.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom.h"
+
+namespace network {
+
+MulticastReceiver::MulticastReceiver(
+    mojo::PendingRemote<mojom::MulticastReceiverClient> client,
+    const scoped_refptr<base::SequencedTaskRunner>& task_runner,
+    LibMcrxWrapper* libmcrx_wrapper)
+    : client_(std::move(client)),
+      subscription_(nullptr),
+      ctx_(nullptr),
+      mcrx_task_runner_(task_runner),
+      libmcrx_wrapper_(libmcrx_wrapper) {
+  DETACH_FROM_SEQUENCE(ui_sequence_checker_);
+}
+
+bool MulticastReceiver::Subscribe(
+    mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+    mcrx_ctx* ctx,
+    const std::string& source,
+    const std::string& group,
+    const std::string& dorms,
+    uint16_t port,
+    base::OnceCallback<void(bool)> on_unsubscribe_callback) {
+  DVLOG(1) << "subscribing";
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+  DCHECK(libmcrx_wrapper_);
+
+  if (!ctx) {
+    TearDown(mojom::MulticastCloseCode::ERROR, "Could not create mcrx context");
+    return false;
+  }
+
+  ctx_ = ctx;
+
+  mcrx_subscription_config config = MCRX_SUBSCRIPTION_CONFIG_INIT;
+  config.port = port;
+  int rc = libmcrx_wrapper_->mcrx_subscription_config_pton(
+        &config, source.c_str(), group.c_str());
+  if (rc != 0) {
+    TearDown(mojom::MulticastCloseCode::ERROR, "mcrx_subscription_config_pton failed");
+    return false;
+  }
+
+  mcrx_subscription* subscription = nullptr;
+  rc = libmcrx_wrapper_->mcrx_subscription_new(
+      ctx, &config, &subscription);
+  if (!subscription || rc != 0) {
+    if (subscription) {
+      libmcrx_wrapper_->mcrx_subscription_unref(subscription);
+    }
+    TearDown(mojom::MulticastCloseCode::ERROR, "mcrx_subscription_new failed");
+    return false;
+  }
+
+  {
+    base::ScopedBlockingCall scoped_blocking(FROM_HERE,
+        base::BlockingType::MAY_BLOCK);
+    DVLOG(1) << "after scoped, before join";
+    rc = libmcrx_wrapper_->mcrx_subscription_join(subscription);
+    DVLOG(1) << "after join, before unscoped";
+  }
+
+  if (rc != 0) {
+    libmcrx_wrapper_->mcrx_subscription_unref(subscription);
+    TearDown(mojom::MulticastCloseCode::ERROR, "mcrx_subscription_join failed");
+    return false;
+  }
+
+  on_unsubscribe_callback_ = std::move(on_unsubscribe_callback);
+  subscription_ = subscription;
+  libmcrx_wrapper_->mcrx_subscription_set_receive_cb(
+      subscription, this);
+
+  DVLOG(1) << "finished subscribing";
+
+  // At this point, TearDown will only be called by Close.
+  // So now we can bind the receiver.
+  base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+      base::BindOnce(&MulticastReceiver::BindReceiver,
+        base::Unretained(this), std::move(receiver)));
+
+  return true;
+}
+
+int MulticastReceiver::OnPacketReceived(mcrx_packet* packet) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+
+  uint8_t* data = nullptr;
+  uint16_t len =
+      libmcrx_wrapper_->mcrx_packet_get_contents(packet, &data);
+  client_->OnDatagram(base::make_span(data, len));
+  libmcrx_wrapper_->mcrx_packet_unref(packet);
+
+  return MCRX_RECEIVE_CONTINUE;
+}
+
+MulticastReceiver::~MulticastReceiver() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+  DVLOG(1) << this << " was deleted";
+}
+
+void MulticastReceiver::Close() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(ui_sequence_checker_);
+  receiver_.reset();
+
+  mojom::MulticastCloseCode close_code;
+  std::string close_message;
+
+  if (mojom_error_) {
+    close_code = mojom::MulticastCloseCode::MOJOM;
+    close_message = "Receiver pipe broke";
+  } else {
+    close_code = mojom::MulticastCloseCode::CLOSED_BY_CLIENT;
+    close_message = "Responding to Close call";
+  }
+
+  mcrx_task_runner_->PostTask(FROM_HERE,
+      base::BindOnce(&MulticastReceiver::TearDown, base::Unretained(this),
+      close_code, close_message));
+
+  // Wake-up |mcrx_sequence_checker_|
+  DCHECK(ctx_);
+  libmcrx_wrapper_->mcrx_ctx_roust(ctx_);
+}
+
+void MulticastReceiver::TearDown(mojom::MulticastCloseCode code,
+                                 const std::string& close_message) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+  DCHECK(!receiver_.is_bound());
+
+  if (subscription_) {
+    // Unsubscribe
+    int rc = libmcrx_wrapper_->mcrx_subscription_leave(subscription_);
+    std::move(on_unsubscribe_callback_).Run(rc == 0);
+
+    libmcrx_wrapper_->mcrx_subscription_unref(subscription_);
+    subscription_ = nullptr;
+  }
+
+  // Log the error message.
+  if (code == mojom::MulticastCloseCode::ERROR) {
+    DLOG(ERROR) << close_message;
+  }
+
+  client_->OnClose(code, close_message);
+  client_.reset();
+
+  delete this;
+}
+
+void MulticastReceiver::BindReceiver(
+    mojo::PendingReceiver<mojom::MulticastReceiver> receiver) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(ui_sequence_checker_);
+  DVLOG(1) << "Bind receiver";
+
+  receiver_.Bind(std::move(receiver));
+  receiver_.set_disconnect_handler(
+      base::BindOnce(&MulticastReceiver::HandleMojomError,
+      base::Unretained(this)));
+}
+
+void MulticastReceiver::HandleMojomError() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(ui_sequence_checker_);
+  mojom_error_ = true;
+  Close();
+}
+
+}  // namespace network
diff --git a/content/browser/multicast/multicast_receiver.h b/content/browser/multicast/multicast_receiver.h
new file mode 100644
index 000000000000..e613883baaa2
--- /dev/null
+++ b/content/browser/multicast/multicast_receiver.h
@@ -0,0 +1,89 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_H_
+#define CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_H_
+
+#include <string>
+
+#include "base/sequence_checker.h"
+#include "content/browser/multicast/libmcrx_wrapper.h"
+#include "content/common/content_export.h"
+#include "mojo/public/cpp/bindings/receiver.h"
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom.h"
+
+namespace network {
+
+class CONTENT_EXPORT MulticastReceiver final
+    : LibMcrxPacketReceiver,
+      public mojom::MulticastReceiver {
+  public:
+    // All the public functions run on |mcrx_sequence_checker_|
+    // (including the construction and destruction of the object).
+
+    MulticastReceiver(
+        mojo::PendingRemote<mojom::MulticastReceiverClient> client,
+        const scoped_refptr<base::SequencedTaskRunner>& task_runner,
+        LibMcrxWrapper* libmcrx_wrapper);
+
+    // Call this once.
+    // Returns true on success.
+    // On true return, |on_unsubscribe_callback| will be called after
+    // unsubscribing.
+    bool Subscribe(mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+                   mcrx_ctx* ctx,
+                   const std::string& source,
+                   const std::string& group,
+                   const std::string& dorms,
+                   uint16_t port,
+                   base::OnceCallback<void(bool)> on_unsubscribe_callback);
+
+    ~MulticastReceiver() override;
+
+  private:
+    // mojom::MulticastReceiver implementation:
+    //
+    // It needs to run on |ui_sequence_checker_| because
+    // |mcrx_sequence_checker_| blocks.
+    void Close() override;
+
+    // These functions run on |mcrx_sequence_checker_|
+
+    // MulticastPacketReceiver implementation:
+    int OnPacketReceived(mcrx_packet* packet) override;
+
+    // Called once. Deletes the instance.
+    void TearDown(mojom::MulticastCloseCode code,
+                  const std::string& close_message);
+
+    // These functions run on |ui_sequence_checker_|
+
+    void BindReceiver(
+        mojo::PendingReceiver<mojom::MulticastReceiver> receiver);
+
+    void HandleMojomError();
+
+    mojo::Receiver<mojom::MulticastReceiver> receiver_{this};
+    mojo::Remote<mojom::MulticastReceiverClient> client_;
+
+    mcrx_subscription* subscription_;
+    mcrx_ctx* ctx_;
+
+    base::OnceCallback<void(bool)> on_unsubscribe_callback_;
+
+    // Used to post tasks to |mcrx_sequence_checker_|
+    scoped_refptr<base::SequencedTaskRunner> mcrx_task_runner_;
+
+    bool mojom_error_ = false;
+
+    LibMcrxWrapper* libmcrx_wrapper_; // outlives |this|
+
+    SEQUENCE_CHECKER(ui_sequence_checker_);
+    SEQUENCE_CHECKER(mcrx_sequence_checker_);
+};
+
+}  // namespace network
+
+#endif  // CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_H_
\ No newline at end of file
diff --git a/content/browser/multicast/multicast_receiver_manager.cc b/content/browser/multicast/multicast_receiver_manager.cc
new file mode 100644
index 000000000000..b8c19b39aebd
--- /dev/null
+++ b/content/browser/multicast/multicast_receiver_manager.cc
@@ -0,0 +1,176 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/multicast/multicast_receiver_manager.h"
+
+#include "base/task/post_task.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/browser/multicast/multicast_receiver.h"
+#include "content/browser/multicast/multicast_generator/libmcrx_multicast_generator.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace network {
+
+MulticastReceiverManager& MulticastReceiverManager::GetInstance() {
+  // C++11 and NoDestructor claim to be thread safe, so this should be
+  // OK from any thread.
+  static base::NoDestructor<MulticastReceiverManager> instance;
+  return *instance;
+}
+
+void MulticastReceiverManager::CreateReceiver(
+    const std::string& source,
+    const std::string& group,
+    const std::string& dorms,
+    uint16_t port,
+    mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+    mojo::PendingRemote<mojom::MulticastReceiverClient> client) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(ui_sequence_checker_);
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  mcrx_task_runner_->PostTask(FROM_HERE,
+      base::BindOnce(&MulticastReceiverManager::CreateReceiverMcrxSequence,
+        base::Unretained(this), source, group, dorms, port,
+        std::move(receiver), std::move(client)));
+
+  WakeUpMcrxSequence();
+}
+
+void MulticastReceiverManager::CreateReceiverMcrxSequence(
+    const std::string& source,
+    const std::string& group,
+    const std::string& dorms,
+    uint16_t port,
+    mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+    mojo::PendingRemote<mojom::MulticastReceiverClient> client) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+
+  if (!libmcrx_wrapper_) {
+#ifdef MULTICAST_API_PROFILING // API profiling - maybe we should delete this?
+    char* packet_size = getenv("PACKET_SIZE");
+    char* stream_bitrate = getenv("STREAM_BITRATE");
+    char* packet_burst = getenv("PACKET_BURST");
+
+    if (packet_size && stream_bitrate) {
+      uint32_t burst = packet_burst ? atoi(packet_burst) : 1;
+      libmcrx_wrapper_ = multicast_generator::CreateMulticastGenerator(
+          atoi(packet_size), atoi(stream_bitrate), burst);
+    } else {
+      libmcrx_wrapper_ = LibMcrxWrapper::CreateInstance();
+    }
+#else
+    libmcrx_wrapper_ = LibMcrxWrapper::CreateInstance();
+#endif // MULTICAST_API_PROFILING
+  }
+  if (!ctx_) {
+    int rc = libmcrx_wrapper_->mcrx_ctx_new(&ctx_);
+    DVLOG(1) << "new ctx: " << ctx_;
+    if (rc != 0) {
+      DLOG(ERROR) << "mcrx_ctx_new failed: " << rc;
+      // Continue so the MulticastReceiver can report this error (see below).
+    } else {
+      DCHECK(ctx_);
+      libmcrx_wrapper_->mcrx_ctx_set_log_priority(ctx_, MCRX_LOGLEVEL_INFO);
+      libmcrx_wrapper_->mcrx_ctx_set_log_string_fn(ctx_, this);
+    }
+  }
+
+  // MulticastReceiver is responsible for deleting itself.
+  MulticastReceiver* multicast_receiver = new MulticastReceiver(
+      std::move(client), mcrx_task_runner_, libmcrx_wrapper_.get());
+
+  // It will report an error if |ctx_| is nullptr
+  if (multicast_receiver->Subscribe(
+      std::move(receiver), ctx_, source, group, dorms, port,
+      base::BindOnce(&MulticastReceiverManager::ReceiverUnsubscribed,
+        base::Unretained(this)))) {
+    live_subscriptions_++;
+    if (live_subscriptions_ == 1) {
+      DVLOG(1) << "Started multicast loop";
+      mcrx_task_runner_->PostTask(FROM_HERE,
+          base::BindOnce(&MulticastReceiverManager::ReceivePacketsMrcxSequence,
+            base::Unretained(this)));
+    }
+  } else {
+    DLOG(ERROR) << get_mcrx_log_messages();
+  }
+}
+
+MulticastReceiverManager::MulticastReceiverManager()
+    : mcrx_task_runner_(
+          base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock(),
+            base::TaskPriority::BEST_EFFORT})),
+      ctx_(nullptr),
+      live_subscriptions_(0) {
+  DETACH_FROM_SEQUENCE(mcrx_sequence_checker_);
+}
+
+MulticastReceiverManager::~MulticastReceiverManager() {}
+
+void MulticastReceiverManager::ReceiverUnsubscribed(bool success) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+  DVLOG(1) << "MulticastReceiverManager::ReceiverUnsubscribed";
+
+  live_subscriptions_--;
+
+  if (!success) {
+    DLOG(ERROR) << get_mcrx_log_messages();
+  }
+}
+
+void MulticastReceiverManager::ReceivePacketsMrcxSequence() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+
+  if (live_subscriptions_ == 0) {
+    DVLOG(1) << "Stopped multicast loop";
+    return;
+  }
+
+  int rc;
+  {
+    base::ScopedBlockingCall scoped_blocking(FROM_HERE,
+        base::BlockingType::WILL_BLOCK);
+    rc = libmcrx_wrapper_->mcrx_ctx_receive_packets(ctx_);
+  }
+
+  if (rc != MCRX_ERR_TIMEDOUT && rc != 0) {
+    DLOG(WARNING) << "errored in receive_packets "
+      << " (" << live_subscriptions_ << " subs)";
+    DLOG(ERROR) << get_mcrx_log_messages();
+  }
+
+  mcrx_task_runner_->PostTask(FROM_HERE,
+      base::BindOnce(&MulticastReceiverManager::ReceivePacketsMrcxSequence,
+        base::Unretained(this)));
+}
+
+void MulticastReceiverManager::Log(const char *str) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+
+  if (errors_.tellp() > 4096) {
+    // cap the buffered size of these, just keep the first
+    // messages in hopes of troubleshooting.
+    return;
+  }
+  errors_ << str;
+}
+
+std::string MulticastReceiverManager::get_mcrx_log_messages() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(mcrx_sequence_checker_);
+
+  std::string tmp = errors_.str();
+  errors_.str("");
+  errors_.clear();
+  return tmp;
+}
+
+void MulticastReceiverManager::WakeUpMcrxSequence() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(ui_sequence_checker_);
+  if (ctx_) {
+    libmcrx_wrapper_->mcrx_ctx_roust(ctx_);
+  }
+}
+
+}  // namespace network
diff --git a/content/browser/multicast/multicast_receiver_manager.h b/content/browser/multicast/multicast_receiver_manager.h
new file mode 100644
index 000000000000..d9b8e1db41e7
--- /dev/null
+++ b/content/browser/multicast/multicast_receiver_manager.h
@@ -0,0 +1,83 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_MANAGER_H_
+#define CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_MANAGER_H_
+
+#include <memory>
+#include <sstream>
+#include <string>
+
+#include "base/no_destructor.h"
+#include "base/memory/scoped_refptr.h"
+#include "base/sequence_checker.h"
+#include "base/sequenced_task_runner.h"
+#include "content/browser/multicast/libmcrx_wrapper.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom.h"
+
+namespace network {
+
+class MulticastReceiverManager : LibMcrxLogger {
+  public:
+    // These functions run on |ui_sequence_checker_|
+
+    static MulticastReceiverManager& GetInstance();
+
+    void CreateReceiver(
+        const std::string& source,
+        const std::string& group,
+        const std::string& dorms,
+        uint16_t port,
+        mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+        mojo::PendingRemote<mojom::MulticastReceiverClient> client);
+
+  private:
+    friend class base::NoDestructor<MulticastReceiverManager>;
+
+    // These functions run on |ui_sequence_checker|
+
+    MulticastReceiverManager();
+
+    void WakeUpMcrxSequence();
+
+    // Never called
+    ~MulticastReceiverManager() override;
+
+    // These functions run on |mcrx_sequence_checker|
+
+    void CreateReceiverMcrxSequence(
+        const std::string& source,
+        const std::string& group,
+        const std::string& dorms,
+        uint16_t port,
+        mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+        mojo::PendingRemote<mojom::MulticastReceiverClient> client);
+
+    void ReceivePacketsMrcxSequence();
+
+    void ReceiverUnsubscribed(bool success);
+
+    std::string get_mcrx_log_messages();
+
+    // MulticastLogger implementation:
+    void Log(const char *str) override;
+
+    SEQUENCE_CHECKER(mcrx_sequence_checker_);
+    scoped_refptr<base::SequencedTaskRunner> mcrx_task_runner_;
+
+    SEQUENCE_CHECKER(ui_sequence_checker_);
+
+    mcrx_ctx* ctx_{0};
+
+    uint32_t live_subscriptions_;
+
+    std::unique_ptr<LibMcrxWrapper> libmcrx_wrapper_;
+
+    // Errors reported by libmcrx
+    std::stringstream errors_;
+};
+
+}  // namespace network
+
+#endif  // CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_MANAGER_H_
diff --git a/content/browser/multicast/multicast_receiver_opener_impl.cc b/content/browser/multicast/multicast_receiver_opener_impl.cc
new file mode 100644
index 000000000000..faced6e61477
--- /dev/null
+++ b/content/browser/multicast/multicast_receiver_opener_impl.cc
@@ -0,0 +1,28 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/multicast/multicast_receiver_opener_impl.h"
+
+#include "content/browser/multicast/multicast_receiver_manager.h"
+
+namespace network {
+
+void MulticastReceiverOpenerImpl::Open(
+    const std::string& source,
+    const std::string& group,
+    const std::string& dorms,
+    uint16_t port,
+    mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+    mojo::PendingRemote<mojom::MulticastReceiverClient>
+        receiver_client) {
+  MulticastReceiverManager::GetInstance().CreateReceiver(
+      source,
+      group,
+      dorms,
+      port,
+      std::move(receiver),
+      std::move(receiver_client));
+}
+
+}  // namespace network
\ No newline at end of file
diff --git a/content/browser/multicast/multicast_receiver_opener_impl.h b/content/browser/multicast/multicast_receiver_opener_impl.h
new file mode 100644
index 000000000000..f721fdc411a8
--- /dev/null
+++ b/content/browser/multicast/multicast_receiver_opener_impl.h
@@ -0,0 +1,30 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_OPENER_IMPL_H_
+#define CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_OPENER_IMPL_H_
+
+#include <string>
+
+#include "net/base/network_isolation_key.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom.h"
+#include "url/origin.h"
+
+namespace network {
+
+class MulticastReceiverOpenerImpl final :  public mojom::MulticastReceiverOpener {
+  public:
+    void Open(
+        const std::string& source,
+        const std::string& group,
+        const std::string& dorms,
+        uint16_t port,
+        mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+        mojo::PendingRemote<mojom::MulticastReceiverClient>
+            receiver_client) override;
+};
+
+}  // namespace network
+
+#endif  // CONTENT_BROWSER_MULTICAST_MULTICAST_RECEIVER_OPENER_IMPL_H_
\ No newline at end of file
diff --git a/content/browser/multicast/multicast_receiver_unittest.cc b/content/browser/multicast/multicast_receiver_unittest.cc
new file mode 100644
index 000000000000..88df40bd3139
--- /dev/null
+++ b/content/browser/multicast/multicast_receiver_unittest.cc
@@ -0,0 +1,336 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/multicast/multicast_receiver.h"
+
+#include <string>
+
+#include "base/memory/scoped_refptr.h"
+#include "base/sequenced_task_runner.h"
+//#include "base/test/bind_test_util.h"
+#include "base/test/bind.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/public/test/browser_task_environment.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom.h"
+
+#include "third_party/libmcrx/include/mcrx/libmcrx.h"
+
+namespace network {
+
+namespace {
+
+using testing::StrictMock;
+
+class MockLibMcrxWrapper : public LibMcrxWrapper {
+  public:
+    MOCK_METHOD(mcrx_error_code,
+                mcrx_ctx_new,
+                (struct mcrx_ctx **ctxp),
+                (override));
+
+    MOCK_METHOD(void,
+                mcrx_ctx_set_log_priority,
+                (struct mcrx_ctx *ctx, enum mcrx_log_priority priority),
+                (override));
+
+    MOCK_METHOD(void,
+                mcrx_ctx_set_log_string_fn,
+                (struct mcrx_ctx *ctx, LibMcrxLogger* logger),
+                (override));
+
+    MOCK_METHOD(void,
+                mcrx_ctx_roust,
+                (struct mcrx_ctx *ctx),
+                (override));
+
+    MOCK_METHOD(mcrx_error_code,
+                mcrx_ctx_receive_packets,
+                (struct mcrx_ctx *ctx),
+                (override));
+
+
+    MOCK_METHOD(mcrx_error_code,
+                mcrx_subscription_config_pton,
+                (struct mcrx_subscription_config*, const char*, const char*),
+                (override));
+
+
+    MOCK_METHOD(void,
+                mcrx_subscription_unref,
+                (struct mcrx_subscription*),
+                (override));
+
+    enum mcrx_error_code mcrx_subscription_new(
+        struct mcrx_ctx* ctx,
+        const struct mcrx_subscription_config* config,
+        struct mcrx_subscription** subp) override {
+      *subp = reinterpret_cast<struct mcrx_subscription*>(42);
+      return mcrx_error_code::MCRX_ERR_OK;
+    }
+
+    void mcrx_subscription_set_receive_cb(
+        struct mcrx_subscription*,
+        LibMcrxPacketReceiver* packet_receiver) override {
+      packet_receiver_ = packet_receiver;
+    }
+
+    MOCK_METHOD(mcrx_error_code,
+                mcrx_subscription_join,
+                (struct mcrx_subscription*),
+                (override));
+
+    MOCK_METHOD(mcrx_error_code,
+                mcrx_subscription_leave,
+                (struct mcrx_subscription*),
+                (override));
+
+    uint16_t mcrx_packet_get_contents(
+        struct mcrx_packet*,
+        uint8_t** data) override {
+      *data = reinterpret_cast<uint8_t*>(&packet_[0]);
+      return packet_.size();
+    }
+
+    MOCK_METHOD(void,
+                mcrx_packet_unref,
+                (struct mcrx_packet*),
+                (override));
+
+    int OnPacketReceived(std::string packet) {
+      packet_ = packet;
+      struct mcrx_packet* pkt =
+          reinterpret_cast<struct mcrx_packet*>(&packet_);
+      return packet_receiver_->OnPacketReceived(pkt);
+    }
+
+    ~MockLibMcrxWrapper() override = default;
+
+  private:
+    std::string packet_;
+    LibMcrxPacketReceiver* packet_receiver_;
+};
+
+
+class TestClient final : public mojom::MulticastReceiverClient {
+  public:
+    explicit TestClient(
+        mojo::PendingReceiver<mojom::MulticastReceiverClient> pending_receiver)
+        : receiver_(this, std::move(pending_receiver)) {}
+
+    // mojom::MulticastReceiverClient implementation.
+    void OnDatagram(::base::span<const ::uint8_t> data) override {
+      received_datagram_ = std::string(data.begin(), data.end());
+
+      if (quit_closure_for_datagram_received_) {
+        std::move(quit_closure_for_datagram_received_).Run();
+      }
+    }
+    void OnClose(mojom::MulticastCloseCode close_code,
+                 const std::string& close_message) override {
+      close_code_ = close_code;
+
+      if (quit_closure_for_on_close_) {
+        std::move(quit_closure_for_on_close_).Run();
+      }
+    }
+
+    void WaitUntilDatagramReceived() {
+      base::RunLoop run_loop;
+
+      quit_closure_for_datagram_received_ = run_loop.QuitClosure();
+      run_loop.Run();
+    }
+
+    void WaitUntilOnClosedCalled() {
+      base::RunLoop run_loop;
+
+      quit_closure_for_on_close_ = run_loop.QuitClosure();
+      run_loop.Run();
+    }
+
+    const std::string& received_datagram() const {
+      return received_datagram_;
+    }
+
+    mojom::MulticastCloseCode close_code() const {
+      return close_code_;
+    }
+
+  private:
+    mojo::Receiver<mojom::MulticastReceiverClient> receiver_;
+    std::string received_datagram_;
+
+    mojom::MulticastCloseCode close_code_;
+
+    base::OnceClosure quit_closure_for_datagram_received_;
+    base::OnceClosure quit_closure_for_on_close_;
+};
+
+
+class MulticastReceiverTest : public testing::Test {
+  public:
+    MulticastReceiverTest()
+      : mcrx_task_runner_(base::ThreadPool::CreateSequencedTaskRunner({})) {}
+    ~MulticastReceiverTest() override = default;
+
+    void CreateMulticastReceiver(
+        const std::string& source,
+        const std::string& group,
+        const std::string& dorms,
+        uint16_t port,
+        mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+        mojo::PendingRemote<mojom::MulticastReceiverClient> client,
+        mcrx_ctx* ctx) {
+      mcrx_task_runner_->PostTask(FROM_HERE,
+          base::BindOnce(&MulticastReceiverTest::CreateReceiverMcrxSequence,
+            base::Unretained(this), source, group, dorms, port,
+            std::move(receiver), std::move(client), ctx));
+    }
+
+    void SendPacket(const std::string& packet) {
+      mcrx_task_runner_->PostTask(FROM_HERE,
+          base::BindLambdaForTesting([libmcrx_wrapper = libmcrx_wrapper_.get(),
+          packet] {
+            libmcrx_wrapper->OnPacketReceived(packet);
+          }));
+    }
+
+    int live_subscriptions() {
+      return live_subscriptions_;
+    }
+
+    void WaitUntilSubscribed() {
+      base::RunLoop run_loop;
+
+      quit_closure_after_subscribing_ = run_loop.QuitClosure();
+      run_loop.Run();
+    }
+
+  protected:
+    content::BrowserTaskEnvironment task_environment_;
+
+  private:
+    void CreateReceiverMcrxSequence(
+        const std::string& source,
+        const std::string& group,
+        const std::string& dorms,
+        uint16_t port,
+        mojo::PendingReceiver<mojom::MulticastReceiver> receiver,
+        mojo::PendingRemote<mojom::MulticastReceiverClient> client,
+        mcrx_ctx* ctx) {
+      libmcrx_wrapper_ = std::make_unique<MockLibMcrxWrapper>();
+      auto* multicast_receiver_ = new MulticastReceiver(
+          std::move(client),
+          mcrx_task_runner_,
+          libmcrx_wrapper_.get());
+
+      // |Subscribe| uses base::ScopedBlockingCall hinting that it may block,
+      // so we need this.
+      base::ScopedAllowBlockingForTesting allow_blocking;
+      if (multicast_receiver_->Subscribe(
+          std::move(receiver), ctx, source, group, dorms, port,
+          base::BindLambdaForTesting([&](bool success) {
+            live_subscriptions_--;
+          }))) {
+        live_subscriptions_++;
+      }
+      if (quit_closure_after_subscribing_) {
+        std::move(quit_closure_after_subscribing_).Run();
+      }
+    }
+
+    base::OnceClosure quit_closure_after_subscribing_;
+
+    scoped_refptr<base::SequencedTaskRunner> mcrx_task_runner_;
+
+    int live_subscriptions_ = 0;
+
+    std::unique_ptr<MockLibMcrxWrapper> libmcrx_wrapper_;
+};
+
+TEST_F(MulticastReceiverTest, CannotSubscribeNullMcrxContext) {
+  mojo::PendingRemote<mojom::MulticastReceiverClient> remote_client;
+  TestClient client(remote_client.InitWithNewPipeAndPassReceiver());
+
+  mojo::Remote<mojom::MulticastReceiver> remote;
+  CreateMulticastReceiver("source", "group", "dorms", 5000,
+      remote.BindNewPipeAndPassReceiver(), std::move(remote_client), nullptr);
+
+  client.WaitUntilOnClosedCalled();
+
+  EXPECT_EQ(0, live_subscriptions());
+  EXPECT_EQ(mojom::MulticastCloseCode::ERROR, client.close_code());
+}
+
+TEST_F(MulticastReceiverTest, SubscribeToMulticast) {
+  mojo::PendingRemote<mojom::MulticastReceiverClient> remote_client;
+  TestClient client(remote_client.InitWithNewPipeAndPassReceiver());
+
+  mojo::Remote<mojom::MulticastReceiver> remote;
+  int ctx_handle = 42;
+  struct mcrx_ctx* ctx = reinterpret_cast<struct mcrx_ctx*>(ctx_handle);
+  CreateMulticastReceiver("source", "group", "dorms", 5000,
+      remote.BindNewPipeAndPassReceiver(), std::move(remote_client), ctx);
+
+  WaitUntilSubscribed();
+  EXPECT_EQ(1, live_subscriptions());
+
+  remote->Close();
+  client.WaitUntilOnClosedCalled();
+
+  EXPECT_EQ(0, live_subscriptions());
+  EXPECT_EQ(mojom::MulticastCloseCode::CLOSED_BY_CLIENT, client.close_code());
+}
+
+TEST_F(MulticastReceiverTest, ReceivePacket) {
+  mojo::PendingRemote<mojom::MulticastReceiverClient> remote_client;
+  TestClient client(remote_client.InitWithNewPipeAndPassReceiver());
+
+  mojo::Remote<mojom::MulticastReceiver> remote;
+  int ctx_handle = 42;
+  struct mcrx_ctx* ctx = reinterpret_cast<struct mcrx_ctx*>(ctx_handle);
+  CreateMulticastReceiver("source", "group", "dorms", 5000,
+      remote.BindNewPipeAndPassReceiver(), std::move(remote_client), ctx);
+
+  WaitUntilSubscribed();
+  EXPECT_EQ(1, live_subscriptions());
+
+  std::string sent_data("hello");
+  SendPacket(sent_data);
+  client.WaitUntilDatagramReceived();
+
+  EXPECT_EQ(sent_data, client.received_datagram());
+
+  remote->Close();
+  client.WaitUntilOnClosedCalled();
+
+  EXPECT_EQ(0, live_subscriptions());
+  EXPECT_EQ(mojom::MulticastCloseCode::CLOSED_BY_CLIENT, client.close_code());
+}
+
+TEST_F(MulticastReceiverTest, UnsubscribeDueToMojoError) {
+  mojo::PendingRemote<mojom::MulticastReceiverClient> remote_client;
+  TestClient client(remote_client.InitWithNewPipeAndPassReceiver());
+
+  mojo::Remote<mojom::MulticastReceiver> remote;
+  int ctx_handle = 42;
+  struct mcrx_ctx* ctx = reinterpret_cast<struct mcrx_ctx*>(ctx_handle);
+  CreateMulticastReceiver("source", "group", "dorms", 5000,
+      remote.BindNewPipeAndPassReceiver(), std::move(remote_client), ctx);
+
+  WaitUntilSubscribed();
+  EXPECT_EQ(1, live_subscriptions());
+
+  remote.reset();
+  client.WaitUntilOnClosedCalled();
+
+  EXPECT_EQ(0, live_subscriptions());
+  EXPECT_EQ(mojom::MulticastCloseCode::MOJOM, client.close_code());
+}
+
+}  // namespace
+
+}  // namespace network
diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index 4214b353a946..e22f4b9da9cd 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -72,6 +72,7 @@
 #include "content/browser/media/capture/audio_mirroring_manager.h"
 #include "content/browser/media/media_interface_proxy.h"
 #include "content/browser/media/webaudio/audio_context_manager_impl.h"
+#include "content/browser/multicast/multicast_receiver_opener_impl.h"
 #include "content/browser/navigation_subresource_loader_params.h"
 #include "content/browser/net/cross_origin_embedder_policy_reporter.h"
 #include "content/browser/net/cross_origin_opener_policy_reporter.h"
@@ -7938,6 +7939,13 @@ void RenderFrameHostImpl::CreateQuicTransportConnector(
       std::move(receiver));
 }
 
+void RenderFrameHostImpl::CreateMulticastReceiverOpener(
+    mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver) {
+  mojo::MakeSelfOwnedReceiver(
+      std::make_unique<network::MulticastReceiverOpenerImpl>(),
+      std::move(receiver));
+}
+
 void RenderFrameHostImpl::CreateNotificationService(
     mojo::PendingReceiver<blink::mojom::NotificationService> receiver) {
   GetProcess()->CreateNotificationService(GetLastCommittedOrigin(),
diff --git a/content/browser/renderer_host/render_frame_host_impl.h b/content/browser/renderer_host/render_frame_host_impl.h
index cbdd042aec9b..21ed598ef3c5 100644
--- a/content/browser/renderer_host/render_frame_host_impl.h
+++ b/content/browser/renderer_host/render_frame_host_impl.h
@@ -125,6 +125,7 @@
 #include "third_party/blink/public/mojom/installedapp/installed_app_provider.mojom.h"
 #include "third_party/blink/public/mojom/loader/resource_load_info.mojom-forward.h"
 #include "third_party/blink/public/mojom/loader/transferrable_url_loader.mojom.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom.h"
 #include "third_party/blink/public/mojom/notifications/notification_service.mojom-forward.h"
 #include "third_party/blink/public/mojom/payments/payment_app.mojom.h"
 #include "third_party/blink/public/mojom/permissions/permission.mojom.h"
@@ -1421,6 +1422,9 @@ class CONTENT_EXPORT RenderFrameHostImpl
   void CreateQuicTransportConnector(
       mojo::PendingReceiver<blink::mojom::QuicTransportConnector> receiver);
 
+  void CreateMulticastReceiverOpener(
+      mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver);
+
   void CreateNotificationService(
       mojo::PendingReceiver<blink::mojom::NotificationService> receiver);
 
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 7e36c27d59e0..fd2a04094aa2 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -106,6 +106,7 @@
 #include "content/browser/media/capture/audio_mirroring_manager.h"
 #include "content/browser/media/media_internals.h"
 #include "content/browser/mime_registry_impl.h"
+#include "content/browser/multicast/multicast_receiver_opener_impl.h"
 #include "content/browser/native_io/native_io_context.h"
 #include "content/browser/navigation_subresource_loader_params.h"
 #include "content/browser/network_service_instance_impl.h"
@@ -2113,6 +2114,21 @@ void RenderProcessHostImpl::CreateWebSocketConnector(
       std::move(receiver));
 }
 
+void RenderProcessHostImpl::CreateMulticastReceiverOpener(
+    const url::Origin& origin,
+    mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver) {
+  // TODO(jam): is it ok to not send extraHeaders for sockets created from
+  // shared and service workers?
+  //
+  // Shared Workers and service workers are not directly associated with a
+  // frame, so the concept of "top-level frame" does not exist. Can use
+  // (origin, origin) for the NetworkIsolationKey for requests because these
+  // workers can only be created when the site has cookie access.
+  mojo::MakeSelfOwnedReceiver(
+      std::make_unique<network::MulticastReceiverOpenerImpl>(),
+      std::move(receiver));
+}
+
 void RenderProcessHostImpl::CancelProcessShutdownDelayForUnload() {
   if (IsKeepAliveRefCountDisabled())
     return;
diff --git a/content/browser/renderer_host/render_process_host_impl.h b/content/browser/renderer_host/render_process_host_impl.h
index cb236a188db0..5646d3f5e3d5 100644
--- a/content/browser/renderer_host/render_process_host_impl.h
+++ b/content/browser/renderer_host/render_process_host_impl.h
@@ -655,6 +655,11 @@ class CONTENT_EXPORT RenderProcessHostImpl
       mojo::PendingReceiver<blink::mojom::WebSocketConnector> receiver)
       override;
 
+  void CreateMulticastReceiverOpener(
+      const url::Origin& origin,
+      mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver)
+      override;
+
   // Allows |process_id| to use an additional |allowed_request_initiator|
   // (bypassing |request_initiator_origin_lock| enforcement).
   //
diff --git a/content/browser/service_worker/service_worker_host.cc b/content/browser/service_worker/service_worker_host.cc
index a487d57cc1ae..4540e9524014 100644
--- a/content/browser/service_worker/service_worker_host.cc
+++ b/content/browser/service_worker/service_worker_host.cc
@@ -15,6 +15,7 @@
 #include "content/browser/service_worker/service_worker_context_core.h"
 #include "content/browser/service_worker/service_worker_version.h"
 #include "content/browser/webtransport/quic_transport_connector_impl.h"
+#include "content/browser/multicast/multicast_receiver_opener_impl.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/render_process_host.h"
 #include "content/public/browser/storage_partition.h"
@@ -45,6 +46,19 @@ void CreateQuicTransportConnectorImpl(
       std::move(receiver));
 }
 
+void CreateMulticastReceiverOpenerImpl(
+    int process_id,
+    mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  auto* process = RenderProcessHost::FromID(process_id);
+  if (!process)
+    return;
+
+  mojo::MakeSelfOwnedReceiver(
+      std::make_unique<network::MulticastReceiverOpenerImpl>(),
+      std::move(receiver));
+}
+
 }  // anonymous namespace
 
 ServiceWorkerHost::ServiceWorkerHost(
@@ -124,4 +138,13 @@ void ServiceWorkerHost::ReportNoBinderForInterface(const std::string& error) {
   broker_receiver_.ReportBadMessage(error + " for the service worker scope");
 }
 
+void ServiceWorkerHost::CreateMulticastReceiverOpener(
+    mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver) {
+  DCHECK_CURRENTLY_ON(ServiceWorkerContext::GetCoreThreadId());
+  RunOrPostTaskOnThread(
+      FROM_HERE, BrowserThread::UI,
+      base::BindOnce(&CreateMulticastReceiverOpenerImpl, worker_process_id_,
+                     std::move(receiver)));
+}
+
 }  // namespace content
diff --git a/content/browser/service_worker/service_worker_host.h b/content/browser/service_worker/service_worker_host.h
index 66209812759e..e49eddc5f73e 100644
--- a/content/browser/service_worker/service_worker_host.h
+++ b/content/browser/service_worker/service_worker_host.h
@@ -31,6 +31,7 @@
 #include "third_party/blink/public/mojom/service_worker/service_worker_provider.mojom.h"
 #include "third_party/blink/public/mojom/web_feature/web_feature.mojom.h"
 #include "third_party/blink/public/mojom/webtransport/quic_transport_connector.mojom.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom-forward.h"
 #include "url/origin.h"
 
 namespace content {
@@ -65,6 +66,10 @@ class CONTENT_EXPORT ServiceWorkerHost {
 
   void CreateQuicTransportConnector(
       mojo::PendingReceiver<blink::mojom::QuicTransportConnector> receiver);
+
+  void CreateMulticastReceiverOpener(
+     mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver);
+
   // Used only when EagerCacheStorageSetupForServiceWorkers is disabled.
   void BindCacheStorage(
       mojo::PendingReceiver<blink::mojom::CacheStorage> receiver);
diff --git a/content/browser/worker_host/dedicated_worker_host.cc b/content/browser/worker_host/dedicated_worker_host.cc
index 6f9581fb978c..c9ebcafaa9e8 100644
--- a/content/browser/worker_host/dedicated_worker_host.cc
+++ b/content/browser/worker_host/dedicated_worker_host.cc
@@ -19,6 +19,7 @@
 #include "content/browser/url_loader_factory_params_helper.h"
 #include "content/browser/websockets/websocket_connector_impl.h"
 #include "content/browser/webtransport/quic_transport_connector_impl.h"
+#include "content/browser/multicast/multicast_receiver_opener_impl.h"
 #include "content/browser/worker_host/dedicated_worker_host_factory_impl.h"
 #include "content/browser/worker_host/dedicated_worker_service_impl.h"
 #include "content/browser/worker_host/worker_script_fetch_initiator.h"
@@ -415,6 +416,21 @@ void DedicatedWorkerHost::CreateQuicTransportConnector(
       std::move(receiver));
 }
 
+void DedicatedWorkerHost::CreateMulticastReceiverOpener(
+    mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  RenderFrameHostImpl* ancestor_render_frame_host =
+      RenderFrameHostImpl::FromID(ancestor_render_frame_host_id_);
+  if (!ancestor_render_frame_host) {
+    // The ancestor frame may have already been closed. In that case, the worker
+    // will soon be terminated too, so abort the connection.
+    return;
+  }
+  mojo::MakeSelfOwnedReceiver(
+      std::make_unique<network::MulticastReceiverOpenerImpl>(),
+      std::move(receiver));
+}
+
 void DedicatedWorkerHost::CreateWakeLockService(
     mojo::PendingReceiver<blink::mojom::WakeLockService> receiver) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
diff --git a/content/browser/worker_host/dedicated_worker_host.h b/content/browser/worker_host/dedicated_worker_host.h
index 4efb8d17392a..d1fdfcb7932c 100644
--- a/content/browser/worker_host/dedicated_worker_host.h
+++ b/content/browser/worker_host/dedicated_worker_host.h
@@ -23,6 +23,7 @@
 #include "third_party/blink/public/common/tokens/tokens.h"
 #include "third_party/blink/public/mojom/idle/idle_manager.mojom-forward.h"
 #include "third_party/blink/public/mojom/loader/content_security_notifier.mojom.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom-forward.h"
 #include "third_party/blink/public/mojom/sms/webotp_service.mojom-forward.h"
 #include "third_party/blink/public/mojom/usb/web_usb_service.mojom-forward.h"
 #include "third_party/blink/public/mojom/wake_lock/wake_lock.mojom-forward.h"
@@ -90,6 +91,8 @@ class DedicatedWorkerHost final : public RenderProcessHostObserver {
       mojo::PendingReceiver<blink::mojom::WebSocketConnector> receiver);
   void CreateQuicTransportConnector(
       mojo::PendingReceiver<blink::mojom::QuicTransportConnector> receiver);
+  void CreateMulticastReceiverOpener(
+      mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver);
   void CreateWakeLockService(
       mojo::PendingReceiver<blink::mojom::WakeLockService> receiver);
   void BindCacheStorage(
diff --git a/content/browser/worker_host/shared_worker_host.cc b/content/browser/worker_host/shared_worker_host.cc
index 59f5f31fad2f..9d1bc04ce902 100644
--- a/content/browser/worker_host/shared_worker_host.cc
+++ b/content/browser/worker_host/shared_worker_host.cc
@@ -15,6 +15,7 @@
 #include "content/browser/appcache/appcache_navigation_handle.h"
 #include "content/browser/devtools/devtools_instrumentation.h"
 #include "content/browser/devtools/shared_worker_devtools_manager.h"
+#include "content/browser/multicast/multicast_receiver_opener_impl.h"
 #include "content/browser/renderer_host/render_frame_host_impl.h"
 #include "content/browser/service_worker/service_worker_main_resource_handle.h"
 #include "content/browser/service_worker/service_worker_object_host.h"
@@ -378,6 +379,13 @@ void SharedWorkerHost::CreateQuicTransportConnector(
                               std::move(receiver));
 }
 
+void SharedWorkerHost::CreateMulticastReceiverOpener(
+    mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  mojo::MakeSelfOwnedReceiver(std::make_unique<network::MulticastReceiverOpenerImpl>(),
+                              std::move(receiver));
+}
+
 void SharedWorkerHost::BindCacheStorage(
     mojo::PendingReceiver<blink::mojom::CacheStorage> receiver) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
diff --git a/content/browser/worker_host/shared_worker_host.h b/content/browser/worker_host/shared_worker_host.h
index c6df40bc457c..ca4de67827f7 100644
--- a/content/browser/worker_host/shared_worker_host.h
+++ b/content/browser/worker_host/shared_worker_host.h
@@ -33,6 +33,7 @@
 #include "third_party/blink/public/common/tokens/tokens.h"
 #include "third_party/blink/public/mojom/appcache/appcache.mojom.h"
 #include "third_party/blink/public/mojom/devtools/devtools_agent.mojom.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom-forward.h"
 #include "third_party/blink/public/mojom/payments/payment_app.mojom-forward.h"
 #include "third_party/blink/public/mojom/service_worker/service_worker_provider.mojom.h"
 #include "third_party/blink/public/mojom/webtransport/quic_transport_connector.mojom.h"
@@ -112,6 +113,8 @@ class CONTENT_EXPORT SharedWorkerHost : public blink::mojom::SharedWorkerHost,
       mojo::PendingReceiver<blink::mojom::AppCacheBackend> receiver);
   void CreateQuicTransportConnector(
       mojo::PendingReceiver<blink::mojom::QuicTransportConnector> receiver);
+  void CreateMulticastReceiverOpener(
+      mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver);
   void BindCacheStorage(
       mojo::PendingReceiver<blink::mojom::CacheStorage> receiver);
 
diff --git a/content/public/browser/render_process_host.h b/content/public/browser/render_process_host.h
index ef51dcc952e1..b6d18ebffd96 100644
--- a/content/public/browser/render_process_host.h
+++ b/content/public/browser/render_process_host.h
@@ -39,6 +39,7 @@
 #include "third_party/blink/public/mojom/filesystem/file_system.mojom-forward.h"
 #include "third_party/blink/public/mojom/indexeddb/indexeddb.mojom-forward.h"
 #include "third_party/blink/public/mojom/locks/lock_manager.mojom-forward.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom-forward.h"
 #include "third_party/blink/public/mojom/native_io/native_io.mojom-forward.h"
 #include "third_party/blink/public/mojom/notifications/notification_service.mojom-forward.h"
 #include "third_party/blink/public/mojom/payments/payment_app.mojom-forward.h"
@@ -527,6 +528,10 @@ class CONTENT_EXPORT RenderProcessHost : public IPC::Sender,
   virtual void CreateWebSocketConnector(
       const url::Origin& origin,
       mojo::PendingReceiver<blink::mojom::WebSocketConnector> receiver) = 0;
+  virtual void CreateMulticastReceiverOpener(
+      const url::Origin& origin,
+      mojo::PendingReceiver<network::mojom::MulticastReceiverOpener>
+        receiver) = 0;
 
   // Returns the current number of active views in this process.  Excludes
   // any RenderViewHosts that are swapped out.
diff --git a/content/public/test/mock_render_process_host.h b/content/public/test/mock_render_process_host.h
index 4630d2a8d6dc..4f5740b794f7 100644
--- a/content/public/test/mock_render_process_host.h
+++ b/content/public/test/mock_render_process_host.h
@@ -219,6 +219,10 @@ class MockRenderProcessHost : public RenderProcessHost {
       const url::Origin& origin,
       mojo::PendingReceiver<blink::mojom::WebSocketConnector> receiver)
       override {}
+  void CreateMulticastReceiverOpener(
+      const url::Origin& origin,
+      mojo::PendingReceiver<network::mojom::MulticastReceiverOpener> receiver)
+      override {}
 
   void CleanupNetworkServicePluginExceptionsUponDestruction() override;
   std::string GetInfoForBrowserContextDestructionCrashReporting() override;
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index 7c3a5f56b313..b2c5978cc9e1 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -446,6 +446,7 @@ static_library("test_support") {
     "//testing/gtest",
     "//third_party/blink/public/strings:strings_grit",
     "//third_party/webrtc_overrides:webrtc_component",
+    "//third_party/libmcrx:mcrx",
     "//ui/accessibility:ax_enums_mojo",
     "//ui/base",
     "//ui/base:test_support",
@@ -1882,6 +1883,7 @@ test("content_unittests") {
     "../browser/memory/swap_metrics_driver_impl_unittest.cc",
     "../browser/mojo_binder_policy_applier_unittest.cc",
     "../browser/mojo_binder_policy_map_impl_unittest.cc",
+    "../browser/multicast/multicast_receiver_unittest.cc",
     "../browser/native_io/native_io_manager_unittest.cc",
     "../browser/net/cross_origin_embedder_policy_reporter_unittest.cc",
     "../browser/net/cross_origin_opener_policy_reporter_unittest.cc",
@@ -2286,6 +2288,7 @@ test("content_unittests") {
     "//third_party/sqlite",
     "//third_party/widevine/cdm:headers",
     "//third_party/zlib/google:compression_utils",
+    "//third_party/libmcrx:mcrx",
     "//ui/accessibility",
     "//ui/accessibility:test_support",
     "//ui/base:test_support",
diff --git a/third_party/blink/public/mojom/BUILD.gn b/third_party/blink/public/mojom/BUILD.gn
index a96bd8fc65f9..7e2f8cf77efd 100644
--- a/third_party/blink/public/mojom/BUILD.gn
+++ b/third_party/blink/public/mojom/BUILD.gn
@@ -118,6 +118,7 @@ mojom("mojom_platform") {
     "mediastream/media_devices.mojom",
     "mediastream/media_stream.mojom",
     "mime/mime_registry.mojom",
+    "multicast/multicast.mojom",
     "native_io/native_io.mojom",
     "notifications/notification.mojom",
     "notifications/notification_service.mojom",
diff --git a/third_party/blink/public/mojom/multicast/multicast.mojom b/third_party/blink/public/mojom/multicast/multicast.mojom
new file mode 100644
index 000000000000..7314e12678bd
--- /dev/null
+++ b/third_party/blink/public/mojom/multicast/multicast.mojom
@@ -0,0 +1,47 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// TODO(cworm): We need to figure out how many libmcrx contexts that should be
+// created and if that should somehow be reflected in this API.
+
+module network.mojom;
+
+import "mojo/public/mojom/base/read_only_buffer.mojom";
+
+// Interface implemented by the browser and called by the renderer.
+interface MulticastReceiverOpener {
+  Open(string source, string group, string dorms, uint16 port,
+    pending_receiver<MulticastReceiver> multicast_receiver,
+    pending_remote<MulticastReceiverClient> multicast_receiver_client);
+};
+
+// These must match the error codes in multicast_receiver.idl
+enum MulticastCloseCode {
+  // Internal errors are negative.
+  MOJOM = -1,
+
+  // Not closed yet.
+  RUNNING = 0,
+
+  // Closed due to call to MulticastReceiver::Close():
+  CLOSED_BY_CLIENT=1,
+
+  // Closed due to some multicast problem. More can be added.
+  ERROR = 2
+};
+
+interface MulticastReceiver {
+  // Call this to stop the receiver. This will result in MulticastReceiverClient
+  // being called with a CLOSED_BY_CLIENT close code.
+  Close();
+};
+
+interface MulticastReceiverClient {
+  // Is called for each multicast datagram with the content of the datagram.
+  OnDatagram(mojo_base.mojom.ReadOnlyBuffer data);
+
+  // Is called when OnDatagram will not be called again. Must only be called
+  // one time. The close_code must be different from RUNNING.
+  OnClose(MulticastCloseCode close_code, string close_message);
+};
diff --git a/third_party/blink/renderer/bindings/generated_in_modules.gni b/third_party/blink/renderer/bindings/generated_in_modules.gni
index 1402bb169061..8398e357611c 100644
--- a/third_party/blink/renderer/bindings/generated_in_modules.gni
+++ b/third_party/blink/renderer/bindings/generated_in_modules.gni
@@ -88,6 +88,8 @@ generated_callback_interface_sources_in_modules = [
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_file_writer_callback.h",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_metadata_callback.cc",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_metadata_callback.h",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_multicast_receiver.cc",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_multicast_receiver.h",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_sql_statement_callback.cc",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_sql_statement_callback.h",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_sql_statement_error_callback.cc",
@@ -869,6 +871,8 @@ generated_dictionary_sources_in_modules = [
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_transient_input_hit_test_options_init.h",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_layer_init.cc",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_layer_init.h",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_multicast_receiver_config.cc",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_multicast_receiver_config.h",
 ]
 
 generated_enumeration_sources_in_modules = [
diff --git a/third_party/blink/renderer/bindings/idl_in_modules.gni b/third_party/blink/renderer/bindings/idl_in_modules.gni
index f2ce1e2e644f..e7b8f8fe834b 100644
--- a/third_party/blink/renderer/bindings/idl_in_modules.gni
+++ b/third_party/blink/renderer/bindings/idl_in_modules.gni
@@ -396,6 +396,8 @@ static_idl_files_in_modules = get_path_info(
           "//third_party/blink/renderer/modules/mediastream/media_track_constraints.idl",
           "//third_party/blink/renderer/modules/mediastream/media_track_settings.idl",
           "//third_party/blink/renderer/modules/mediastream/media_track_supported_constraints.idl",
+          "//third_party/blink/renderer/modules/multicast/multicast_receiver.idl",
+          "//third_party/blink/renderer/modules/multicast/multicast_receiver_config.idl",
           "//third_party/blink/renderer/modules/mediastream/navigator_media_stream.idl",
           "//third_party/blink/renderer/modules/mediastream/navigator_user_media.idl",
           "//third_party/blink/renderer/modules/mediastream/overconstrained_error.idl",
diff --git a/third_party/blink/renderer/modules/BUILD.gn b/third_party/blink/renderer/modules/BUILD.gn
index edd4884efdb3..eeae6f43247b 100644
--- a/third_party/blink/renderer/modules/BUILD.gn
+++ b/third_party/blink/renderer/modules/BUILD.gn
@@ -130,6 +130,7 @@ component("modules") {
     "//third_party/blink/renderer/modules/mediasource",
     "//third_party/blink/renderer/modules/mediastream",
     "//third_party/blink/renderer/modules/media",
+    "//third_party/blink/renderer/modules/multicast",
     "//third_party/blink/renderer/modules/webrtc",
     "//third_party/blink/renderer/modules/native_io",
     "//third_party/blink/renderer/modules/navigatorcontentutils",
@@ -518,6 +519,7 @@ source_set("unit_tests") {
     "//third_party/blink/renderer/modules/indexeddb:unit_tests",
     "//third_party/blink/renderer/modules/mediarecorder:buildflags",
     "//third_party/blink/renderer/modules/mediastream:test_support",
+    "//third_party/blink/renderer/modules/multicast:unit_tests",
     "//third_party/blink/renderer/modules/peerconnection:test_support",
     "//third_party/blink/renderer/modules/storage:unit_tests",
     "//third_party/blink/renderer/modules/webcodecs:unit_tests",
diff --git a/third_party/blink/renderer/modules/event_target_modules_names.json5 b/third_party/blink/renderer/modules/event_target_modules_names.json5
index 5ba2efe3026a..e31b2e2150ec 100644
--- a/third_party/blink/renderer/modules/event_target_modules_names.json5
+++ b/third_party/blink/renderer/modules/event_target_modules_names.json5
@@ -34,6 +34,7 @@
     "MediaDevices",
     "MediaStream",
     "MediaStreamTrack",
+    "MulticastReceiver",
     "RTCDTMFSender",
     "RTCDataChannel",
     "RTCDtlsTransport",
diff --git a/third_party/blink/renderer/modules/modules_idl_files.gni b/third_party/blink/renderer/modules/modules_idl_files.gni
index e7828a83bfb5..594677a4a0f5 100644
--- a/third_party/blink/renderer/modules/modules_idl_files.gni
+++ b/third_party/blink/renderer/modules/modules_idl_files.gni
@@ -96,6 +96,7 @@ _idl_imports = [
   "//third_party/blink/renderer/modules/mediasession/idls.gni",
   "//third_party/blink/renderer/modules/mediasource/idls.gni",
   "//third_party/blink/renderer/modules/mediastream/idls.gni",
+  "//third_party/blink/renderer/modules/multicast/idls.gni",
   "//third_party/blink/renderer/modules/native_io/idls.gni",
   "//third_party/blink/renderer/modules/navigatorcontentutils/idls.gni",
   "//third_party/blink/renderer/modules/netinfo/idls.gni",
diff --git a/third_party/blink/renderer/modules/multicast/BUILD.gn b/third_party/blink/renderer/modules/multicast/BUILD.gn
new file mode 100644
index 000000000000..32e9a86f6f52
--- /dev/null
+++ b/third_party/blink/renderer/modules/multicast/BUILD.gn
@@ -0,0 +1,33 @@
+# Copyright 2020 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//third_party/blink/renderer/modules/modules.gni")
+
+blink_modules_sources("multicast") {
+  sources = [
+    "multicast_receiver.h",
+    "multicast_receiver.cc"
+  ]
+}
+
+source_set("unit_tests") {
+  testonly = true
+  sources = [
+    "multicast_receiver_test.cc",
+  ]
+
+  configs += [
+    "//third_party/blink/renderer:config",
+    "//third_party/blink/renderer:inside_blink",
+    "//third_party/blink/renderer/core:blink_core_pch",
+  ]
+
+  deps = [
+    "//testing/gmock",
+    "//testing/gtest",
+    "//third_party/blink/renderer/modules",
+    "//third_party/blink/renderer/platform",
+    "//third_party/blink/renderer/platform/wtf",
+  ]
+}
diff --git a/third_party/blink/renderer/modules/multicast/idls.gni b/third_party/blink/renderer/modules/multicast/idls.gni
new file mode 100644
index 000000000000..90255e0b15d6
--- /dev/null
+++ b/third_party/blink/renderer/modules/multicast/idls.gni
@@ -0,0 +1,11 @@
+# Copyright 2020 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+modules_idl_files = [
+  "multicast_receiver.idl",
+]
+
+modules_dictionary_idl_files = [
+  "multicast_receiver_config.idl",
+]
diff --git a/third_party/blink/renderer/modules/multicast/multicast_receiver.cc b/third_party/blink/renderer/modules/multicast/multicast_receiver.cc
new file mode 100644
index 000000000000..58c95dcfdbdc
--- /dev/null
+++ b/third_party/blink/renderer/modules/multicast/multicast_receiver.cc
@@ -0,0 +1,278 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/modules/multicast/multicast_receiver.h"
+
+#include "third_party/blink/public/common/browser_interface_broker_proxy.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom-blink.h"
+#include "third_party/blink/public/platform/task_type.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_throw_dom_exception.h"
+#include "third_party/blink/renderer/core/dom/events/event.h"
+#include "third_party/blink/renderer/core/execution_context/execution_context.h"
+#include "third_party/blink/renderer/core/streams/count_queuing_strategy.h"
+#include "third_party/blink/renderer/core/streams/readable_stream.h"
+#include "third_party/blink/renderer/core/streams/readable_stream_default_controller_with_script_scope.h"
+#include "third_party/blink/renderer/core/streams/underlying_sink_base.h"
+#include "third_party/blink/renderer/core/streams/underlying_source_base.h"
+#include "third_party/blink/renderer/core/typed_arrays/dom_typed_array.h"
+#include "third_party/blink/renderer/modules/multicast/multicast_receiver_config.h"
+#include "third_party/blink/renderer/platform/bindings/exception_state.h"
+
+#include <algorithm>
+
+namespace blink {
+
+using network::mojom::blink::MulticastCloseCode;
+
+constexpr unsigned MulticastReceiver::kCloseCodeRunning;
+constexpr unsigned MulticastReceiver::kCloseCodeCanceled;
+constexpr unsigned MulticastReceiver::kCloseCodeError;
+
+// The underlying source.
+//
+// It doesn't do much except beeing an UnderlyingSource
+// and telling the MulticastReceiver when it is started and canceled.
+class MulticastReceiver::DatagramUnderlyingSource final
+    : public UnderlyingSourceBase {
+ public:
+  DatagramUnderlyingSource(ScriptState* script_state,
+                           MulticastReceiver* multicast_receiver)
+      : UnderlyingSourceBase(script_state),
+        multicast_receiver_(multicast_receiver) {}
+
+  ScriptPromise Start(ScriptState* script_state) override {
+    multicast_receiver_->UnderlyingSourceStarted(Controller());
+    return ScriptPromise::CastUndefined(script_state);
+  }
+
+  ScriptPromise pull(ScriptState* script_state) override {
+    return ScriptPromise::CastUndefined(script_state);
+  }
+
+  ScriptPromise Cancel(ScriptState* script_state, ScriptValue reason) override {
+    multicast_receiver_->UnderlyingSourceCanceled();
+    return ScriptPromise::CastUndefined(script_state);
+  }
+
+  void Trace(Visitor* visitor) const override {
+    visitor->Trace(multicast_receiver_);
+    UnderlyingSourceBase::Trace(visitor);
+  }
+
+ private:
+  // This pointer prevents MulticastReceiver from being Garbage Collected
+  // for as long as the multicast can be cancled from JavaScript.
+  // See the discussion at the top of multicast_receiver.h.
+  Member<MulticastReceiver> multicast_receiver_;
+};
+
+MulticastReceiver* MulticastReceiver::Create(ScriptState* script_state,
+                                             MulticastReceiverConfig* config,
+                                             ExceptionState& exception_state) {
+  // TODO(cworm): Webtransport seems to have just a single packet in the queue
+  // where we default to 100. Having just a single packet seems to be very bad
+  // as the queue then can likely overflow very quickly. The webtransport code
+  // has comments about problems with the queue - but these comments seem to be
+  // related to the fact that they want to drop old rather than new packets
+  // when the queue is full.
+  return Create(script_state, config, 100, exception_state);
+}
+
+MulticastReceiver* MulticastReceiver::Create(ScriptState* script_state,
+                                             MulticastReceiverConfig* config,
+                                             uint32_t queue_size_in_packets,
+                                             ExceptionState& exception_state) {
+  DVLOG(1) << "MulticastReceiver::Create " << queue_size_in_packets;
+
+  MulticastReceiver* result =
+      MakeGarbageCollected<MulticastReceiver>(script_state);
+
+  result->Init(config, queue_size_in_packets, exception_state);
+
+  return result;
+}
+
+
+MulticastReceiver::MulticastReceiver(ScriptState* script_state)
+    : ExecutionContextLifecycleObserver(ExecutionContext::From(script_state)),
+      script_state_(script_state) {
+#ifdef MULTICAST_API_PROFILING
+  char* max_packet_size=getenv("MAX_PACKET_SIZE");
+  if(max_packet_size) max_packet_size_=atoi(max_packet_size);
+#endif
+}
+
+void MulticastReceiver::Init(MulticastReceiverConfig* config,
+                             uint32_t queue_size_in_packets,
+                             ExceptionState& exception_state) {
+  DVLOG(1) << "MulticastReceiver::Init() {";
+
+  // Parse configuration:
+  if (!config->hasSource() || !config->hasGroup() || !config->hasDorms() ||
+      !config->hasPort() || config->port() == 0) {
+    exception_state.ThrowDOMException(
+        DOMExceptionCode::kSyntaxError,
+        "The provided configuration was not complete");
+    return;
+  }
+
+  // Save configuration:
+  source_ = config->source();
+  group_ = config->group();
+  dorms_ = config->dorms();
+  port_ = config->port();
+
+  // Make sure queue_size_in_packets is valid:
+  queue_size_in_packets = std::max(1u, queue_size_in_packets);
+
+  // Create the ReadableStream.
+  received_datagrams_ = ReadableStream::CreateWithCountQueueingStrategy(
+      script_state_,
+      MakeGarbageCollected<DatagramUnderlyingSource>(script_state_, this),
+      queue_size_in_packets);
+
+  // TODO(cworm): We should probably check that we are allowed to connect to
+  // the DORMS server like webtransport checks that it is allowed to connect to
+  // the provided URL.
+
+  DVLOG(1) << "MulticastReceiver::Init() }";
+}
+
+void MulticastReceiver::UnderlyingSourceStarted(
+    ReadableStreamDefaultControllerWithScriptScope* controller) {
+  // This function is called before Init returns. However, its implemenation
+  // does not rely on that.
+
+  DVLOG(1) << "MulticastReceiver::UnderlyingSourceStarted {";
+
+  auto* execution_context = GetExecutionContext();
+  if (!execution_context)
+    return;
+
+  // Save controller:
+  received_datagrams_controller_ = controller;
+
+  // Connect with mojom to start to let the multicast data flow.
+  mojo::Remote<network::mojom::blink::MulticastReceiverOpener> connector;
+  execution_context->GetBrowserInterfaceBroker().GetInterface(
+      connector.BindNewPipeAndPassReceiver(
+          execution_context->GetTaskRunner(TaskType::kNetworking)));
+
+  scoped_refptr<base::SequencedTaskRunner> task_runner =
+      execution_context->GetTaskRunner(TaskType::kNetworking);
+  connector->Open(source_, group_, dorms_, port_,
+                  remote_.BindNewPipeAndPassReceiver(task_runner),
+                  receiver_.BindNewPipeAndPassRemote(task_runner));
+
+  // TODO(cworm): quic_transport sets up mojom disconnect handlers, so we do the
+  // same here. It is not totally clear to me that it is needed. Possibly,
+  // quic_transport has an expected case where a disconnect may happen that
+  // we do not have (?).
+
+  receiver_.set_disconnect_handler(
+      WTF::Bind(&MulticastReceiver::OnClose, WrapWeakPersistent(this),
+                MulticastCloseCode::MOJOM, WTF::String("Mojo error")));
+
+  DVLOG(1) << "MulticastReceiver::UnderlyingSourceStarted }";
+}
+
+void MulticastReceiver::UnderlyingSourceCanceled() {
+  DVLOG(1) << "MulticastReceiver::UnderlyingSourceCanceled";
+
+  if (!GetExecutionContext())
+    return;
+
+  received_datagrams_controller_->NoteHasBeenCanceled();
+  if (close_code_ == MulticastCloseCode::RUNNING) {
+    close_code_ = MulticastCloseCode::CLOSED_BY_CLIENT;
+  }
+
+  // Tell the browser side to close gracefully.
+  DCHECK(remote_);  // Dispose should not have been called here..
+  remote_->Close();
+}
+
+
+void MulticastReceiver::OnDatagram(::base::span<const ::uint8_t> data) {
+  DVLOG(1) << "MulticastReceiver::OnDatagram()";
+
+  ReadableStreamDefaultControllerWithScriptScope* controller =
+      received_datagrams_controller_;
+
+  // This will enqueue into the queue of size queue_size_in_packets.
+  // Note that when it is full, we will drop the new packets rather than
+  // the old  packets.
+
+  // TODO(cworm): quic_transport makes sure not to enqueue after cancel
+  // has been called. But since we have called NoteHasBeenCanceled in
+  // that case, this code should do no harm.
+#ifdef MULTICAST_API_PROFILING
+  if(max_packet_size_==0) {
+    // No special configuration
+#endif
+    if (controller->DesiredSize() > 0) {
+      DVLOG(1) << "MulticastReceiver::OnDatagram(): Enqueued";
+        auto* array = DOMUint8Array::Create(
+            data.data(), base::checked_cast<wtf_size_t>(data.size()));
+        controller->Enqueue(array);
+    } else {
+      DVLOG(1) << "MulticastReceiver::OnDatagram(): Dropped";
+    }
+#ifdef MULTICAST_API_PROFILING
+  } else {
+    // Split packets
+    size_t size=data.size();
+    for(size_t start=0; start<size;start+=max_packet_size_) {
+      if(controller->DesiredSize() <= 0) break;
+      size_t len=std::min(max_packet_size_,size-start);
+      auto* array = DOMUint8Array::Create(
+          data.data()+start, base::checked_cast<wtf_size_t>(len));
+      controller->Enqueue(array);
+    }
+  }
+#endif
+}
+
+void MulticastReceiver::OnClose(MulticastCloseCode close_code,
+                                const WTF::String& close_message) {
+  DVLOG(1) << "MulticastReceiver::OnClose " << close_code << " "
+           << close_message << "{";
+
+  if (!GetExecutionContext())
+    return;
+
+  DCHECK(close_code != MulticastCloseCode::RUNNING);
+  if (close_code_ != MulticastCloseCode::RUNNING)
+    return;
+  close_code_ = close_code;
+
+  // TODO(dt): This seems to cause a crash when it is run
+  received_datagrams_controller_->Error(V8ThrowDOMException::CreateOrEmpty(
+      script_state_->GetIsolate(), DOMExceptionCode::kNetworkError,
+      close_message));
+
+  DVLOG(1) << "MulticastReceiver::OnClose }";
+}
+
+void MulticastReceiver::Trace(Visitor* visitor) const  {
+  ExecutionContextLifecycleObserver::Trace(visitor);
+  ScriptWrappable::Trace(visitor);
+  visitor->Trace(script_state_);
+  visitor->Trace(received_datagrams_);
+  visitor->Trace(received_datagrams_controller_);
+}
+
+void MulticastReceiver::ContextDestroyed() {
+  Dispose();
+}
+
+void MulticastReceiver::Dispose() {
+  DVLOG(1) << "MulticastReceiver::Dispose";
+
+  // Make sure we do not get any more callbacks:
+  remote_.reset();
+  receiver_.reset();
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/multicast/multicast_receiver.h b/third_party/blink/renderer/modules/multicast/multicast_receiver.h
new file mode 100644
index 000000000000..add6e1870528
--- /dev/null
+++ b/third_party/blink/renderer/modules/multicast/multicast_receiver.h
@@ -0,0 +1,167 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_MULTICAST_MULTICAST_RECEIVER_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_MULTICAST_MULTICAST_RECEIVER_H_
+
+#include "mojo/public/cpp/bindings/receiver.h"
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom-blink.h"
+#include "third_party/blink/renderer/core/execution_context/execution_context_lifecycle_observer.h"
+#include "third_party/blink/renderer/modules/modules_export.h"
+#include "third_party/blink/renderer/platform/bindings/script_state.h"
+#include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
+
+namespace blink {
+class MulticastReceiverConfig;
+class ReadableStream;
+class ReadableStreamDefaultControllerWithScriptScope;
+class ExceptionState;
+
+/**
+ * TODO(cworm)
+ *
+ * A key design consideration is the following: Consider the case where
+ * JavaScript creates a MulticastReceiver and then removes all references to it
+ * (and hence make it a candidate for Garbage Collection) without canceling it.
+ *
+ * Other download classes (WebSocket, WebTransport, XmlHttpRequest) will
+ * in this case continue to download data in the background and prevent
+ * themselves from being garbage collected. This is implemented by inheriting
+ * from ActiveScriptWrapable. I believe there are two reasons that this may be
+ * useful behaviour:
+ *
+ *   a) Even though JavaScript has no pointers to the download object itself,
+ *      there may still be event handlers that fire up as data is received
+ *      (when the API uses old style events without flow control to provide data
+ *       instead of a ReadablStream)
+ *   b) The JavaScript may know that there is no more data to be received and
+ *      that the server side will close the connection - so it is not critical
+ *      that it does it itself.
+ *
+ * For the MulticastReceiver download object this is a bit different:
+ *
+ *   a) If JavaScript has no reference the the MulticastReceiver (or a
+ *      reader/readablestream from it) then JavaScript cannot receive new data
+ *      (that is how ReadableStreams work)
+ *   b) There is no way for the multicast flow to indicate an end-of-stream
+ *      that will cause the browser side to close it gracefully
+ *
+ * In combination these two items imply that there seems to be no good use case
+ * for never closing a MultcastReceiver and hence for us to prevent garbage
+ * collection like the other download classes do.
+ *
+ * Now, there are nuances: For item a) JavaScript could have made a finite
+ * number of read calls and hence received a finite number of unsettled promises
+ * that could still read data. For item b) the browser may close the stream if
+ * no multicast data is received for some time. Despite these nuances, I still
+ * think there is no good excuse for not closing a MulticastReceiver.
+ *
+ * Several notes to this:
+ *   * Does this sound fair?
+ *   * What if JavaScript has made some calls to read() and got some promisses
+ *     Will they be settled when the ReadableStream is GCed? Or will they
+ *     prevent GC from happening? What if there are no pointers to the promises
+ *     themselves but they still have accept and/or reject handlers installed?
+ *     See also notes in the GarbageCollection unit tests.
+ *   * It would be nice to log to the JavaScript console if a MulticastReceiver
+ *     is GCed whitout being closed. But it seems like it is not possible
+ *     to log a message to the JavaScript console from a pre finalizer since
+ *     it requires allocation of a GCed ConsoleMessage object. Is there a good
+ *     way around that? Perhaps we can Post a task to do the console logging?
+ *
+ * Another thing we may want to do and which could change the above perspective,
+ * is to automatically close a MulticastReceiver in case JavaScript does not
+ * appear to read from it. If we do that, then it seems more okay for JavaScript
+ * to not close a MulticastReceiver.
+ */
+
+class MODULES_EXPORT MulticastReceiver final
+    : public ScriptWrappable,
+      public ExecutionContextLifecycleObserver,
+      //public GarbageCollected<MulticastReceiver>,
+      public network::mojom::blink::MulticastReceiverClient {
+  DEFINE_WRAPPERTYPEINFO();
+  // USING_GARBAGE_COLLECTED_MIXIN(MulticastReceiver);
+  USING_PRE_FINALIZER(MulticastReceiver, Dispose);
+
+ public:
+  explicit MulticastReceiver(ScriptState*);
+
+  static MulticastReceiver* Create(ScriptState* script_state,
+                                   MulticastReceiverConfig* config,
+                                   uint32_t queue_size_in_packets,
+                                   ExceptionState&);
+  static MulticastReceiver* Create(ScriptState* script_state,
+                                   MulticastReceiverConfig* config,
+                                   ExceptionState&);
+
+  // MulticastReceiverClient - mojo callbacks from the browser process.
+  void OnDatagram(::base::span<const ::uint8_t> data) override;
+  void OnClose(network::mojom::blink::MulticastCloseCode close_code,
+               const WTF::String& close_message) override;
+
+  // Garbage collection
+  void Trace(Visitor*) const override;
+
+  // ExecutionContextLifecycleObserver.
+  void ContextDestroyed() override;
+
+  // JavaScript:
+  ReadableStream* readable() { return received_datagrams_; }
+  unsigned closecode() { return (unsigned)close_code_; }
+  static constexpr auto kCloseCodeRunning =
+      (unsigned)network::mojom::MulticastCloseCode::RUNNING;
+  static constexpr auto kCloseCodeCanceled =
+      (unsigned)network::mojom::MulticastCloseCode::CLOSED_BY_CLIENT;
+  static constexpr auto kCloseCodeError =
+      (unsigned)network::mojom::MulticastCloseCode::ERROR;
+
+ private:
+  class DatagramUnderlyingSource;
+
+  void Init(MulticastReceiverConfig*,
+            uint32_t queue_size_in_packets,
+            ExceptionState&);
+
+  // Called by DatagramUnderlyingSource.
+  void UnderlyingSourceStarted(ReadableStreamDefaultControllerWithScriptScope*);
+  void UnderlyingSourceCanceled();
+
+  // TODO(cworm): The ScriptState documentation says you are not allowed to
+  // store the ScriptState in a C++ object that has an idl interface. So maybe
+  // we are not allowed to store it here? I *think* we are - at least
+  // quic_transport does a similar thing. Also we do not really store it since
+  // it is GC controlled.
+  const Member<ScriptState> script_state_;
+
+  Member<ReadableStream> received_datagrams_;
+
+  Member<ReadableStreamDefaultControllerWithScriptScope>
+      received_datagrams_controller_;
+
+  void Dispose();
+
+  network::mojom::blink::MulticastCloseCode close_code_{
+      network::mojom::blink::MulticastCloseCode::RUNNING};
+
+  // Configuration:
+  String source_;
+  String group_;
+  String dorms_;
+  unsigned short port_;
+
+#ifdef MULTICAST_API_PROFILING
+  size_t max_packet_size_=0;
+#endif
+
+  // Mojo stuff:
+  mojo::Remote<network::mojom::blink::MulticastReceiver> remote_;
+  mojo::Receiver<network::mojom::blink::MulticastReceiverClient> receiver_{
+      this};
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_MULTICAST_MULTICAST_RECEIVER_H_
diff --git a/third_party/blink/renderer/modules/multicast/multicast_receiver.idl b/third_party/blink/renderer/modules/multicast/multicast_receiver.idl
new file mode 100644
index 000000000000..758345e67658
--- /dev/null
+++ b/third_party/blink/renderer/modules/multicast/multicast_receiver.idl
@@ -0,0 +1,34 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+[Exposed=(Window,Worker),
+ RuntimeEnabled=MulticastTransport
+]
+interface MulticastReceiver {
+    // TODO(cworm): Instead of taking a queue_size_in_packets as a constructor
+    // argument, maybe it would be better to take a QueuingStrategy so the user
+    // could setup his own ByteLengthQueuingStrategy or CountQueuingStrategy?
+    // (I am not sure it is possible to make custom queing strategies besides
+    // these two?).
+  [CallWith=ScriptState, RaisesException] constructor(MulticastReceiverConfig config, optional unsigned long queue_size_in_packets);
+
+  // Returns a close code. Normally this should only be read when a promise
+  // returned by read has been rejected.
+  readonly attribute unsigned short closecode;
+
+  // Close codes. The first two are non-errors. Everything else is an error.
+  const unsigned short CLOSE_CODE_RUNNING = 0; // Still running, not closed
+  const unsigned short CLOSE_CODE_CANCELED = 1; // Closed by cancel
+  const unsigned short CLOSE_CODE_ERROR = 2;
+
+  // readable stream. Provides an UInt8Array with each datagram.
+  //
+  // TODO(cworm): Do we need to make chunks of datagrams for better
+  // CPU efficiency?
+  //
+  // TODO(cworm): Maybe it is better that the user brings his own
+  // WriteableStream? Then he can set it up in whatever way he likes with
+  // respect to dropping packets..
+  readonly attribute ReadableStream readable;
+};
diff --git a/third_party/blink/renderer/modules/multicast/multicast_receiver_config.idl b/third_party/blink/renderer/modules/multicast/multicast_receiver_config.idl
new file mode 100644
index 000000000000..d6e4333ccd1b
--- /dev/null
+++ b/third_party/blink/renderer/modules/multicast/multicast_receiver_config.idl
@@ -0,0 +1,10 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+dictionary MulticastReceiverConfig {
+  DOMString source;
+  DOMString group;
+  DOMString dorms;
+  unsigned short port;
+};
diff --git a/third_party/blink/renderer/modules/multicast/multicast_receiver_test.cc b/third_party/blink/renderer/modules/multicast/multicast_receiver_test.cc
new file mode 100644
index 000000000000..d60c26ffb542
--- /dev/null
+++ b/third_party/blink/renderer/modules/multicast/multicast_receiver_test.cc
@@ -0,0 +1,496 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/modules/multicast/multicast_receiver.h"
+
+#include "base/test/mock_callback.h"
+#include "mojo/public/cpp/bindings/receiver_set.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/public/common/browser_interface_broker_proxy.h"
+#include "third_party/blink/public/mojom/multicast/multicast.mojom-blink.h"
+#include "third_party/blink/renderer/bindings/core/v8/script_promise.h"
+#include "third_party/blink/renderer/bindings/core/v8/script_promise_tester.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_testing.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_dom_exception.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_iterator_result_value.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_uint8_array.h"
+#include "third_party/blink/renderer/core/execution_context/execution_context.h"
+#include "third_party/blink/renderer/core/streams/readable_stream.h"
+#include "third_party/blink/renderer/modules/multicast/multicast_receiver_config.h"
+#include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
+
+namespace blink {
+
+namespace {
+
+using ::testing::ElementsAre;
+using ::testing::StrictMock;
+
+using network::mojom::blink::MulticastCloseCode;
+
+// This mock saves all the calls to Open and leaves it to the user of the
+// class to reply to them later.
+class MulticastReceiverOpener final
+    : public network::mojom::blink::MulticastReceiverOpener {
+ public:
+  struct OpenArgs {
+    OpenArgs(const WTF::String& source,
+             const WTF::String& group,
+             const WTF::String& dorms,
+             uint16_t port,
+             mojo::PendingReceiver<network::mojom::blink::MulticastReceiver>
+                 multicast_receiver,
+             mojo::PendingRemote<network::mojom::blink::MulticastReceiverClient>
+                 multicast_receiver_client)
+        : source_(source),
+          group_(group),
+          dorms_(dorms),
+          port_(port),
+          multicast_receiver_(std::move(multicast_receiver)),
+          multicast_receiver_client_(std::move(multicast_receiver_client)) {}
+
+    WTF::String source_, group_, dorms_;
+    uint16_t port_;
+    mojo::PendingReceiver<network::mojom::blink::MulticastReceiver>
+        multicast_receiver_;
+    mojo::PendingRemote<network::mojom::blink::MulticastReceiverClient>
+        multicast_receiver_client_;
+  };
+
+  void Open(const WTF::String& source,
+            const WTF::String& group,
+            const WTF::String& dorms,
+            uint16_t port,
+            mojo::PendingReceiver<network::mojom::blink::MulticastReceiver>
+                multicast_receiver,
+            mojo::PendingRemote<network::mojom::blink::MulticastReceiverClient>
+                multicast_receiver_client) override {
+    open_args_.push_back(OpenArgs(source, group, dorms, port,
+                                  std::move(multicast_receiver),
+                                  std::move(multicast_receiver_client)));
+  }
+
+  // Takes the calls to Open
+  Vector<OpenArgs> TakeOpenArgs() { return std::move(open_args_); }
+
+  // Binds a PendingReceiver to this instance.
+  void Bind(
+      mojo::PendingReceiver<network::mojom::blink::MulticastReceiverOpener>
+          receiver) {
+    receiver_set_.Add(this, std::move(receiver));
+  }
+
+ private:
+  mojo::ReceiverSet<network::mojom::blink::MulticastReceiverOpener>
+      receiver_set_;
+  Vector<OpenArgs> open_args_;
+};
+
+class MockMulticastReceiver : public network::mojom::blink::MulticastReceiver {
+ public:
+  MockMulticastReceiver(
+      mojo::PendingReceiver<network::mojom::blink::MulticastReceiver>
+          pending_receiver)
+      : receiver_(this, std::move(pending_receiver)) {}
+
+  MOCK_METHOD0(Close, void());
+
+ private:
+  mojo::Receiver<network::mojom::blink::MulticastReceiver> receiver_;
+};
+
+class MulticastReceiverTest : public ::testing::Test {
+ public:
+  // Creates a dummy configuration
+  MulticastReceiverConfig* config() {
+    MulticastReceiverConfig* ret = MulticastReceiverConfig::Create();
+    ret->setDorms("dorms");
+    ret->setGroup("group");
+    ret->setSource("source");
+    ret->setPort(27);
+    return ret;
+  }
+
+  // Creates a MulticastReceiver to test.
+  MulticastReceiver* Create(const V8TestingScope& scope,
+                            MulticastReceiverConfig* config,
+                            uint32_t queue_size_in_packets) {
+    // Tell the system to use the MulticastReceiverOpener implemented above when
+    // the MulticastReceiver tries to connect to th browser side.
+    interface_broker_ =
+        const_cast<blink::BrowserInterfaceBrokerProxy *> (&scope.GetExecutionContext()->GetBrowserInterfaceBroker());
+    interface_broker_->SetBinderForTesting(
+        network::mojom::blink::MulticastReceiverOpener::Name_,
+        base::BindRepeating(&MulticastReceiverTest::BindConnector,
+                            weak_ptr_factory_.GetWeakPtr()));
+
+    // And then Create the MulticastReceiver:
+    return MulticastReceiver::Create(scope.GetScriptState(), config,
+                                     queue_size_in_packets,
+                                     ASSERT_NO_EXCEPTION);
+  }
+
+  // Given a MulticastReceiver returned by Create, this resolves the pending
+  // mojom arguments that Create has given to Open.
+  void ResolveCreate(MulticastReceiver* receiver) {
+    DCHECK(!mock_multicast_receiver_) << "Only one flow supported, sorry";
+
+    test::RunPendingTasks();
+
+    auto args = opener_.TakeOpenArgs();
+    if (args.size() != 1u) {
+      ADD_FAILURE() << "args.size() should be 1, but is " << args.size();
+      return;
+    }
+
+    client_remote_.Bind(std::move(args[0].multicast_receiver_client_));
+    mock_multicast_receiver_ =
+        std::make_unique<StrictMock<MockMulticastReceiver>>(
+            std::move(args[0].multicast_receiver_));
+
+    test::RunPendingTasks();
+  }
+
+  void TearDown() override {
+    if (!interface_broker_)
+      return;
+    interface_broker_->SetBinderForTesting(
+        network::mojom::blink::MulticastReceiverOpener::Name_, {});
+  }
+
+  // Used by ResolveCreate to represent the two sides of the mojo API.
+  std::unique_ptr<MockMulticastReceiver> mock_multicast_receiver_;
+  mojo::Remote<network::mojom::blink::MulticastReceiverClient> client_remote_;
+
+  // Used by the Create method to install the MulticastReceiverOpener
+  // implemented above.
+  void BindConnector(mojo::ScopedMessagePipeHandle handle) {
+    opener_.Bind(
+        mojo::PendingReceiver<network::mojom::blink::MulticastReceiverOpener>(
+            std::move(handle)));
+  }
+  MulticastReceiverOpener opener_;
+  BrowserInterfaceBrokerProxy* interface_broker_ = nullptr;
+  base::WeakPtrFactory<MulticastReceiverTest> weak_ptr_factory_{this};
+};
+
+TEST_F(MulticastReceiverTest, FailWithNoConfig) {
+  V8TestingScope scope;
+  auto& exception_state = scope.GetExceptionState();
+  MulticastReceiver::Create(scope.GetScriptState(),
+                            MulticastReceiverConfig::Create(), exception_state);
+  EXPECT_TRUE(exception_state.HadException());
+  EXPECT_EQ(static_cast<int>(DOMExceptionCode::kSyntaxError),
+            exception_state.Code());
+}
+
+TEST_F(MulticastReceiverTest, FailWithNoDorms) {
+  V8TestingScope scope;
+  auto& exception_state = scope.GetExceptionState();
+  MulticastReceiverConfig* cnf = MulticastReceiverConfig::Create();
+  cnf->setSource("s");
+  cnf->setGroup("g");
+  cnf->setPort(42);
+  MulticastReceiver::Create(scope.GetScriptState(), cnf, exception_state);
+  EXPECT_TRUE(exception_state.HadException());
+  EXPECT_EQ(static_cast<int>(DOMExceptionCode::kSyntaxError),
+            exception_state.Code());
+}
+
+TEST_F(MulticastReceiverTest, FailWithZeroPort) {
+  V8TestingScope scope;
+  auto& exception_state = scope.GetExceptionState();
+  MulticastReceiverConfig* cnf = MulticastReceiverConfig::Create();
+  cnf->setSource("s");
+  cnf->setGroup("g");
+  cnf->setDorms("d");
+  cnf->setPort(0);
+  MulticastReceiver::Create(scope.GetScriptState(), cnf, exception_state);
+  EXPECT_TRUE(exception_state.HadException());
+  EXPECT_EQ(static_cast<int>(DOMExceptionCode::kSyntaxError),
+            exception_state.Code());
+}
+
+TEST_F(MulticastReceiverTest, SetupTransferConfigToBrowser) {
+  V8TestingScope scope;
+
+  MulticastReceiverConfig* cnf = MulticastReceiverConfig::Create();
+  cnf->setSource("s");
+  cnf->setGroup("g");
+  cnf->setDorms("d");
+  cnf->setPort(27);
+
+  Create(scope, cnf, 1);
+
+  test::RunPendingTasks();
+
+  auto args = std::move(opener_.TakeOpenArgs()[0]);
+
+  EXPECT_EQ("s", args.source_);
+  EXPECT_EQ("g", args.group_);
+  EXPECT_EQ("d", args.dorms_);
+  EXPECT_EQ(27, args.port_);
+}
+
+TEST_F(MulticastReceiverTest, ClosedByBrowser) {
+  V8TestingScope scope;
+  MulticastReceiver* multicast_receiver = Create(scope, config(), 1);
+  ResolveCreate(multicast_receiver);
+
+  // No error yet:
+  EXPECT_EQ(multicast_receiver->closecode(),
+            MulticastReceiver::kCloseCodeRunning);
+
+  // Simulate close from browser side:
+  client_remote_->OnClose(MulticastCloseCode::ERROR, "my error");
+
+  test::RunPendingTasks();
+
+  // Check close code.
+  EXPECT_EQ(multicast_receiver->closecode(),
+            MulticastReceiver::kCloseCodeError);
+
+  // Check that we get the error when reading:
+  auto* readable = multicast_receiver->readable();
+  auto* script_state = scope.GetScriptState();
+  auto* reader = readable->GetDefaultReaderForTesting(script_state, ASSERT_NO_EXCEPTION);
+
+  ScriptPromise result = reader->read(script_state, ASSERT_NO_EXCEPTION);
+  ScriptPromiseTester tester(script_state, result);
+  tester.WaitUntilSettled();
+
+  EXPECT_TRUE(tester.IsRejected());
+
+  DOMException* exception = V8DOMException::ToImplWithTypeCheck(
+      scope.GetIsolate(), tester.Value().V8Value());
+  EXPECT_EQ(exception->name(), "NetworkError");
+  EXPECT_EQ(exception->message(), "my error");
+
+  // TODO(cworm): Should we test what happens in case of mojo disconnect?
+}
+
+TEST_F(MulticastReceiverTest, ClosedByRenderer) {
+  V8TestingScope scope;
+  MulticastReceiver* multicast_receiver = Create(scope, config(), 1);
+  ResolveCreate(multicast_receiver);
+
+  auto* readable = multicast_receiver->readable();
+  auto* script_state = scope.GetScriptState();
+
+  // The cancel call below should make us call Close on the browser side:
+  EXPECT_CALL(*mock_multicast_receiver_, Close).Times(1);
+
+  readable->cancel(script_state, ASSERT_NO_EXCEPTION);
+
+  test::RunPendingTasks();
+
+  EXPECT_EQ(multicast_receiver->closecode(),
+            MulticastReceiver::kCloseCodeCanceled);
+}
+
+// Helper class copied verbatim from quic_transport_test.
+Vector<uint8_t> GetValueAsVector(ScriptState* script_state,
+                                 ScriptValue iterator_result) {
+  bool done = false;
+  v8::Local<v8::Value> value;
+  if (!V8UnpackIteratorResult(script_state,
+                              iterator_result.V8Value().As<v8::Object>(), &done)
+           .ToLocal(&value)) {
+    ADD_FAILURE() << "unable to unpack iterator_result";
+    return {};
+  }
+
+  EXPECT_FALSE(done);
+  auto* array =
+      V8Uint8Array::ToImplWithTypeCheck(script_state->GetIsolate(), value);
+  if (!array) {
+    ADD_FAILURE() << "value was not a Uint8Array";
+    return {};
+  }
+
+  Vector<uint8_t> result;
+  result.Append(array->Data(), array->length());
+  return result;
+}
+
+TEST_F(MulticastReceiverTest, ReceiveDatagramBeforeRead) {
+  V8TestingScope scope;
+  MulticastReceiver* multicast_receiver = Create(scope, config(), 1);
+  ResolveCreate(multicast_receiver);
+
+  // Send a packet:
+  const std::array<uint8_t, 1> chunk = {'M'};
+  client_remote_->OnDatagram(chunk);
+
+  test::RunPendingTasks();
+
+  // Check that we get the packet:
+  auto* readable = multicast_receiver->readable();
+  auto* script_state = scope.GetScriptState();
+  auto* reader = readable->GetDefaultReaderForTesting(script_state, ASSERT_NO_EXCEPTION);
+  ScriptPromise result = reader->read(script_state, ASSERT_NO_EXCEPTION);
+  ScriptPromiseTester tester(script_state, result);
+  tester.WaitUntilSettled();
+  EXPECT_TRUE(tester.IsFulfilled());
+  EXPECT_THAT(GetValueAsVector(script_state, tester.Value()), ElementsAre('M'));
+}
+
+TEST_F(MulticastReceiverTest, ReceiveDatagramDuringRead) {
+  V8TestingScope scope;
+  MulticastReceiver* multicast_receiver = Create(scope, config(), 1);
+  ResolveCreate(multicast_receiver);
+
+  auto* readable = multicast_receiver->readable();
+  auto* script_state = scope.GetScriptState();
+  auto* reader = readable->GetDefaultReaderForTesting(script_state, ASSERT_NO_EXCEPTION);
+  ScriptPromise result = reader->read(script_state, ASSERT_NO_EXCEPTION);
+
+  const std::array<uint8_t, 1> chunk = {'A'};
+  client_remote_->OnDatagram(chunk);
+
+  ScriptPromiseTester tester(script_state, result);
+  tester.WaitUntilSettled();
+  EXPECT_TRUE(tester.IsFulfilled());
+
+  EXPECT_THAT(GetValueAsVector(script_state, tester.Value()), ElementsAre('A'));
+}
+
+TEST_F(MulticastReceiverTest, DatagramsAreDropped) {
+  V8TestingScope scope;
+  MulticastReceiver* multicast_receiver = Create(scope, config(), 2);  // size 2
+  ResolveCreate(multicast_receiver);
+
+  // Chunk 'A' gets placed in the readable queue.
+  const std::array<uint8_t, 1> chunk1 = {'A'};
+  client_remote_->OnDatagram(chunk1);
+
+  // Chunk 'B' gets placed in the readable queue.
+  const std::array<uint8_t, 1> chunk2 = {'B'};
+  client_remote_->OnDatagram(chunk2);
+
+  // Chunk 'C' gets dropped, because we have set the readable queue up to have
+  // size 2.
+  const std::array<uint8_t, 1> chunk3 = {'C'};
+  client_remote_->OnDatagram(chunk3);
+
+  // Make sure that the calls have run.
+  test::RunPendingTasks();
+
+  auto* readable = multicast_receiver->readable();
+  auto* script_state = scope.GetScriptState();
+  auto* reader = readable->GetDefaultReaderForTesting(script_state, ASSERT_NO_EXCEPTION);
+  ScriptPromise result1 = reader->read(script_state, ASSERT_NO_EXCEPTION);
+  ScriptPromise result2 = reader->read(script_state, ASSERT_NO_EXCEPTION);
+  ScriptPromise result3 = reader->read(script_state, ASSERT_NO_EXCEPTION);
+
+  ScriptPromiseTester tester1(script_state, result1);
+  ScriptPromiseTester tester2(script_state, result2);
+  ScriptPromiseTester tester3(script_state, result3);
+
+  tester2.WaitUntilSettled();
+  EXPECT_TRUE(tester2.IsFulfilled());
+  EXPECT_FALSE(tester3.IsFulfilled());
+
+  EXPECT_THAT(GetValueAsVector(script_state, tester1.Value()),
+              ElementsAre('A'));
+
+  EXPECT_THAT(GetValueAsVector(script_state, tester2.Value()),
+              ElementsAre('B'));
+
+  // Chunk 'D' fulfills the pending read.
+  const std::array<uint8_t, 1> chunk4 = {'D'};
+  client_remote_->OnDatagram(chunk4);
+
+  tester3.WaitUntilSettled();
+  EXPECT_TRUE(tester3.IsFulfilled());
+
+  EXPECT_THAT(GetValueAsVector(script_state, tester3.Value()),
+              ElementsAre('D'));
+}
+
+// Test that the MulticastReceiver will be kept alive as long as it can be
+// canceled from JavaScript.
+TEST_F(MulticastReceiverTest, GarbageCollectionReader) {
+  V8TestingScope scope;
+  WeakPersistent<MulticastReceiver> multicast_receiver;
+  {
+    // TODO(cworm): This line is also there in quic_transport_test. I would like
+    // to understand what it does. What is a handle? Is it the same as a pointer
+    // to a GC object? Why does this not delete handles that should not be
+    // deleted? Why is it needed? Is there any documentation that explains this?
+    v8::HandleScope handle_scope(scope.GetIsolate());
+
+    multicast_receiver = Create(scope, config(), 1);
+    ResolveCreate(multicast_receiver);
+  }
+
+  // Create a reader to keep MulticastReceiver alive.
+  Persistent<ReadableStreamDefaultReader> reader =
+      multicast_receiver->readable()->GetDefaultReaderForTesting(scope.GetScriptState(),
+                                                ASSERT_NO_EXCEPTION);
+
+  // From quic_transport_test:
+  //
+  //   Pretend the stack is empty. This will avoid accidentally treating any
+  //   copies of the |multicast_receiver| as references.
+  //
+  // TODO(cworm): But it still looks like the reader we keep on the stack above
+  // is accounted for...?
+  ThreadState::Current()->CollectAllGarbageForTesting();
+      // scope.GetIsolate(), v8::EmbedderHeapTracer::EmbedderStackState::kEmpty);
+
+  EXPECT_TRUE(multicast_receiver);
+
+  // Remove pointer to the reader:
+  reader.Clear();
+
+  // And now it should be GCed.
+  ThreadState::Current()->CollectAllGarbageForTesting();
+      // scope.GetIsolate(), v8::EmbedderHeapTracer::EmbedderStackState::kEmpty);
+  EXPECT_FALSE(multicast_receiver);
+
+  // TODO (cworm): In the log it looks like MulticastReceiver::Dispose is called
+  // maybe 10 times. Is that expected?
+}
+
+// A lot of this is taken from the GarbageCollectionReader test above.
+TEST_F(MulticastReceiverTest, GarbageCollectionPromise) {
+  V8TestingScope scope;
+  WeakPersistent<MulticastReceiver> multicast_receiver;
+  {
+    v8::HandleScope handle_scope(scope.GetIsolate());
+
+    multicast_receiver = Create(scope, config(), 1);
+    ResolveCreate(multicast_receiver);
+  }
+
+  // Create a reader to keep stuff alive.
+  WeakPersistent<ReadableStreamDefaultReader> reader =
+      multicast_receiver->readable()->GetDefaultReaderForTesting(scope.GetScriptState(),
+                                                ASSERT_NO_EXCEPTION);
+
+  // Get a read promise:
+  ScriptPromise read_promise =
+      reader->read(scope.GetScriptState(), ASSERT_NO_EXCEPTION);
+
+  ThreadState::Current()->CollectAllGarbageForTesting();
+   //    scope.GetIsolate(), v8::EmbedderHeapTracer::EmbedderStackState::kEmpty);
+
+  // TODO(cworm): Not sure what to expect here. But it seems like it is not
+  // GCed.
+  EXPECT_TRUE(multicast_receiver);
+
+  // Clear the promise
+  ThreadState::Current()->CollectAllGarbageForTesting();
+      // scope.GetIsolate(), v8::EmbedderHeapTracer::EmbedderStackState::kEmpty);
+
+  // TODO(cworm): I would expect everything to be GCed here. But it is not.
+  // I would like to understand why.
+  EXPECT_TRUE(multicast_receiver);
+}
+
+}  // namespace
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/runtime_enabled_features.json5 b/third_party/blink/renderer/platform/runtime_enabled_features.json5
index 16073b493df9..4e31322c7110 100644
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -1307,6 +1307,10 @@
       // When enabled, iframes are not capturing mouse events by default.
       name: "MouseSubframeNoImplicitCapture",
     },
+    {
+      name: "MulticastTransport",
+      status: "experimental",
+    },
     {
       // Named pages for pagination (the "page" CSS property).
       name: "NamedPages",
diff --git a/third_party/libmcrx/.gitignore b/third_party/libmcrx/.gitignore
new file mode 100644
index 000000000000..9feefe5725ca
--- /dev/null
+++ b/third_party/libmcrx/.gitignore
@@ -0,0 +1,18 @@
+*.o
+*.log
+*.trs
+*.lint
+.DS_Store
+.deps/
+.libs/
+Makefile
+Makefile.in
+/aclocal.m4
+/autom4te.cache
+/build-aux
+/config.*
+/configure
+/libtool
+/stamp-h1
+.*.sw?
+*~
diff --git a/third_party/libmcrx/BUILD.gn b/third_party/libmcrx/BUILD.gn
new file mode 100644
index 000000000000..f41cd33d93a5
--- /dev/null
+++ b/third_party/libmcrx/BUILD.gn
@@ -0,0 +1,31 @@
+# Copyright 2019 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+import("//build/config/compiler/compiler.gni")
+
+config("libmcrx_config") {
+  include_dirs = [ "include" ]
+  cflags = [
+    "-DLIBMCRX_STATIC"
+  ]
+}
+
+static_library("mcrx") {
+  sources = [
+    "src/libmcrx-private.h",
+    "src/libmcrx.c",
+    "src/native.c",
+    "src/wait.c",
+  ]
+
+  public_configs = [ ":libmcrx_config" ]
+
+  deps = []
+
+  configs -= [ "//build/config/compiler:chromium_code" ]
+  configs += [
+    ":libmcrx_config",
+    "//build/config/compiler:no_chromium_code",
+  ]
+}
+
diff --git a/third_party/libmcrx/CPPLINT.cfg b/third_party/libmcrx/CPPLINT.cfg
new file mode 100644
index 000000000000..93930fd80761
--- /dev/null
+++ b/third_party/libmcrx/CPPLINT.cfg
@@ -0,0 +1,3 @@
+# -readability/casting: C code uses C-style casts, so accept it without complaint
+#   --jake 2019-06-13
+filter=-readability/casting
diff --git a/third_party/libmcrx/HOWTO.md b/third_party/libmcrx/HOWTO.md
new file mode 100644
index 000000000000..db798d25be0c
--- /dev/null
+++ b/third_party/libmcrx/HOWTO.md
@@ -0,0 +1,202 @@
+# How To Receive Multicast
+
+A simple test program, [mcrx-check](test/mcrx-check.c), is included.
+It counts the received packets and prints periodic stats about the packets received.
+
+However, in order to receive multicast traffic, something has to be sending traffic.
+
+There are several good ways to do this, several are described below, in increasing order of setup complexity.
+
+## Being In A Multicast-Capable Network
+
+The simplest case is when your receiver device already lives inside a multicast-capable network, and someone on that network is already producing traffic or ingesting externally available traffic when clients join globally addressed (S,G)s.
+
+If you're lucky enough, you might be in one of the locations that supports multicast traffic already.
+Organizations connected to [internet2](https://internet2.edu/community/membership/member-list/) in many cases can consume multicast traffic from the [active senders there](https://multicastmenu.herokuapp.com/).
+
+But most people are not so lucky, and will have to use one of the more complex options.
+Setting up your own personal multicast-capable network has some challenges, but is possible without specialized equipment, as described in the [Running a multicast-capable network](#running-a-multicast-capable-network) section below.
+
+If you are one of those lucky few, you can just run the `mcrx-check` program that this project builds for testing, and you'll be able to receieve packets that someone else is sending:
+
+~~~
+./mcrx-check -s 129.174.55.131 -g 232.44.15.9 -p 50001 -d 0 -c 2000
+~~~
+
+In most cases for the [traffic people are sending on I2](https://multicastmenu.herokuapp.com), if you can see the basic receive path working, you can also watch it as streaming video with [vlc](https://www.videolan.org/vlc/index.html) by using the source IP, group IP, and port for a vlc stream:
+
+~~~
+vlc udp://129.174.131.51@233.44.15.9:50001
+~~~
+
+## Running A Multicast-capable Network
+
+If your ISP does not provide you a multicast network, it's still possible to set up a multicast network that can ingest traffic and then run your receivers on devices running within that network, as described in the section above.
+
+Some detailed instructions are available in the [multicast-ingest-platform](https://github.com/GrumpyOldTroll/multicast-ingest-platform) project, and the associated [sample-network](https://github.com/GrumpyOldTroll/multicast-ingest-platform/tree/master/sample-network).
+
+Although this option has a high one-time complexity and some maintenance burden, if you'll be working with multicast a lot it can save some hassle relative to the options below that will have you setting up config and tearing it down each time you work with it, and for each different source you want to access.
+
+## Running Your Own Sender
+
+[ffmpeg](https://ffmpeg.org/) and [vlc](https://www.videolan.org/vlc/index.html) both have ways to run multicast traffic.
+There are several online resources with [examples](https://wiki.videolan.org/Documentation:Streaming_HowTo/Command_Line_Examples/) [showing how](https://trac.ffmpeg.org/wiki/StreamingGuide), and many reports of [mixed success](https://forum.videolan.org/viewtopic.php?t=62053) that once worked for someone, but might need troubleshooting for particular videos and installations.
+
+These examples generate traffic for me, using a [BigBuckBunny](http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4) download:
+
+vlc:
+
+~~~
+vlc ~/Downloads/BigBuckBunny.mp4 --sout '#transcode {vcodec=h264,scale=Auto,acodec=mpga,ab=128,channels=2,samplerate=44100}:std{access=udp,mux=ts,dst=232.10.1.10:1234}'
+~~~
+
+ffmpeg:
+
+~~~
+ffmpeg -re -i ~/Downloads/BigBuckBunny.mp4 -c copy -f mpegts udp://232.10.1.12:1234?pkt_size=1316
+~~~
+
+When you run your own sender, it will generally output traffic on the interface with the default route, unless you've set up something more specific.
+
+One good way to do testing with your own traffic is to run a sender on one machine and a receiver on another machine in the same LAN.
+Usually this usage requires no special setup, if the LAN allows multicast traffic between its hosts.
+
+Another good way is to run a virtual machine, and to send traffic between the host and the virtual machine.
+This often requires adjusting the routing table on the sender to ensure the traffic goes to the right interface.
+
+For example, when using a Mac, I often install [Virtualbox](https://www.virtualbox.org/wiki/Downloads) and set up a [host-only adapter](https://www.virtualbox.org/manual/ch06.html#network_hostonly) for the guest machine, and install a linux distro.
+In this example, the guest IP is `192.168.56.101`, and the host IP for the host-only network is `192.168.56.1`.
+
+Then, if you want to send traffic from the guest to the host, you can run the above ffmpeg command on the linux guest, but you'll have to set the route so the traffic goes out the host-only adapter:
+
+~~~bash
+# on the guest, before sending traffic to the host
+sudo ip route add 232.0.0.0/8 via 192.168.56.1
+~~~
+
+Then you run your traffic from the linux guest:
+
+~~~bash
+# on the guest, generating traffic
+ffmpeg -re -i ~/Downloads/BigBuckBunny.mp4 -c copy -f mpegts udp://232.10.1.12:1234?pkt_size=1316
+~~~
+
+Then from the host or on another guest virtual machine, you'd run a receiver and join the same traffic stream:
+
+~~~
+$ ./mcrx-check -s 192.168.56.101 -g 232.10.1.12 -p 1234 -d 0 -c 1000
+02-02 01:47:52: joined to 192.168.56.101->232.10.1.12:1234 for 2s, 0 pkts received
+02-02 01:47:54: joined to 192.168.56.101->232.10.1.12:1234 for 4s, 819 pkts received
+passed (1000/1000 packets in 4s)
+~~~
+
+Conversely, you can do the same thing from the host to the guest, by adding a route for the destination, and using the host's IP address for the source:
+
+~~~bash
+# on an OSX host, before sending traffic to a guest
+sudo route add -net 232.0.0.0/8 192.168.56.101
+~~~
+
+Then running the traffic sending to the guests:
+
+~~~bash
+# on the OSX host, sending traffic to a guest
+ffmpeg -re -i ~/Downloads/BigBuckBunny.mp4 -c copy -f mpegts udp://232.10.10.2:1234?pkt_size=1316
+~~~
+
+And receiving in the guest then uses the sender's host IP and whatver group address you used:
+
+~~~
+$ ./mcrx-check -s 192.168.56.1 -g 232.10.10.2 -p 1234 -d 0 -c 1000
+02-02 09:23:37: joined to 192.168.56.1->232.10.10.2:1234 for 2s, 443 pkts received
+02-02 09:23:39: joined to 192.168.56.1->232.10.10.2:1234 for 4s, 840 pkts received
+passed (1000/1000 packets in 4s)
+~~~
+
+## Ingesting External Traffic with AMT
+
+There are several live sources of external traffic that can be consumed by using [AMT](https://www.rfc-editor.org/rfc/rfc7450.html) tunnels.
+
+In order to receive multicast traffic over AMT, you'd run an AMT gateway to connect to an AMT relay that can deliver the traffic you want.
+
+### Finding The Right Relay
+
+Running an AMT gateway to ingest traffic requires connecting to an AMT relay that can forward the multicast traffic you're trying to receive.
+There's a few different ways that can work.
+
+#### Discovering A Relay From The Traffic's Source IP
+
+There is some live traffic with associated [AMTRELAY](https://www.rfc-editor.org/rfc/rfc8777.html) DNS records for the source's reverse IP domain name.
+Akamai runs some traffic this way and other sources might advertise relays this way as well.
+
+AMT relays for traffic like this can be discovered with [driad.py](https://github.com/GrumpyOldTroll/libmcrx/driad.py).
+For example, to discover the right relay for (23.212.185.4, 232.1.1.1), you would run:
+
+~~~
+curl -O https://raw.githubusercontent.com/GrumpyOldTroll/libmcrx/master/driad.py
+RELAYIP=$(python3 driad.py 23.212.185.4)
+~~~
+
+#### Picking A Known Relay
+
+Internet2 also has some AMT relays running that can forward the [live traffic on Internet2](https://multicastmenu.herokuapp.com).
+They're hooking those relays up to the domain `amt-relay.m2icast.net.`, so you can discover them with that name:
+
+~~~
+RELAYIP=$(dig +short amt-relay.m2icast.net. | shuf | head -n 1)
+~~~
+
+#### Anycast
+
+In theory, the method described in the original AMT spec could also be used, which is that on a global multicast backbone, a well-known reserved anycast IP address would map to the nearest AMT relay.
+
+In practice, relays assigned to those IP addresses are not deployed at the time of this writing, and nobody has yet volunteered to deploy this kind of public infrastructure.
+However, if you want to try it or deploy some locally, the [well-known anycast IPs](https://www.rfc-editor.org/rfc/rfc7450.html#section-7) are `192.52.193.1` and `2001:3::1`.
+
+### Running An AMT Gateway
+
+When you have a relay IP that can forward the traffic you want, you can run an AMT gateway to connect to it:
+
+~~~
+docker run -d --rm --name amtgw --privileged grumpyoldtroll/amtgw $RELAYIP
+~~~
+
+This will let you receive traffic in the `docker0` network:
+
+~~~
+./mcrx-check -s 23.212.185.4 -g 232.1.1.1 -p 5001 -i docker0 -d 0 -n 10
+~~~
+
+Instead of specifying an interface override, it's also possible to set a route for the source IP toward the interface where the AMT gateway will produce traffic:
+
+~~~
+sudo ip route add 23.212.185.4/32 dev docker0
+mcrx-check -s 23.212.185.4 -g 232.1.1.1 -p 5001 -d 0 -c 10
+~~~
+
+When you're done with the traffic, it's wise to clean up by removing the route if you added one and stopping the container:
+
+~~~
+sudo ip route del 23.212.185.4/32 dev docker0
+docker stop amtgw
+~~~
+
+### Forwarding Traffic From AMT Into Your LAN
+
+If you want to use an AMT gateway to ingest the traffic and forward it on an external interface, it's possible with the `grumpyoldtroll/amtgw` image to add a macvlan interface, which will result in multicast traffic being emitted onto the 2nd connected interface.
+Reading up on [docker macvlan networking](https://docs.docker.com/network/network-tutorial-macvlan/) may help determine if this makes sense in your network, and if so what config parameters to use:
+
+~~~
+docker network create --driver macvlan --subnet=192.168.56.0/24 --ip-range=192.168.56.0/26 --gateway=192.168.56.1 -o parent=enp0s8 external-multicast
+
+docker create --rm --name amtgw --privileged grumpyoldtroll/amtgw $RELAYIP
+docker network connect external-multicast amtgw
+docker start amtgw
+~~~
+
+NB: note that a [docker issue](https://github.com/moby/moby/issues/25181) causes the interface ordering to be determined by their lexical name, not the order they're added.
+So in this example, it's important to ensure that the macvlan's name is lexically later than `docker0` so that it's mapped inside the amtgw container, the output network is mapped to eth1 instead of eth0, since in that container eth0 is used for the AMT and DNS traffic and eth1 is used for the multicast output.
+
+Note that for a VM, forwarding traffic into the LAN doesn't have to mean onto a wire, it can be forwarded into a host-only adapter from a guest to send traffic to the host machine or another guest machine sharing the host-only network.
+This can be a useful way to work with multicast in a development environment.
+
diff --git a/third_party/libmcrx/LICENSE b/third_party/libmcrx/LICENSE
new file mode 100644
index 000000000000..bff3066325bf
--- /dev/null
+++ b/third_party/libmcrx/LICENSE
@@ -0,0 +1,15 @@
+BSD 0-clause license
+
+Copyright (C) 2019 by Akamai Technologies
+   Jake Holland <jakeholland.net@gmail.com>
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/third_party/libmcrx/Makefile.am b/third_party/libmcrx/Makefile.am
new file mode 100644
index 000000000000..2ca28c8ac5f5
--- /dev/null
+++ b/third_party/libmcrx/Makefile.am
@@ -0,0 +1,105 @@
+ACLOCAL_AMFLAGS = -I m4 ${ACLOCAL_FLAGS}
+EXTRA_DIST =
+CLEANFILES =
+MAINTAINERCLEANFILES = Makefile.in aclocal.m4 build-aux/compile \
+            build-aux/config.guess build-aux/config.sub build-aux/depcomp \
+            build-aux/install-sh build-aux/ltmain.sh build-aux/missing \
+            config.h.in config.h.in~ configure m4/libtool.m4 m4/ltoptions.m4 \
+            m4/ltsugar.m4 m4/ltversion.m4 m4/lt~obsolete.m4
+MOSTLYCLEANFILES =
+AM_MAKEFLAGS = --no-print-directory
+
+# https://linux.die.net/man/7/feature_test_macros
+AM_CPPFLAGS = \
+	-include $(top_builddir)/config.h \
+	-DSYSCONFDIR=\""$(sysconfdir)"\" \
+	-DLIBEXECDIR=\""$(libexecdir)"\" \
+	-I${top_srcdir}/include \
+	-I${top_srcdir}/src
+
+AM_CFLAGS = ${my_CFLAGS} \
+	-fvisibility=hidden \
+	-ffunction-sections \
+	-fdata-sections
+
+#AM_LDFLAGS = -levent
+
+SED_PROCESS = \
+	$(AM_V_GEN)$(MKDIR_P) $(dir $@) && $(SED) \
+	-e 's,@VERSION\@,$(VERSION),g' \
+	-e 's,@prefix\@,$(prefix),g' \
+	-e 's,@exec_prefix\@,$(exec_prefix),g' \
+	-e 's,@libdir\@,$(libdir),g' \
+	-e 's,@includedir\@,$(includedir),g' \
+	< $< > $@ || rm $@
+
+%.pc: %.pc.in Makefile
+	$(SED_PROCESS)
+
+LIBMCRX_CURRENT=2
+LIBMCRX_REVISION=0
+LIBMCRX_AGE=2
+
+pkginclude_HEADERS = include/mcrx/libmcrx.h include/mcrx/errors.h
+lib_LTLIBRARIES = libmcrx.la
+lib_LIBRARIES = libmcrx.a
+noinst_PROGRAMS = mcrx-check
+
+libmcrx_la_SOURCES =\
+	src/libmcrx-private.h \
+	src/libmcrx.c \
+	src/native.c \
+	src/wait.c
+libmcrx_la_CFLAGS = $(AM_CFLAGS)
+
+libmcrx_a_SOURCES = $(libmcrx_la_SOURCES)
+libmcrx_a_CFLAGS = $(AM_CFLAGS)
+
+mcrx_check_SOURCES = test/mcrx-check.c
+mcrx_check_LDADD = libmcrx.a
+
+# with thanks:
+# https://stackoverflow.com/questions/29811970/adding-linting-to-autotools-based-build-system
+LINTFILES = $(libmcrx_la_SOURCES) $(pkginclude_HEADERS)
+LINTTARGETS = $(LINTFILES:%=%.lint)
+
+lint: $(LINTTARGETS)
+
+%.lint: %
+	$(CPPLINT) $? | tee $@
+
+all-local: lint
+
+.PHONY: lint
+
+# following hints from:
+# https://www.gnu.org/software/automake/manual/html_node/Clean.html
+MOSTLYCLEANFILES += $(LINTTARGETS)
+
+EXTRA_DIST += src/libmcrx.sym
+
+libmcrx_la_LDFLAGS = $(AM_LDFLAGS) \
+	-version-info $(LIBMCRX_CURRENT):$(LIBMCRX_REVISION):$(LIBMCRX_AGE)
+libmcrx_la_DEPENDENCIES = ${top_srcdir}/src/libmcrx.sym
+
+pkgconfigdir = $(libdir)/pkgconfig
+nodist_pkgconfig_DATA = src/libmcrx.pc
+EXTRA_DIST += src/libmcrx.pc.in
+CLEANFILES += src/libmcrx.pc
+
+TESTS = test/test1-libmcrx test/test-rejoin-same test/test-logstr
+
+check_PROGRAMS = \
+		 test/test1-libmcrx \
+		 test/test-logstr \
+		 test/test-rejoin-same
+
+test_test1_libmcrx_SOURCES = test/test1-libmcrx.c
+test_test1_libmcrx_LDADD = libmcrx.a
+
+test_test_rejoin_same_SOURCES = test/test-rejoin-same.c
+test_test_rejoin_same_LDADD = libmcrx.a
+
+test_test_logstr_SOURCES = test/test-logstr.c
+test_test_logstr_LDADD = libmcrx.a
+
diff --git a/third_party/libmcrx/NEWS b/third_party/libmcrx/NEWS
new file mode 100644
index 000000000000..d5d3c13008e2
--- /dev/null
+++ b/third_party/libmcrx/NEWS
@@ -0,0 +1,3 @@
+libmcrx 1 (2019-07-01)
+
+       Initial release.
diff --git a/third_party/libmcrx/README.md b/third_party/libmcrx/README.md
new file mode 100644
index 000000000000..4cd5865d6114
--- /dev/null
+++ b/third_party/libmcrx/README.md
@@ -0,0 +1,144 @@
+# Intro
+
+libmcrx is a low-level library for receiving multicast UDP traffic.
+
+## Motivation
+
+The code for receiving multicast traffic is different on different platforms, and has some quirks and complexities.
+This library is intended to ease adoption of multicast-based protocols by simplifying the programming task of receiving multicast packets at the client side.
+Its API uses C linkage in an attempt to maximize the portability for implementing simple wrappers in other languages.
+
+The library also is intended to serve as an extension point to integrate with some standards and standard-tracked work in progress in the IETF, ideally including:
+
+ - [AMBI](https://datatracker.ietf.org/doc/draft-ietf-mboned-ambi/): an asymmetric cryptographic authentication scheme for multicast traffic
+   - this provides loss statistics as well as authenticated payloads
+ - [CBACC](https://datatracker.ietf.org/doc/draft-ietf-mboned-cbacc/): bandwith limitation enforcement.
+ - [AMT](https://www.rfc-editor.org/rfc/rfc7450.html): unicast tunneling
+   - with [DRIAD](https://www.rfc-editor.org/rfc/rfc8777.html), a tunnel discovery mechanism that ensures use of native multicast is favored where possible
+
+# Building
+
+## Linux
+
+### Prerequisites
+
+For normal linux builds of the library, this project uses autoconf and automake, following the [libabc](http://0pointer.de/blog/projects/libabc.html) template.
+
+#### APT-based (Debian, Ubuntu)
+
+~~~
+apt-get install \
+  autoconf \
+  libtool-bin \
+  make \
+  build-essential
+~~~
+
+#### MacOS with brew
+
+Using [brew](https://brew.sh/):
+
+~~~
+brew install \
+  autoconf \
+  automake \
+  make \
+  libtool
+~~~
+
+TBD: more platforms
+
+### Build
+
+~~~
+./autogen.sh
+./configure
+make
+~~~
+
+As usual with autotools, `./configure --help` provides a bunch of options, and more in-depth [explanations](https://www.gnu.org/prep/standards/html_node/Configuration.html#Configuration) give more [useful details](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html).
+
+For example, with something like `--prefix=${HOME}/local-install` a `make install` will not need sudo, and will put the library and header files under ${HOME}/local-install.
+
+### Test
+
+Note that to test this library, you'll need reachability to an active sender of multicast traffic.  See the [how-to](HOWTO.md) for some approaches.
+
+NB: the current tests use a hardcoded (S,G), and probably should be changed to use a config file instead.  As-is you'll basically need to be using the multicast-ingest-platform or to be in a multicast-capable network that performs ingest using DRIAD for it to pass, assuming the sender it uses is running.
+
+~~~
+make check
+~~~
+
+### Install
+
+Autoconf by default should build a configure and Makefiles that will put the headers and libraries into the default location for user libraries for the system.
+
+~~~
+sudo make install
+~~~
+
+# Using the library
+
+This library is structured as a few types of objects in a hierarchy, wrapping as much socket-receiving complexity as we could arrange.
+
+The relevant objects are:
+
+ - **ctx**: a context.  All the function calls are associated with exactly one context (or with an object below that's associated with exactly one context).  Multiple contexts may exist, and objects associated with different contexts do not directly interact (they can be processed by separate threads without any synchronization between contexts, for example).
+ - **sub**: a subscription.  Each subscription is associated immutably with an (S,G) or (\*,G) and a UDP port number.  A callback function is set for the subscription and provides received packets.
+ - **pkt**: a packet.  Each packet provides the payload of a UDP packet received on the wire and associated with a particular subscription.
+
+Each of these objects is created with a "_new" function, and is destroyed with a "_unref" function.  (An internal refcount may be increased with a "_ref" function, which will keep the object alive through one extra "_unref".)
+
+Each object also can hold an arbitrary "user data" pointer, set and retrieved with a set_userdata and get_userdata function.  That pointer is opaque to the library, and provided as a convenience for the calling system.
+
+Basic usage looks like this:
+
+~~~c
+#include <mcrx/libmcrx.h>
+
+static int receive_cb(struct mcrx_packet* packet);
+
+int receive_thread() {
+  struct mcrx_ctx* ctx = NULL;
+  mcrx_ctx_new(&ctx);
+
+  struct mcrx_subscription_config conf = MCRX_SUBSCRIPTION_CONFIG_INIT;
+  mxrx_subscription_config_pton(&conf, "23.212.185.4", "232.1.1.1");
+  conf.port = 5001;
+
+  struct mcrx_subscription *sub;
+  mcrx_subscription_new(ctx, &conf, &sub);
+  mcrx_subscription_set_receive_cb(sub, receive_cb);
+
+  mcrx_subscription_join(sub);
+
+  while (1) {
+    mcrx_ctx_receive_packets(ctx);
+  }
+}
+
+static int receive_cb(struct mcrx_packet* packet) {
+  // do something with packet
+  // operations like creating, joining, and leaving subscriptions are
+  // safe here.
+  mcrx_packet_unref(packet);
+  return MCRX_RECEIVE_CONTINUE;
+}
+~~~
+
+For a more detailed example including appropriate error handling, please see [mcrx-check](test/mcrx-check.c).
+
+## Thread Safety
+
+There is no thread safety handling inside the library.
+It's the caller's responsibility to ensure that no calls to any functions using the same ctx or the objects generated from the same ctx (including packets and subscriptions) have function calls that overlap in time between different threads.
+
+## Alternative Event Handlers
+
+For an example integrating with an external event handler instead of using the blocking mcrx_ctx_receive_packets call, see the libmcrx integration with [python-asyncio-taps](https://github.com/fg-inet/python-asyncio-taps).
+
+That project uses python's [asyncio](https://docs.python.org/3/library/asyncio.html) as the event handling library, and exports sockets to be added to the list of sockets to monitor for read readiness via mcrx_ctx_set_receive_socket_handlers, rather than using the blocking mcrx_ctx_receive_packets call.
+
+In that scenario, the calling system is responsible for making a timely call to the do_receive function for all the sockets that have been given to the calling system with the add_socket_cb callback and that have not yet been removed with the remove_socket_cb callback.
+
diff --git a/third_party/libmcrx/autogen.sh b/third_party/libmcrx/autogen.sh
new file mode 100755
index 000000000000..a22c937ef590
--- /dev/null
+++ b/third_party/libmcrx/autogen.sh
@@ -0,0 +1,19 @@
+#!/bin/sh -e
+
+autoreconf --install --symlink
+
+libdir() {
+        echo $(cd $1/$(gcc -print-multi-os-directory 2>/dev/null); pwd)
+}
+
+args="--prefix=/usr \
+--sysconfdir=/etc \
+--libdir=$(libdir /usr/lib)"
+
+echo
+echo "----------------------------------------------------------------"
+echo "Initialized build system. For a common configuration please run:"
+echo "----------------------------------------------------------------"
+echo
+echo "./configure CFLAGS='-g -O0' $args"
+echo
diff --git a/third_party/libmcrx/configure.ac b/third_party/libmcrx/configure.ac
new file mode 100644
index 000000000000..ed4662b33319
--- /dev/null
+++ b/third_party/libmcrx/configure.ac
@@ -0,0 +1,88 @@
+AC_PREREQ(2.60)
+AC_INIT([mcrx],
+        [1],
+        [jakeholland.net@gmail.com],
+        [mcrx],
+        [http://github.com/GrumpyOldTroll/libmcrx])
+AC_CONFIG_SRCDIR([src/libmcrx.c])
+AC_CONFIG_AUX_DIR([build-aux])
+AC_CONFIG_LIBOBJ_DIR([portable])
+AM_INIT_AUTOMAKE([check-news foreign 1.11 -Wall -Werror -Wno-portability silent-rules tar-pax no-dist-gzip dist-xz subdir-objects])
+AM_MAINTAINER_MODE
+AC_PROG_CC_STDC
+AC_USE_SYSTEM_EXTENSIONS
+AC_SYS_LARGEFILE
+AC_CONFIG_MACRO_DIR([m4])
+AM_SILENT_RULES([yes])
+LT_INIT([disable-static pic-only])
+AC_PREFIX_DEFAULT([/usr])
+
+AC_PROG_SED
+AC_PROG_MKDIR_P
+
+AC_ARG_ENABLE([logging],
+        AS_HELP_STRING([--disable-logging], [disable system logging @<:@default=enabled@:>@]),
+        disable_logging=yes, [])
+AS_IF([test "x$disable_logging" = "xyes"], [
+        AC_DEFINE(DISABLE_LOGGING, [1], [System logging.])
+])
+
+AC_PATH_PROG([CPPLINT], [cpplint], [true])
+AS_IF([test "x$CPPLINT" = xtrue],
+    [AC_MSG_WARN([We recommend cpplint for developing this package.
+Get it from 'pip install cpplint' or https://github.com/cpplint/cpplint])])
+
+AC_ARG_ENABLE([debug],
+        AS_HELP_STRING([--enable-debug], [enable debug messages @<:@default=disabled@:>@]),
+        [], [disable_debug=yes])
+AS_IF([test "x$disable_debug" = "xyes"], [
+        AC_DEFINE(DISABLE_DEBUG, [1], [Debug messages.])
+])
+
+#AC_CHECK_HEADER([event.h],
+#     [AC_DEFINE([HAVE_EVENT_H], [1], [Define to 1 if you have <event.h>.])],
+#     [AC_MSG_ERROR([could not include <event.h>. You need to install libevent-dev or build from https://github.com/libevent/libevent.git and set C_INCLUDE_PATH and LIBRARY_PATH])])
+#
+#AC_CHECK_LIB([event],[event_base_new],
+#	[AC_DEFINE([HAVE_EVENT_LIB], [1], [Define to 1 if you have libevent])],
+#	[AC_MSG_ERROR([could not invoke event_base_new with -levent, you need to install libevent-dev or build from https://github.com/libevent/libevent.git and set C_INCLUDE_PATH and LIBRARY_PATH])])
+#
+#AC_CHECK_HEADER([dns_sd.h],
+#     [AC_DEFINE([HAVE_DNSSD_H], [1], [Define to 1 if you have <dns_sd.h>.])],
+#     [AC_MSG_ERROR([could not include <dns_sd.h>. You need to install libavahi-compat-libdnssd-dev or build from https://github.com/IETF-Hackathon/mDNSResponder.git (mDNSPosix) and set C_INCLUDE_PATH and LIBRARY_PATH])])
+
+# commenting for mac.  it's not libdns_sd, it's part of system libraries,
+# so there needs to be a mac/other special case.
+#AC_CHECK_LIB([dns_sd],[DNSServiceRegister],
+#	[AC_DEFINE([HAVE_DNSSD_LIB], [1], [Define to 1 if you have libdns_sd])],
+#	[AC_MSG_ERROR([could not load libdns_sd.so. You need to install mdnsd or build from https://github.com/IETF-Hackathon/mDNSResponder.git (mDNSPosix) and set C_INCLUDE_PATH and LIBRARY_PATH])])
+
+my_CFLAGS="-pedantic -Wall -Wextra \
+-Wmissing-declarations -Wmissing-prototypes \
+-Wnested-externs -Wsign-compare \
+-Wstrict-prototypes -Wshadow \
+-Wformat-security"
+AC_SUBST([my_CFLAGS])
+
+AC_CONFIG_HEADERS(config.h)
+AC_CONFIG_FILES([
+        Makefile
+])
+
+AC_OUTPUT
+AC_MSG_RESULT([
+        $PACKAGE $VERSION
+        =====
+
+        prefix:                 ${prefix}
+        sysconfdir:             ${sysconfdir}
+        libdir:                 ${libdir}
+        includedir:             ${includedir}
+
+        compiler:               ${CC}
+        cflags:                 ${CFLAGS}
+        ldflags:                ${LDFLAGS}
+
+        logging:                ${enable_logging}
+        debug:                  ${enable_debug}
+])
diff --git a/third_party/libmcrx/driad.py b/third_party/libmcrx/driad.py
new file mode 100644
index 000000000000..883aa8839bb0
--- /dev/null
+++ b/third_party/libmcrx/driad.py
@@ -0,0 +1,173 @@
+#!/usr/bin/env python3
+
+# libmcrx - multicast receiving library
+# driad.py
+#
+# Copyright (C) 2019 by Akamai Technologies
+#    Jake Holland <jakeholland.net@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+import sys
+import random
+import ipaddress
+import subprocess
+import argparse
+import re
+from itertools import groupby
+
+'''
+Attempts lookup of an AMT relay that can forward multicast traffic
+from <source_ip> via DRIAD (draft-ietf-mboned-driad-amt-discovery).
+This does not perform the DNS-SD lookup to find a local relay, only
+the remote lookup of a relay known to the source using DNS RRType
+260.
+
+requires 'dig' in path.
+
+Outputs an IP address of an AMT relay, if successful.
+'''
+
+def main(args_in):
+    parser = argparse.ArgumentParser(
+            description='''
+Use DNS RRType 260 to look up an AMT relay known to a multicast
+sender, identified by the sending IP address of a (S,G).  See
+draft-ietf-mboned-driad-amt-discovery for details.''')
+
+    parser.add_argument('-v', '--verbose', action='count')
+    parser.add_argument('SourceIP', help='source ip of a multicast source')
+    parser.add_argument('-r', '--resolver', help='use a specific DNS resolver')
+
+    args = parser.parse_args(args_in[1:])
+    source_ip_str = args.SourceIP
+
+    source_ip = ipaddress.ip_address(source_ip_str)
+    rev_ip_name = source_ip.reverse_pointer
+    # note: on mac, this does not work without encoding the ip as ascii
+    if args.resolver is None:
+        initial_cmd = ['dig', '+short',  '-t',  'TYPE260', rev_ip_name.encode('ascii')]
+    else:
+        resolver = "@"+args.resolver
+        initial_cmd = ['dig', '+short',  '-t',  'TYPE260', resolver, rev_ip_name.encode('ascii')]
+
+    if args.verbose:
+        print('running "%s"' % ' '.join([str(x) for x in initial_cmd]),
+                file=sys.stderr)
+
+    initial_dig_output = \
+            subprocess.check_output(initial_cmd).decode('ascii').strip()
+
+    amt_line_re = re.compile(r'^\s*(?:\\#\s+(?P<generic_len>[0-9]+)\s+(?P<generic_data>(?:[0-9a-fA-F]|\s)+)|(?P<precedence>[0-9]+)\s+(?P<dbit>0|1)\s+(?P<type>[0-3])\s+(?P<relay>\S+)\s*)$')
+
+    possibilities = []
+    for line in initial_dig_output.split('\n'):
+        if args.verbose:
+            print('parsing line: %s' % line, file=sys.stderr)
+        m = amt_line_re.match(line)
+        if not m:
+            if args.verbose:
+                print(f'  skipping line "{line}" (does not match AMTRELAY)...', file=sys.stderr)
+            continue
+        prec_str = m.group('precedence')
+        if prec_str:
+            cur_precedence = int(prec_str)
+        else:
+            val = m.group('generic_data')
+            if val:
+                cur_precedence = int(val[0:2],16)
+            else:
+                if args.verbose:
+                    print(f'  internal error: matched regex without precedence, skipping', file=sys.stderr)
+                continue
+        possibilities.append((cur_precedence, m))
+
+    possibilities.sort()
+    for prec, equal_group in groupby(possibilities, lambda x: x[0]):
+        equal_list = list(equal_group)
+        if len(equal_list) > 1:
+            random.shuffle(equal_list)
+
+        for prec, m in equal_list:
+            typ_str, relay = m.group('type'), m.group('relay')
+            if typ_str:
+                typ = int(typ_str)
+            else:
+                val = m.group('generic_data')
+                typ = int(val[2:4],16)&0x7f
+                loc = val[4:]
+
+                if typ == 1:
+                    relay = '%d.%d.%d.%d' % (
+                            int(loc[0:2],16),
+                            int(loc[2:4],16),
+                            int(loc[4:6],16),
+                            int(loc[6:8],16))
+                elif typ == 2:
+                    relay = ipaddress.ip_address(':'.join(
+                        [loc[i:i+4] for i in range(0,32,4)])).compressed
+                elif typ == 3:
+                    ix = 0
+                    names = []
+                    while ix < len(loc):
+                        ln = int(loc[ix:ix+2],16)
+                        if ln == 0:
+                            break
+                        #print('ln:%d' % ln)
+                        ix += 2
+                        name=''.join([chr(int(loc[jx:jx+2],16))
+                            for jx in range(ix, ix+2*ln, 2)])
+                        #print('name:%s' % name)
+                        names.append(name)
+                        ix += 2*ln
+                    relay = '.'.join(names)
+
+                else:
+                    print('failed TYPE260 generic parse:%s' % (val), file=sys.stderr)
+                    continue
+
+            if typ == 3:
+                if args.resolver is None:
+                    secondary_dig_cmd = ['dig', '+short', relay.encode('ascii')]
+                else:
+                    resolver = "@"+args.resolver
+                    secondary_dig_cmd = ['dig', '+short', resolver, relay.encode('ascii')]
+                if args.verbose:
+                    print('  running "%s"' % ' '.join([str(x) for x in secondary_dig_cmd]),
+                        file=sys.stderr)
+                out  = subprocess.check_output(secondary_dig_cmd).decode('ascii').strip()
+                if not out:
+                    print('  rejecting: %s failed: %s' % (' '.join(secondary_dig_cmd), out), file=sys.stderr)
+                    continue
+                addrs = []
+                for line in out.split('\n'):
+                    try:
+                        addr = ipaddress.ip_address(line.strip())
+                    except:
+                        continue
+                    addrs.append(line.strip())
+                if len(addrs) == 0:
+                    print('  rejecting: %s no addresses found in output: %s' % (' '.join(secondary_dig_cmd), out), file=sys.stderr)
+                    continue
+
+                relay = addrs[random.randint(0, len(addrs)-1)]
+
+            print(relay)
+            return 0
+
+    print('no results from DRIAD lookup: "%s"' %
+            ' '.join([str(x) for x in initial_cmd]), file=sys.stderr)
+    return -1
+
+if __name__=="__main__":
+    ret = main(sys.argv)
+    exit(ret)
diff --git a/third_party/libmcrx/include/mcrx/errors.h b/third_party/libmcrx/include/mcrx/errors.h
new file mode 100644
index 000000000000..1286597737da
--- /dev/null
+++ b/third_party/libmcrx/include/mcrx/errors.h
@@ -0,0 +1,79 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#pragma once
+
+#ifndef GUARD_LIBMCRX_ERRORS_H
+#define GUARD_LIBMCRX_ERRORS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum mcrx_error_code {
+  MCRX_ERR_OK = 0,
+  MCRX_ERR_TIMEDOUT,  // only from receive_packets, if timeout hit.
+  MCRX_ERR_NOMEM,
+  MCRX_ERR_NULLARG,
+  MCRX_ERR_NOSPACE,
+  MCRX_ERR_UNKNOWN_FAMILY,
+  MCRX_ERR_UNSUPPORTED,
+  MCRX_ERR_ALREADY_JOINED,
+  MCRX_ERR_ALREADY_NOTJOINED,
+  MCRX_ERR_INTERNAL_ERROR,
+  MCRX_ERR_CALLBACK_FAILED,
+  MCRX_ERR_NOTHING_JOINED,
+  MCRX_ERR_INCONSISTENT_HANDLER,
+
+  // errors from system calls within the library.  errno
+  // remains as set by the underlying system.
+  // for stability under change, these come from a different space.
+  MCRX_ERR_SYSCALL_BIND = 9001,
+  MCRX_ERR_SYSCALL_CLOSE,
+  MCRX_ERR_SYSCALL_CONNECT,
+  MCRX_ERR_SYSCALL_FCNTL,
+  MCRX_ERR_SYSCALL_GETSOCKNAME,
+  MCRX_ERR_SYSCALL_GETIFADDRS,
+  MCRX_ERR_SYSCALL_NTOP,
+  MCRX_ERR_SYSCALL_RECVMSG,
+  MCRX_ERR_SYSCALL_SOCKET,
+  MCRX_ERR_SYSCALL_SETSOCKOPT,
+  MCRX_ERR_SYSCALL_SETSOURCEFILTER,
+  MCRX_ERR_SYSCALL_EPOLLCREATE,
+  MCRX_ERR_SYSCALL_EPOLLADD,
+  MCRX_ERR_SYSCALL_EPOLLDEL,
+  MCRX_ERR_SYSCALL_EPOLLWAIT,
+  MCRX_ERR_SYSCALL_KEVENT,
+  MCRX_ERR_SYSCALL_KQUEUE,
+};
+
+// this will give error information about the error code above
+// if mcrx_is_system_error(err) is true, there may be additional
+// information available by calling strerror(errno)
+const char* mcrx_strerror(enum mcrx_error_code err);
+
+// this is zero when no errno can be expected, or 1 when errno
+// can be used to strerror(errno) to see the underlying system
+// problem encountered.
+int mcrx_is_system_error(enum mcrx_error_code err);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif  // GUARD_LIBMCRX_ERRORS_H
diff --git a/third_party/libmcrx/include/mcrx/libmcrx.h b/third_party/libmcrx/include/mcrx/libmcrx.h
new file mode 100644
index 000000000000..e14cfc0540f5
--- /dev/null
+++ b/third_party/libmcrx/include/mcrx/libmcrx.h
@@ -0,0 +1,288 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#pragma once
+
+#ifndef GUARD_LIBMCRX_H
+#define GUARD_LIBMCRX_H
+
+#include <stdarg.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <netinet/in.h>
+#include <mcrx/errors.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * mcrx_ctx:
+ *
+ * library user context - reads the config and system
+ * environment, user variables, allows custom logging
+ */
+struct mcrx_ctx;
+
+/**
+ * mcrx_subscription:
+ *
+ * subscription handle - joins a (S,G) and passes received
+ * packets to library user.
+ */
+struct mcrx_subscription;
+
+/**
+ * mcrx_packet:
+ *
+ * packet handle - provides data and packet lengths to
+ * library user.
+ */
+struct mcrx_packet;
+
+struct mcrx_ctx *mcrx_ctx_ref(
+    struct mcrx_ctx *ctx);
+struct mcrx_ctx *mcrx_ctx_unref(
+    struct mcrx_ctx *ctx);
+intptr_t mcrx_ctx_get_userdata(
+    struct mcrx_ctx *ctx);
+void mcrx_ctx_set_userdata(
+    struct mcrx_ctx *ctx,
+    intptr_t userdata);
+
+enum mcrx_error_code mcrx_ctx_new(
+    struct mcrx_ctx **ctxp);
+
+
+void mcrx_ctx_set_log_fn(
+    struct mcrx_ctx *ctx,
+    void (*log_fn)(
+      struct mcrx_ctx *ctx,
+      int priority,  // a value from mcrx_log_priority
+      const char *file,
+      int line,
+      const char *fn,
+      const char *format,
+      va_list args));
+void mcrx_ctx_set_log_string_fn(
+    struct mcrx_ctx *ctx,
+    void (*log_fn)(
+      struct mcrx_ctx *ctx,
+      int priority,  // a value from mcrx_log_priority
+      const char *file,
+      int line,
+      const char *fn,
+      const char *str));
+// log priority values match those in <sys/syslog.h>
+// but only these values are supported.
+enum mcrx_log_priority {
+  MCRX_LOGLEVEL_ERROR = 3,    // MCRX_LOG=err
+  MCRX_LOGLEVEL_WARNING = 4,  // MCRX_LOG=warn
+  MCRX_LOGLEVEL_INFO = 6,     // MCRX_LOG=info
+  MCRX_LOGLEVEL_DEBUG = 7,    // MCRX_LOG=dbg
+};
+// log priority: LOG_ERR, LOG_WARNING, LOG_INFO, or LOG_DEBUG (syslog.h)
+enum mcrx_log_priority mcrx_ctx_get_log_priority(
+    struct mcrx_ctx *ctx);
+void mcrx_ctx_set_log_priority(
+    struct mcrx_ctx *ctx,
+    enum mcrx_log_priority priority);
+
+/**
+ * mcrx_ctx_log_msg:
+ *
+ * writes a message into the same log stream as mcrx internal logging.
+ */
+void mcrx_ctx_log_msg(
+    struct mcrx_ctx *ctx,
+    enum mcrx_log_priority prio,
+    const char *file,
+    int line,
+    const char *fn,
+    const char* msg);
+
+
+// Default value is 1000+random()%1000
+// like epoll, 0 means don't block, -1 means infinity
+void mcrx_ctx_set_wait_ms(
+    struct mcrx_ctx *ctx,
+    int timeout_ms);
+
+enum mcrx_error_code mcrx_ctx_receive_packets(
+    struct mcrx_ctx *ctx);
+
+enum mcrx_error_code mcrx_ctx_set_receive_socket_handlers(
+    struct mcrx_ctx *ctx,
+    int (*add_socket_cb)(
+        struct mcrx_ctx* ctx,
+        intptr_t handle,
+        int fd,
+        int (*do_receive)(intptr_t handle, int fd)),
+    int (*remove_socket_cb)(
+        struct mcrx_ctx* ctx,
+        int fd));
+
+
+/**
+ * mcrx_subscription_addrs_v4:
+ *
+ * on platforms with struct in_addr, a memcpy from one of those into
+ * these objects is ok.  This is declared weird for easier cross-platform.
+ *
+ * struct in_addr usually there if you include <netinet/in.h>
+ * and can be filled from string with inet_ntop(AF_INET)
+ */
+struct mcrx_subscription_addrs_v4 {
+  struct in_addr source;
+  struct in_addr group;
+};
+
+/**
+ * mcrx_subscription_addrs_v6:
+ *
+ * on platforms with struct in6_addr, a memcpy from one of those into
+ * these objects is ok.  This is declared weird for easier cross-platform.
+ *
+ * struct in_addr usually there if you include <netinet/in.h>
+ * and can be filled from string with inet_ntop(AF_INET6)
+ */
+struct mcrx_subscription_addrs_v6 {
+  struct in6_addr source;
+  struct in6_addr group;
+};
+
+enum MCRX_ADDR_TYPE {
+  MCRX_ADDR_TYPE_UNKNOWN,
+  MCRX_ADDR_TYPE_V4,
+  MCRX_ADDR_TYPE_V6
+};
+
+/**
+ * mcrx_subscription_config:
+ *
+ * config for the subscription object.  Provides the (S,G) either as
+ * a pair of v4 addresses, a pair of v6 addresses, or a pair of DNS
+ * names (which may be address strings, but will error if they don't
+ * match type after resolution).  Also requires UDP port.  Initialize
+ * with MCRX_SUBSCRIPTION_INIT, then overwrite fields as needed.
+ */
+struct mcrx_subscription_config {
+  int magic;
+  uint16_t packet_size;
+  uint16_t port;  // in host byte order (.port=255 to get wire=0x00ff)
+  enum MCRX_ADDR_TYPE addr_type;
+  union {
+    struct mcrx_subscription_addrs_v4 v4;
+    struct mcrx_subscription_addrs_v6 v6;
+  } addrs;
+};
+#define MCRX_SUBSCRIPTION_CONFIG_INIT_MAGIC 0x42
+// default values
+#define MCRX_SUBSCRIPTION_CONFIG_INIT { \
+  .magic = MCRX_SUBSCRIPTION_CONFIG_INIT_MAGIC, \
+  .packet_size = 1452 \
+}
+
+enum mcrx_error_code mcrx_subscription_config_pton(
+    struct mcrx_subscription_config* config,
+    const char* source,
+    const char* group);
+
+struct mcrx_subscription* mcrx_subscription_ref(
+    struct mcrx_subscription* sub);
+struct mcrx_subscription* mcrx_subscription_unref(
+    struct mcrx_subscription* sub);
+intptr_t mcrx_subscription_get_userdata(
+    struct mcrx_subscription *sub);
+void mcrx_subscription_set_userdata(
+    struct mcrx_subscription *sub,
+    intptr_t userdata);
+struct mcrx_ctx* mcrx_subscription_get_ctx(
+    struct mcrx_subscription* sub);
+void mcrx_subscription_override_ifname(
+    struct mcrx_subscription* sub,
+    const char* ifname);
+
+enum mcrx_error_code mcrx_subscription_new(
+    struct mcrx_ctx* ctx,
+    const struct mcrx_subscription_config* config,
+    struct mcrx_subscription** subp);
+
+/*
+ * at entry to receive_cb, mcrx_packet_get_userdata returns the
+ * same as mcrx_subscription_get_userdata for the sub.
+ */
+enum mcrx_receive_cb_continuation {
+  MCRX_RECEIVE_CONTINUE = 0,
+  MCRX_RECEIVE_STOP_FD,
+  MCRX_RECEIVE_STOP_CTX
+};
+void mcrx_subscription_set_receive_cb(
+    struct mcrx_subscription* sub,
+    int (*receive_cb)(
+      struct mcrx_packet* packet));
+
+void mcrx_subscription_set_max_payload(
+    struct mcrx_subscription* sub,
+    uint16_t payload_size);
+enum mcrx_error_code mcrx_subscription_join(
+    struct mcrx_subscription* sub);
+enum mcrx_error_code mcrx_subscription_leave(
+    struct mcrx_subscription* sub);
+
+struct mcrx_packet* mcrx_packet_ref(
+    struct mcrx_packet* pkt);
+struct mcrx_packet* mcrx_packet_unref(
+    struct mcrx_packet* pkt);
+intptr_t mcrx_packet_get_userdata(
+    struct mcrx_packet* pkt);
+void mcrx_packet_set_userdata(
+    struct mcrx_packet* pkt,
+    intptr_t userdata);
+struct mcrx_subscription* mcrx_packet_get_subscription(
+    struct mcrx_packet* pkt);
+
+// returns length of data
+uint16_t mcrx_packet_get_contents(
+    struct mcrx_packet* pkt,
+    uint8_t** data);
+// remote port of received packet (host byte order)
+uint16_t mcrx_packet_get_remote_port(
+    struct mcrx_packet* pkt);
+
+#define MCRX_SUB_STRLEN (INET6_ADDRSTRLEN+2+INET6_ADDRSTRLEN+1+6)
+/**
+ * mcrx_subscription_ntop:
+ * @sub: subscription
+ * @buf: buffer to write desc into
+ * @len: len of buffer (use MCRX_SUB_STRLEN to guarantee size)
+ *
+ * Write "src->grp(port)" to buf, return nonzero and set errno on error.
+ *
+ * Returns: 0 on success, nonzero on error.
+ */
+enum mcrx_error_code mcrx_subscription_ntop(
+    struct mcrx_subscription* sub,
+    char* buf,
+    int buflen);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif  // GUARD_LIBMCRX_H
diff --git a/third_party/libmcrx/m4/.gitignore b/third_party/libmcrx/m4/.gitignore
new file mode 100644
index 000000000000..8bab51c22bf5
--- /dev/null
+++ b/third_party/libmcrx/m4/.gitignore
@@ -0,0 +1,6 @@
+libtool.m4
+ltoptions.m4
+ltsugar.m4
+ltversion.m4
+lt~obsolete.m4
+
diff --git a/third_party/libmcrx/portable/.gitignore b/third_party/libmcrx/portable/.gitignore
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/third_party/libmcrx/src/.gitignore b/third_party/libmcrx/src/.gitignore
new file mode 100644
index 000000000000..c28a8f019013
--- /dev/null
+++ b/third_party/libmcrx/src/.gitignore
@@ -0,0 +1,8 @@
+.dirstamp
+.deps/
+.libs/
+*.la
+*.lo
+libmcrx.pc
+.*.sw?
+*~
diff --git a/third_party/libmcrx/src/libmcrx-private.h b/third_party/libmcrx/src/libmcrx-private.h
new file mode 100644
index 000000000000..13605c786d42
--- /dev/null
+++ b/third_party/libmcrx/src/libmcrx-private.h
@@ -0,0 +1,222 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#pragma once
+
+#ifndef GUARD_LIBMCRX_PRIVATE_H_
+#define GUARD_LIBMCRX_PRIVATE_H_
+
+#include <stdbool.h>
+#include <syslog.h>
+#include <sys/queue.h>
+
+#include <mcrx/libmcrx.h>
+
+#ifdef __APPLE__
+#define MCRX_PRV_USE_KEVENT 1
+#define MCRX_PRV_USE_EPOLL 0
+#endif
+
+#ifdef __linux__
+#define MCRX_PRV_USE_KEVENT 0
+#define MCRX_PRV_USE_EPOLL 1
+#endif
+
+#define UNUSED(x) ((void)x)
+
+static inline void __attribute__((always_inline, format(printf, 2, 3)))
+mcrx_log_null(struct mcrx_ctx *ctx, const char *format, ...) {
+  UNUSED(ctx);
+  UNUSED(format);
+}
+
+#ifdef LIBMCRX_STATIC
+#define MCRX_EXPORT
+#else
+// for chromium's static build usage (with checking of exported symbols)
+// this caused an error, but it's needed for the dynamic library usage
+// in https://github.com/fg-inet/python-asyncio-taps. --jake 2020-10
+#define MCRX_EXPORT __attribute__((visibility("default")))
+#endif
+
+#define mcrx_log_cond(ctx, prio, file, line, func, ...)                   \
+  do {                                                                    \
+    if (mcrx_ctx_get_log_priority(ctx) >= prio)                           \
+      mcrx_log(ctx, prio, file, line, func, __VA_ARGS__); \
+  } while (0)
+
+#ifdef DISABLE_DEBUG
+#undef DISABLE_DEBUG
+#endif
+
+#ifndef DISABLE_LOGGING
+#ifndef DISABLE_DEBUG
+#define dbg_passthru(ctx, file, line, func, ...) mcrx_log_cond(ctx, \
+    MCRX_LOGLEVEL_DEBUG, file, line, func, __VA_ARGS__)
+#define dbg(ctx, ...) dbg_passthru(ctx, __FILE__, __LINE__, __func__, \
+    __VA_ARGS__)
+#else
+#define dbg(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#endif
+#define info_passthru(ctx, file, line, func, ...) mcrx_log_cond(ctx, \
+    MCRX_LOGLEVEL_INFO, file, line, func, __VA_ARGS__)
+#define warn_passthru(ctx, file, line, func, ...) mcrx_log_cond(ctx, \
+    MCRX_LOGLEVEL_WARNING, file, line, func, __VA_ARGS__)
+#define err_passthru(ctx, file, line, func, ...) mcrx_log_cond(ctx, \
+    MCRX_LOGLEVEL_ERROR, file, line, func, __VA_ARGS__)
+
+#define info(ctx, ...) info_passthru(ctx, __FILE__, __LINE__, __func__, \
+    __VA_ARGS__)
+#define warn(ctx, ...) warn_passthru(ctx, __FILE__, __LINE__, __func__, \
+    __VA_ARGS__)
+#define err(ctx, ...) err_passthru(ctx, __FILE__, __LINE__, __func__, \
+    __VA_ARGS__)
+#else
+#define dbg(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#define info(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#define warn(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#define err(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+
+#define dbg_passthru(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#define info_passthru(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#define warn_passthru(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#define err_passthru(ctx, ...) mcrx_log_null(ctx, __VA_ARGS__)
+#endif
+
+void mcrx_log(struct mcrx_ctx *ctx, enum mcrx_log_priority priority,
+    const char *file, int line, const char *fn, const char *format, ...)
+    __attribute__((format(printf, 6, 7)));
+
+/**
+ * mcrx_packet:
+ *
+ * Opaque object representing a received packet.
+ */
+struct mcrx_packet {
+  struct mcrx_subscription *sub;
+  int refcount;
+  intptr_t userdata;
+  TAILQ_ENTRY(mcrx_packet) pkt_entries;
+  uint16_t remote_port;
+  uint16_t size;
+  uint8_t data[];
+};
+
+/**
+ * mcrx_subscription:
+ *
+ * Opaque object representing a subscription to an (S,G):port.
+ */
+struct mcrx_subscription {
+  struct mcrx_ctx *ctx;
+  int refcount;
+  intptr_t userdata;
+  uint16_t max_payload_size;
+  LIST_ENTRY(mcrx_subscription) sub_entries;
+  TAILQ_HEAD(tailhead, mcrx_packet) pkts_head;
+  struct mcrx_subscription_config input;
+  int sock_fd;
+  int (*receive_cb)(struct mcrx_packet* packet);
+  int joined;
+  const char* override_ifname;
+};
+
+enum mcrx_socket_handling_state {
+  MCRX_SOCKHANDLER_UNCOMMITTED,
+  MCRX_SOCKHANDLER_BUILTIN,
+  MCRX_SOCKHANDLER_EXTERNAL
+};
+
+/**
+ * mcrx_ctx:
+ *
+ * Opaque object representing the library context.
+ */
+struct mcrx_ctx {
+  int refcount;
+  void (*log_fn)(struct mcrx_ctx *ctx, int priority,
+      const char *file, int line, const char *fn,
+      const char *format, va_list args);
+  void (*string_log_fn)(struct mcrx_ctx *ctx, int priority,
+      const char *file, int line, const char *fn,
+      const char *str);
+  intptr_t userdata;
+  enum mcrx_log_priority log_priority;
+  LIST_HEAD(listhead, mcrx_subscription) subs_head;
+  int timeout_ms;
+  int wait_fd;
+  sigset_t wait_sigmask;
+  intptr_t added_handle;
+  intptr_t removed_handle;
+  int (*add_socket_cb)(
+    struct mcrx_ctx* ctx,
+    intptr_t handle,
+    int fd,
+    int (*do_receive)(intptr_t handle, int fd));
+
+  int (*remove_socket_cb)(
+    struct mcrx_ctx* ctx,
+    int fd);
+
+  u_int live_subs;
+  enum mcrx_socket_handling_state sock_handler_state;
+
+#if MCRX_PRV_USE_KEVENT
+  struct kevent* events;
+  u_int nevents;
+  struct kevent* triggered;
+  u_int ntriggered;
+  u_int nadded;
+#endif
+#if MCRX_PRV_USE_EPOLL
+  struct epoll_event *events;
+  u_int nevents;
+  struct epoll_event* triggered;
+  u_int ntriggered;
+#endif
+};
+
+enum mcrx_error_code mcrx_subscription_native_join(
+    struct mcrx_subscription* sub);
+enum mcrx_error_code mcrx_subscription_native_leave(
+    struct mcrx_subscription* sub);
+
+int mcrx_prv_add_socket_cb(
+    struct mcrx_ctx* ctx,
+    intptr_t handle,
+    int fd,
+    int (*do_receive)(intptr_t handle, int fd));
+
+int mcrx_prv_remove_socket_cb(
+    struct mcrx_ctx* ctx,
+    int fd);
+
+void wrap_strerr(
+    int err_no,
+    char* buf,
+    int len);
+
+enum mcrx_error_code handle_close_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func);
+#define handle_close_error(ctx) handle_close_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+#endif  // GUARD_LIBMCRX_PRIVATE_H_
diff --git a/third_party/libmcrx/src/libmcrx.c b/third_party/libmcrx/src/libmcrx.c
new file mode 100644
index 000000000000..183b9507efc5
--- /dev/null
+++ b/third_party/libmcrx/src/libmcrx.c
@@ -0,0 +1,1057 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#include <mcrx/libmcrx.h>
+#include "./libmcrx-private.h"
+
+/**
+ * SECTION:libmcrx
+ * @short_description: libmcrx context
+ *
+ * The context contains the default values for the library user,
+ * and is passed to all library operations.
+ */
+
+/*
+ * mcrx_log:
+ *
+ * This gets called underneath the "dbg", "info", "warn", and "err"
+ * printf-like macros (as: info(ctx, "something %s", str); )
+ */
+void mcrx_log(
+    struct mcrx_ctx *ctx,
+    enum mcrx_log_priority priority,
+    const char *file,
+    int line,
+    const char *fn,
+    const char *format,
+    ...) {
+  va_list args;
+
+  va_start(args, format);
+  ctx->log_fn(ctx, priority, file, line, fn, format, args);
+  va_end(args);
+}
+
+static void log_stderr(
+    struct mcrx_ctx *ctx,
+    int priority,
+    const char *file,
+    int line,
+    const char *fn,
+    const char *format,
+    va_list args) {
+  UNUSED(ctx);
+  UNUSED(priority);
+  UNUSED(file);
+  UNUSED(line);
+
+  fprintf(stderr, "libmcrx: %s: ", fn);
+  vfprintf(stderr, format, args);
+}
+
+static void log_string_cb(
+    struct mcrx_ctx *ctx,
+    int priority,
+    const char *file,
+    int line,
+    const char *fn,
+    const char *format,
+    va_list args) {
+
+  if (!ctx) {
+    fprintf(stderr, "%s: %d (%s) error: log_string_cb null ctx\n",
+        file, line, fn);
+    return;
+  }
+  if (!ctx->string_log_fn) {
+    fprintf(stderr, "%s: %d (%s) error: log_string_cb called unattached\n",
+        file, line, fn);
+    log_stderr(ctx, priority, file, line, fn, format, args);
+    return;
+  }
+  char buf[1024];
+  int buflen = sizeof(buf);
+  int len = vsnprintf(buf, buflen, format, args);
+  if (len < buflen && len >= 0) {
+    buf[len] = 0;
+  } else {
+    buf[sizeof(buf)-1] = 0;
+    len = sizeof(buf);
+  }
+  ctx->string_log_fn(ctx, priority, file, line, fn, buf);
+}
+
+/**
+ * mcrx_ctx_set_log_fn:
+ * @ctx: mcrx library context
+ * @log_fn: function to be called for logging messages
+ *
+ * The built-in logging writes to stderr. It can be
+ * overridden by a custom function, to plug log messages
+ * into the user's logging functionality.
+ *
+ **/
+MCRX_EXPORT void mcrx_ctx_set_log_fn(
+    struct mcrx_ctx *ctx,
+    void (*log_fn)(
+      struct mcrx_ctx *ctx,
+      int priority,
+      const char *file,
+      int line,
+      const char *fn,
+      const char *format,
+      va_list args)) {
+  if (!ctx) {
+    info(ctx, "mcrx_ctx_set_log_fn called with no ctx\n");
+    return;
+  }
+
+  void (*old_log_fn)(
+      struct mcrx_ctx *ctx,
+      int priority,
+      const char *file,
+      int line,
+      const char *fn,
+      const char *format,
+      va_list args);
+  old_log_fn = ctx->log_fn;
+
+  if (log_fn == NULL) {
+    ctx->log_fn = log_stderr;
+    ctx->string_log_fn = NULL;
+  } else {
+    ctx->log_fn = log_fn;
+    ctx->string_log_fn = NULL;
+  }
+
+  // PRIxPTR from <inttypes.h> should compile everywhere, but this
+  // probably works too, if it has trouble: --jake 2019-06-17
+  // "custom logging function %016llx registered (replaced %016llx)\n",
+  // (unsigned long long)log_fn, (unsigned long long)ctx->log_fn);
+  info(ctx,
+      "custom logging function %016"PRIxPTR
+      " registered (replaced %016"PRIxPTR")\n",
+      (uintptr_t)log_fn, (uintptr_t)old_log_fn);
+}
+
+/**
+ * mcrx_ctx_set_log_string_fn:
+ * @ctx: mcrx library context
+ * @string_log_fn: function to be called for logging messages
+ *
+ * This can be used instead of mcrx_ctx_set_log_fn to
+ * register a callback that takes a fully-formed string instead
+ * of a va_list.  It is not possible to use both log_fn and
+ * log_string_fn, use of either will override the other.
+ *
+ **/
+MCRX_EXPORT void mcrx_ctx_set_log_string_fn(
+    struct mcrx_ctx *ctx,
+    void (*string_log_fn)(
+      struct mcrx_ctx *ctx,
+      int priority,
+      const char *file,
+      int line,
+      const char *fn,
+      const char *str)) {
+  if (!ctx) {
+    info(ctx, "mcrx_ctx_set_log_string_fn called with no ctx\n");
+    return;
+  }
+
+  void (*old_string_log_fn)(struct mcrx_ctx *ctx, int priority,
+    const char *file, int line, const char *fn,
+    const char *str);
+  old_string_log_fn = ctx->string_log_fn;
+  if (string_log_fn == NULL) {
+    ctx->log_fn = log_stderr;
+    ctx->string_log_fn = NULL;
+  } else {
+    ctx->log_fn = log_string_cb;
+    ctx->string_log_fn = string_log_fn;
+  }
+  info(ctx,
+      "custom logging function %016"PRIxPTR
+      " registered (replaced %016"PRIxPTR")\n",
+      (uintptr_t)string_log_fn, (uintptr_t)old_string_log_fn);
+}
+
+/**
+ * mcrx_cts_log_msg:
+ * @ctx: mcrx library context
+ * @prio: log level
+ * @file: filename to report (usually __FILE__)
+ * @line: line number to report (usually __LINE__)
+ * @fn: function to report (usually __function__)
+ * @msg: message to log
+ *
+ * This feeds a message into the logging system, as if the
+ * libmcrx library generated an error or warning message.
+ */
+MCRX_EXPORT void mcrx_ctx_log_msg(
+    struct mcrx_ctx *ctx,
+    enum mcrx_log_priority prio,
+    const char* file,
+    int line,
+    const char* fn,
+    const char* msg) {
+  if (!ctx) {
+    err(ctx, "no ctx for log_msg(%d,%s:%d/%s): %s", (int)prio,
+        file, line, fn, msg);
+    return;
+  }
+  if (!ctx->log_fn) {
+    err(ctx, "no log_fn for log_msg(%d,%s:%d/%s): %s", (int)prio,
+        file, line, fn, msg);
+    return;
+  }
+  switch (prio) {
+    case MCRX_LOGLEVEL_DEBUG:
+    case MCRX_LOGLEVEL_INFO:
+    case MCRX_LOGLEVEL_WARNING:
+    case MCRX_LOGLEVEL_ERROR:
+      mcrx_log(ctx, prio, file, line, fn, "%s", msg);
+      break;
+    default:
+      err(ctx, "bad priority for log_msg(%d,%s:%d/%s): %s", (int)prio,
+          file, line, fn, msg);
+      break;
+  }
+}
+
+/**
+ * mcrx_ctx_get_userdata:
+ * @ctx: mcrx library context
+ *
+ * Retrieve stored data pointer from library context. This might be useful
+ * to access from callbacks like a custom logging function.
+ *
+ * Returns: stored userdata
+ **/
+MCRX_EXPORT intptr_t mcrx_ctx_get_userdata(
+    struct mcrx_ctx *ctx) {
+  if (ctx == NULL) {
+    return 0;
+  }
+
+  return ctx->userdata;
+}
+
+/**
+ * mcrx_ctx_set_userdata:
+ * @ctx: mcrx library context
+ * @userdata: data pointer
+ *
+ * Store custom @userdata in the library context.
+ **/
+MCRX_EXPORT void mcrx_ctx_set_userdata(
+    struct mcrx_ctx *ctx,
+    intptr_t userdata) {
+  if (ctx == NULL) {
+    return;
+  }
+
+  ctx->userdata = userdata;
+}
+
+/**
+ * mcrx_set_recive_socket_handlers:
+ * @ctx: mcrx library context
+ * @add_socket_cb: callback when a socket is added
+ * @remove_socket_cb: callback when a socket is removed
+ *
+ * This can be used to integrate with event loops that do not
+ * play will with making a blocking call in a dedicated thread to
+ * receive the libmcrx packets.  This will expose the sockets to
+ * the calling program, so they can be used in select/epoll/kevent/etc.
+ * for receive events.  After a receive event on the libmcrx sockets
+ * reported by these callbacks, the do_receive function pointer
+ * provided by the add_socket_cb should be invoked with the handle
+ * parameter provided by the add_socket_cb and the fd.
+ *
+ * Applications that use this function cannot use
+ * mcrx_ctx_receive_packets with the same ctx, and instead must process
+ * socket receive events for this ctx with the given do_receive
+ * functions (which are non-blocking, and invoke the subscription
+ * packet receive callbacks).
+ */
+MCRX_EXPORT enum mcrx_error_code mcrx_ctx_set_receive_socket_handlers(
+    struct mcrx_ctx *ctx,
+    int (*add_socket_cb)(
+        struct mcrx_ctx*,
+        intptr_t handle,
+        int fd,
+        int (*do_receive)(intptr_t handle, int fd)),
+    int (*remove_socket_cb)(
+        struct mcrx_ctx*,
+        int fd)) {
+  if (ctx == NULL) {
+    return MCRX_ERR_NULLARG;
+  }
+
+  if (ctx->sock_handler_state == MCRX_SOCKHANDLER_BUILTIN) {
+    return MCRX_ERR_INCONSISTENT_HANDLER;
+  }
+
+  if (ctx->sock_handler_state == MCRX_SOCKHANDLER_EXTERNAL) {
+    if (add_socket_cb == NULL && remove_socket_cb == NULL) {
+      if (ctx->live_subs == 0) {
+        ctx->add_socket_cb = mcrx_prv_add_socket_cb;
+        ctx->remove_socket_cb = mcrx_prv_remove_socket_cb;
+        ctx->sock_handler_state = MCRX_SOCKHANDLER_UNCOMMITTED;
+        return MCRX_ERR_OK;
+      }
+      return MCRX_ERR_INCONSISTENT_HANDLER;
+    }
+    ctx->add_socket_cb = add_socket_cb;
+    ctx->remove_socket_cb = remove_socket_cb;
+    return MCRX_ERR_OK;
+  }
+
+  if (ctx->sock_handler_state == MCRX_SOCKHANDLER_UNCOMMITTED) {
+    if (ctx->live_subs != 0) {
+      err(ctx,
+          "internal error: ctx %p uncommitted sockhandler with live subs\n",
+          (void*)ctx);
+      return MCRX_ERR_INTERNAL_ERROR;
+    }
+    if (!add_socket_cb || !remove_socket_cb) {
+      err(ctx,
+          "ctx %p ignoring null socket handler registration\n", (void*)ctx);
+      return MCRX_ERR_NULLARG;
+    }
+    ctx->add_socket_cb = add_socket_cb;
+    ctx->remove_socket_cb = remove_socket_cb;
+    ctx->sock_handler_state = MCRX_SOCKHANDLER_EXTERNAL;
+    return MCRX_ERR_OK;
+  }
+
+  err(ctx, "internal error: ctx %p sockhandler unknown state\n", (void*)ctx);
+  return MCRX_ERR_INTERNAL_ERROR;
+}
+
+static int log_priority(
+    const char *priority) {
+  char *endptr;
+  int prio;
+
+  prio = strtol(priority, &endptr, 10);
+
+  if (endptr[0] == '\0' || isspace(endptr[0])) {
+    return prio;
+  }
+
+  if (strncmp(priority, "err", 3) == 0) {
+    return LOG_ERR;
+  }
+
+  if (strncmp(priority, "warn", 4) == 0) {
+    return LOG_WARNING;
+  }
+
+  if (strncmp(priority, "info", 4) == 0) {
+    return LOG_INFO;
+  }
+
+  if (strncmp(priority, "debug", 5) == 0) {
+    return LOG_DEBUG;
+  }
+
+  return 0;
+}
+
+/**
+ * mcrx_ctx_new:
+ * @ctxp: pointer to be filled with the new mcrx library context
+ *
+ * Create mcrx library context. This reads the mcrx configuration
+ * and fills in the default values.
+ *
+ * The initial refcount is 1, and needs to be decremented to
+ * release the resources of the mcrx library context.
+ *
+ * Returns: An error code.
+ **/
+MCRX_EXPORT enum mcrx_error_code mcrx_ctx_new(
+    struct mcrx_ctx **ctxp) {
+  const char *env;
+  struct mcrx_ctx *c;
+
+  c = calloc(1, sizeof(struct mcrx_ctx));
+  if (!c) {
+    return MCRX_ERR_NOMEM;
+  }
+
+  c->refcount = 1;
+  c->log_fn = log_stderr;
+  c->log_priority = LOG_ERR;
+
+  /* environment overwrites config */
+  env = getenv("MCRX_LOG");
+  if (env != NULL) {
+    int prio = log_priority(env);
+    if (prio == 0) {
+      err(c, "env MCRX_LOG=%s unconverted (try debug, info, warn, err)\n",
+          env);
+    }
+    mcrx_ctx_set_log_priority(c, prio);
+  }
+  LIST_INIT(&c->subs_head);
+  c->timeout_ms = 1000 + random() % 1000;
+  c->add_socket_cb = mcrx_prv_add_socket_cb;
+  c->remove_socket_cb = mcrx_prv_remove_socket_cb;
+  c->sock_handler_state = MCRX_SOCKHANDLER_UNCOMMITTED;
+  c->wait_fd = -1;
+
+  // info(c, "version %s context %p created\n", VERSION, (void *)c);
+  dbg(c, "log_priority=%d\n", c->log_priority);
+  *ctxp = c;
+  return MCRX_ERR_OK;
+}
+
+/**
+ * mcrx_ctx_ref:
+ * @ctx: mcrx library context
+ *
+ * Take a reference of the mcrx library context.
+ *
+ * Returns: the passed mcrx library context
+ **/
+MCRX_EXPORT struct mcrx_ctx *mcrx_ctx_ref(
+    struct mcrx_ctx *ctx) {
+  if (ctx == NULL) {
+    warn(ctx, "context %p increment attempted\n", (void *)ctx);
+    return NULL;
+  }
+
+  dbg(ctx, "context %p incremented\n", (void *)ctx);
+  ctx->refcount++;
+  return ctx;
+}
+
+/**
+ * mcrx_ctx_unref:
+ * @ctx: mcrx library context
+ *
+ * Drop a reference of the mcrx library context. If the refcount
+ * reaches zero, the resources of the context will be released.
+ *
+ * Returns: the passed mcrx library context, or NULL if released.
+ **/
+MCRX_EXPORT struct mcrx_ctx *mcrx_ctx_unref(
+    struct mcrx_ctx *ctx) {
+  if (ctx == NULL) {
+    warn(ctx, "context %p decrement attempted\n", (void *)ctx);
+    return NULL;
+  }
+
+  ctx->refcount--;
+  if (ctx->refcount > 0) {
+    dbg(ctx, "context %p decremented\n", (void *)ctx);
+    return ctx;
+  }
+
+  int nsubs = 0;
+  while (!LIST_EMPTY(&ctx->subs_head)) {
+    struct mcrx_subscription *sub;
+    sub = LIST_FIRST(&ctx->subs_head);
+    warn(ctx, "subscription %p still alive when deleting context %p\n",
+        (void*)sub, (void*)ctx);
+    if (sub->joined) {
+      mcrx_subscription_leave(sub);
+    }
+    sub->ctx = NULL;
+    LIST_REMOVE(sub, sub_entries);
+    nsubs += 1;
+  }
+  if (nsubs != 0) {
+    err(ctx, "%d subscriptions still alive when deleting context %p\n",
+        nsubs, (void*)ctx);
+  }
+
+  if (ctx->wait_fd != -1) {
+    err(ctx, "wait_fd still alive when deleting context %p\n", (void*)ctx);
+    close(ctx->wait_fd);
+    ctx->wait_fd = -1;
+  }
+
+  info(ctx, "context %p released\n", (void *)ctx);
+  free(ctx);
+  return NULL;
+}
+
+/**
+ * mcrx_ctx_get_log_priority:
+ * @ctx: mcrx library context
+ *
+ * Returns: the current logging priority
+ **/
+MCRX_EXPORT enum mcrx_log_priority mcrx_ctx_get_log_priority(
+    struct mcrx_ctx *ctx) {
+  if (ctx == NULL) {
+    return LOG_DEBUG;
+  }
+  return ctx->log_priority;
+}
+
+/**
+ * mcrx_ctx_set_log_priority:
+ * @ctx: mcrx library context
+ * @priority: the new logging priority
+ *
+ * Set the current logging priority. The value controls which messages
+ * are logged.
+ **/
+MCRX_EXPORT void mcrx_ctx_set_log_priority(
+    struct mcrx_ctx *ctx,
+    enum mcrx_log_priority priority) {
+  if (ctx == NULL) {
+    return;
+  }
+  ctx->log_priority = priority;
+}
+
+/**
+ * mcrx_subscription_ref:
+ * @sub: mcrx subscription handle
+ *
+ * Take a reference of the mcrx subscription handle.
+ *
+ * Returns: the passed mcrx subscription handle.
+ **/
+MCRX_EXPORT struct mcrx_subscription* mcrx_subscription_ref(
+    struct mcrx_subscription* sub) {
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  if (sub == NULL) {
+    warn(ctx, "subscription %p increment attempted\n", (void *)sub);
+    return NULL;
+  }
+
+  dbg(ctx, "subscription %p incremented\n", (void *)sub);
+  sub->refcount++;
+  return sub;
+}
+
+/**
+ * mcrx_subscription_unref:
+ * @sub: mcrx subscription handle
+ *
+ * Drop a reference of the mcrx subscription handle. If the refcount
+ * reaches zero, the resources of the handle will be released.
+ *
+ * Returns: the passed mcrx subscription handle (or null if released)
+ **/
+MCRX_EXPORT struct mcrx_subscription* mcrx_subscription_unref(
+    struct mcrx_subscription* sub) {
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  if (sub == NULL) {
+    warn(ctx, "null subscription %p unref attempted\n", (void *)sub);
+    return NULL;
+  }
+  if (ctx == NULL) {
+    warn(ctx, "detached subscription %p ctx NULL on unref\n", (void *)sub);
+  }
+
+  sub->refcount--;
+  if (sub->refcount > 0) {
+    dbg(ctx, "subscription %p decremented\n", (void *)sub);
+    return sub;
+  }
+
+  int npkts = 0;
+  while (!TAILQ_EMPTY(&sub->pkts_head)) {
+    struct mcrx_packet *pkt;
+    pkt = TAILQ_FIRST(&sub->pkts_head);
+    pkt->sub = NULL;
+    TAILQ_REMOVE(&sub->pkts_head, pkt, pkt_entries);
+    npkts += 1;
+  }
+  if (npkts != 0) {
+    warn(ctx, "%d packets still alive when deleting subscription %p\n",
+        npkts, (void*)sub);
+  }
+
+  if (ctx) {
+    LIST_REMOVE(sub, sub_entries);
+  }
+  info(ctx, "subscription %p released\n", (void *)sub);
+
+  free(sub);
+  return NULL;
+}
+
+/**
+ * mcrx_subscription_get_userdata:
+ * @sub: mcrx subscription handle
+ *
+ * Retrieve stored data pointer from subscription handle. This might be useful
+ * to access from callbacks like a custom logging function.
+ *
+ * Returns: stored userdata
+ **/
+MCRX_EXPORT intptr_t mcrx_subscription_get_userdata(
+    struct mcrx_subscription *sub) {
+  if (sub == NULL) {
+    return 0;
+  }
+
+  return sub->userdata;
+}
+
+/**
+ * mcrx_subscription_set_userdata:
+ * @sub: mcrx subscription handle
+ * @userdata: data pointer
+ *
+ * Store custom @userdata in the subscription handle.
+ **/
+MCRX_EXPORT void mcrx_subscription_set_userdata(
+    struct mcrx_subscription *sub,
+    intptr_t userdata) {
+  if (sub == NULL) {
+    return;
+  }
+
+  sub->userdata = userdata;
+}
+
+/**
+ * mcrx_subscription_get_ctx:
+ * @sub: mcrx subscription handle
+ *
+ * Retrieve the mcrx library context for the subscription handle.
+ * Note: this DOES NOT increase the ctx ref count, so increase it
+ * with mcrx_ctx_ref if you are possibly holding it beyond the
+ * subscription lifetime.
+ *
+ * Returns: mcrx library context that owns the subscription
+ **/
+MCRX_EXPORT struct mcrx_ctx* mcrx_subscription_get_ctx(
+    struct mcrx_subscription* sub) {
+  if (sub == NULL) {
+    return NULL;
+  }
+
+  return sub->ctx;
+}
+
+/**
+ * mcrx_subscription_override_ifname:
+ * @sub: mcrx subscription handle
+ * @ifname: name of interface on which to join
+ *
+ * Ordinarily, the subscription will join on the interface with the
+ * route toward the source IP, but this can be used to override the
+ * interface with a user-provided name.  The provided ifname must
+ * remain a valid pointer until the subscription is released or until
+ * overridden with a different ifname, and must be a 0-terminated string.
+ * This takes effect on the join, so leave/override/join can change
+ * interfaces.
+ **/
+MCRX_EXPORT void mcrx_subscription_override_ifname(
+    struct mcrx_subscription* sub,
+    const char* ifname) {
+  if (sub == NULL) {
+    return;
+  }
+
+  sub->override_ifname = ifname;
+}
+
+static int default_receive_cb(
+    struct mcrx_packet* pkt) {
+  struct mcrx_subscription* sub = mcrx_packet_get_subscription(pkt);
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  int len = mcrx_packet_get_contents(pkt, NULL);
+  warn(ctx, "sub %p no receive callback set for pkt %p len %d\n", (void*)sub,
+      (void*)pkt, len);
+  return MCRX_RECEIVE_CONTINUE;
+}
+
+/**
+ * mcrx_subscription_new:
+ * @ctx: mcrx library context
+ * @config: subscription config
+ * @subp: pointer to be filled with the new subscription handle
+ *
+ * Create a new subscription handle from the config parameters.
+ *
+ * Returns: error code
+ **/
+MCRX_EXPORT enum mcrx_error_code mcrx_subscription_new(
+    struct mcrx_ctx* ctx,
+    const struct mcrx_subscription_config* config,
+    struct mcrx_subscription** subp) {
+  if (ctx == NULL || config == NULL || subp == NULL) {
+    err(ctx, "invalid input: ctx=%p, config=%p, subp=%p\n",
+        (void*)ctx, (void*)config, (void*)subp);
+    return MCRX_ERR_NULLARG;
+  }
+
+  if (config->magic != MCRX_SUBSCRIPTION_CONFIG_INIT_MAGIC) {
+    warn(ctx, "config should be initialized with MCRX_SUBSCRIPTION_INIT\n");
+  }
+  struct mcrx_subscription* sub;
+  sub = calloc(1, sizeof(struct mcrx_subscription));
+  if (!sub) {
+    return MCRX_ERR_NOMEM;
+  }
+
+  sub->ctx = ctx;
+  sub->refcount = 1;
+  sub->receive_cb = default_receive_cb;
+  sub->sock_fd = -1;
+
+  // default assume 1500 ethernet, minus:
+  // ip  (20 v4 or 40 v6, according to amt)
+  // udp (8)
+  // amt (2)
+  // ip  (20 v4 or 40 v6, according to sub)
+  // udp (8)
+  // 118 v6 sub or 98 v4 sub
+  sub->max_payload_size = 1382;
+  memcpy(&sub->input, config, sizeof(*config));
+
+  TAILQ_INIT(&sub->pkts_head);
+  LIST_INSERT_HEAD(&ctx->subs_head, sub, sub_entries);
+  info(ctx, "subscription %p created\n", (void *)sub);
+  *subp = sub;
+  return MCRX_ERR_OK;
+}
+
+void mcrx_subscription_set_max_payload(
+    struct mcrx_subscription* sub,
+    uint16_t payload_size) {
+  sub->max_payload_size = payload_size;
+}
+
+/**
+ * mcrx_subscription_set_receive_cb:
+ * @sub: mcrx subscription handle
+ * @receive_cb: receiver callback function
+ *
+ * Join the (S,G) and pass to user packets received on the given port.
+ * receive_cb should return an enum mcrx_receive_cb_continuation value.
+ *
+ * Returns: 0 on success -1 and set errno on failure
+ **/
+MCRX_EXPORT void mcrx_subscription_set_receive_cb(
+    struct mcrx_subscription* sub,
+    int (*receive_cb)(
+      struct mcrx_packet* packet)) {
+  if (!receive_cb) {
+    sub->receive_cb = default_receive_cb;
+  } else {
+    sub->receive_cb = receive_cb;
+  }
+}
+
+/**
+ * mcrx_subscription_join:
+ * @sub: mcrx subscription handle
+ * @receive_cb: receiver callback function
+ *
+ * Join the (S,G) and pass to user packets received on the given port.
+ *
+ * Returns: error code
+ **/
+MCRX_EXPORT enum mcrx_error_code mcrx_subscription_join(
+    struct mcrx_subscription* sub) {
+  enum mcrx_error_code err = mcrx_subscription_native_join(sub);
+  if (err == MCRX_ERR_OK) {
+    struct mcrx_ctx* ctx = (struct mcrx_ctx*)mcrx_subscription_get_ctx(sub);
+    if (ctx) {
+      ctx->live_subs++;
+    }
+  }
+  return err;
+}
+
+/**
+ * mcrx_subscription_leave:
+ * @sub: mcrx subscription handle
+ *
+ * Stop receiving and leave the subscription's (S,G).
+ *
+ * Returns: error code
+ **/
+MCRX_EXPORT enum mcrx_error_code mcrx_subscription_leave(
+    struct mcrx_subscription* sub) {
+  enum mcrx_error_code err = mcrx_subscription_native_leave(sub);
+  if (err == MCRX_ERR_OK) {
+    struct mcrx_ctx* ctx = (struct mcrx_ctx*)mcrx_subscription_get_ctx(sub);
+    if (ctx) {
+      ctx->live_subs--;
+    }
+  }
+  return err;
+}
+
+/**
+ * mcrx_packet_ref:
+ * @pkt: mcrx packet handle
+ *
+ * Take a reference of the mcrx packet handle.
+ *
+ * Returns: the passed mcrx packet handle.
+ **/
+MCRX_EXPORT struct mcrx_packet* mcrx_packet_ref(
+    struct mcrx_packet* pkt) {
+  struct mcrx_subscription* sub = mcrx_packet_get_subscription(pkt);
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  if (pkt == NULL) {
+    warn(ctx, "packet %p increment attempted\n", (void *)pkt);
+    return NULL;
+  }
+
+  dbg(ctx, "packet %p incremented\n", (void *)pkt);
+  pkt->refcount++;
+  return pkt;
+}
+
+/**
+ * mcrx_packet_unref:
+ * @pkt: mcrx packet handle
+ *
+ * Drop a reference of the mcrx packet handle. If the refcount
+ * reaches zero, the resources of the handle will be released.
+ *
+ * Returns: the passed mcrx packet handle (or null if released)
+ **/
+MCRX_EXPORT struct mcrx_packet* mcrx_packet_unref(
+    struct mcrx_packet* pkt) {
+  struct mcrx_subscription* sub = mcrx_packet_get_subscription(pkt);
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  if (pkt == NULL) {
+    warn(ctx, "packet %p decrement attempted\n", (void *)pkt);
+    return NULL;
+  }
+
+  pkt->refcount--;
+  if (pkt->refcount > 0) {
+    dbg(ctx, "packet %p decremented\n", (void *)pkt);
+    return pkt;
+  }
+
+  if (sub == NULL) {
+    warn(ctx, "packet %p sub NULL when released\n", (void *)pkt);
+  } else {
+    TAILQ_REMOVE(&sub->pkts_head, pkt, pkt_entries);
+  }
+
+  dbg(ctx, "packet %p released\n", (void *)pkt);
+  free(pkt);
+  return NULL;
+}
+
+/**
+ * mcrx_packet_get_userdata:
+ * @pkt: mcrx packet handle
+ *
+ * Retrieve stored data pointer from packet handle. This might be useful
+ * to access from callbacks like a custom logging function.
+ *
+ * Returns: stored userdata
+ **/
+MCRX_EXPORT intptr_t mcrx_packet_get_userdata(
+    struct mcrx_packet* pkt) {
+  if (pkt == NULL) {
+    return 0;
+  }
+
+  return pkt->userdata;
+}
+
+/**
+ * mcrx_packet_set_userdata:
+ * @pkt: mcrx packet handle
+ * @userdata: data pointer
+ *
+ * Store custom @userdata in the packet handle.
+ **/
+MCRX_EXPORT void mcrx_packet_set_userdata(
+    struct mcrx_packet* pkt,
+    intptr_t userdata) {
+  if (pkt == NULL) {
+    return;
+  }
+
+  pkt->userdata = userdata;
+}
+
+/**
+ * mcrx_packet_get_subscription:
+ * @pkt: mcrx packet handle
+ *
+ * Retrieve the mcrx subscription handle for the packet handle.
+ * Note: this DOES NOT increase the subscription ref count, so increase it
+ * with mcrx_subscription_ref if you are possibly holding it beyond the
+ * packet lifetime.
+ *
+ * Returns: mcrx subscription handle that owns the packet
+ **/
+MCRX_EXPORT struct mcrx_subscription* mcrx_packet_get_subscription(
+    struct mcrx_packet* pkt) {
+  if (pkt == NULL) {
+    return NULL;
+  }
+
+  return pkt->sub;
+}
+
+/**
+ * mcrx_packet_get_contents:
+ * @pkt: mcrx packet handle
+ * @datap: pointer to be filled with a pointer to the packet data
+ *
+ * Retrieve the packet payload contents and length.
+ *
+ * Returns: the length of the data.
+ **/
+MCRX_EXPORT uint16_t mcrx_packet_get_contents(
+    struct mcrx_packet* pkt,
+    uint8_t** datap) {
+  if (pkt == NULL) {
+    if (datap != NULL) {
+      *datap = NULL;
+    }
+    return 0;
+  }
+
+  if (datap != NULL) {
+    *datap = &pkt->data[0];
+  }
+  return pkt->size;
+}
+
+/**
+ * mcrx_packet_get_remote_port:
+ * @pkt: mcrx packet handle
+ *
+ * Retrieve the source port.
+ *
+ * Returns: the source port of the packet in host byte order.
+ **/
+MCRX_EXPORT uint16_t mcrx_packet_get_remote_port(
+    struct mcrx_packet* pkt) {
+  if (pkt == NULL) {
+    return 0;
+  }
+
+  return pkt->remote_port;
+}
+
+/**
+ * mcrx_strerror:
+ * @err: enum mcrx_error_code
+ *
+ * Similar to strerror(2). For some cases from system call failures,
+ * errno will also be set and can additionally be used in strerror/perror
+ * for more information about the problem encountered.
+ */
+MCRX_EXPORT const char*
+mcrx_strerror(enum mcrx_error_code err) {
+  switch (err) {
+    case MCRX_ERR_OK:
+      return "mcrx: no error";
+    case MCRX_ERR_TIMEDOUT:
+      return "mcrx: timed out";
+    case MCRX_ERR_NOMEM:
+      return "mcrx: out of memory";
+    case MCRX_ERR_NULLARG:
+      return "mcrx: null argument passed";
+    case MCRX_ERR_NOSPACE:
+      return "mcrx: insufficient buffer space for ntop";
+    case MCRX_ERR_UNKNOWN_FAMILY:
+      return "mcrx: unknown address family";
+    case MCRX_ERR_UNSUPPORTED:
+      return "mcrx: unsupported operation";
+    case MCRX_ERR_ALREADY_JOINED:
+      return "mcrx: already joined";
+    case MCRX_ERR_ALREADY_NOTJOINED:
+      return "mcrx: already not joined";
+    case MCRX_ERR_INTERNAL_ERROR:
+      return "mcrx: internal library error";
+    case MCRX_ERR_CALLBACK_FAILED:
+      return "mcrx: callback failed";
+    case MCRX_ERR_NOTHING_JOINED:
+      return "mcrx: nothing joined";
+    case MCRX_ERR_INCONSISTENT_HANDLER:
+      return "mcrx: socket handlers not consistent with packet receive path";
+    case MCRX_ERR_SYSCALL_BIND:
+      return "mcrx: system error during bind()";
+    case MCRX_ERR_SYSCALL_CLOSE:
+      return "mcrx: system error during close()";
+    case MCRX_ERR_SYSCALL_CONNECT:
+      return "mcrx: system error during connect()";
+    case MCRX_ERR_SYSCALL_FCNTL:
+      return "mcrx: system error during fcntl()";
+    case MCRX_ERR_SYSCALL_GETSOCKNAME:
+      return "mcrx: system error during getsockname()";
+    case MCRX_ERR_SYSCALL_GETIFADDRS:
+      return "mcrx: system error during getifaddrs()";
+    case MCRX_ERR_SYSCALL_NTOP:
+      return "mcrx: system error during ntop()";
+    case MCRX_ERR_SYSCALL_RECVMSG:
+      return "mcrx: system error during recvmsg()";
+    case MCRX_ERR_SYSCALL_SOCKET:
+      return "mcrx: system error during socket()";
+    case MCRX_ERR_SYSCALL_SETSOCKOPT:
+      return "mcrx: system error during setsockopt()";
+    case MCRX_ERR_SYSCALL_SETSOURCEFILTER:
+      return "mcrx: system error during setsourcefilter()";
+    case MCRX_ERR_SYSCALL_EPOLLCREATE:
+      return "mcrx: system error during epollcreate()";
+    case MCRX_ERR_SYSCALL_EPOLLADD:
+      return "mcrx: system error during epolladd()";
+    case MCRX_ERR_SYSCALL_EPOLLDEL:
+      return "mcrx: system error during epolldel()";
+    case MCRX_ERR_SYSCALL_EPOLLWAIT:
+      return "mcrx: system error during epollwait()";
+    case MCRX_ERR_SYSCALL_KEVENT:
+      return "mcrx: system error during kevent()";
+    case MCRX_ERR_SYSCALL_KQUEUE:
+      return "mcrx: system error during kqueue()";
+  }
+  return "mcrx_strerror: unknown error code";
+}
+
+/**
+ * mcrx_is_system_error:
+ * @err: enum mcrx_error_code
+ *
+ * returns 1 if calling strerror(errno) can be expected to give
+ * additional useful information about the underlying system problem
+ * encountered when mcrx produced this error code, or 0 otherwise.
+ */
+MCRX_EXPORT int
+mcrx_is_system_error(enum mcrx_error_code err) {
+  return err >= MCRX_ERR_SYSCALL_BIND;
+}
+
diff --git a/third_party/libmcrx/src/libmcrx.pc.in b/third_party/libmcrx/src/libmcrx.pc.in
new file mode 100644
index 000000000000..f98ae346e938
--- /dev/null
+++ b/third_party/libmcrx/src/libmcrx.pc.in
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libmcrx
+Description: multicast receiving library
+URL: http://www.jakeholland.net/mcrx/dist/libmcrx-@VERSION@.tar.xz
+Version: @VERSION@
+Libs: -L${libdir} -lmcrx
+Libs.private:
+Cflags: -I${includedir}
diff --git a/third_party/libmcrx/src/libmcrx.sym b/third_party/libmcrx/src/libmcrx.sym
new file mode 100644
index 000000000000..809d4728f13c
--- /dev/null
+++ b/third_party/libmcrx/src/libmcrx.sym
@@ -0,0 +1,33 @@
+LIBMCRX_1 {
+global:
+        mcrx_ctx_get_userdata;
+        mcrx_ctx_set_userdata;
+        mcrx_ctx_new;
+        mcrx_ctx_ref;
+        mcrx_ctx_unref;
+        mcrx_ctx_set_log_fn;
+        mcrx_ctx_get_log_priority;
+        mcrx_ctx_set_log_priority;
+        mcrx_ctx_receive_packets;
+        mcrx_subscription_ref;
+        mcrx_subscription_unref;
+        mcrx_subscription_get_userdata;
+        mcrx_subscription_set_userdata;
+        mcrx_subscription_get_ctx;
+        mcrx_subscription_new;
+        mcrx_subscription_set_receive_cb;
+        mcrx_subscription_join;
+        mcrx_packet_ref;
+        mcrx_packet_unref;
+        mcrx_packet_get_userdata;
+        mcrx_packet_set_userdata;
+        mcrx_packet_get_subscription;
+        mcrx_packet_get_contents;
+        mcrx_ctx_set_wait_ms;
+        mcrx_subscription_leave;
+        mcrx_subscription_config_pton;
+        mcrx_subscription_ntop;
+        mcrx_ctx_receive_packets;
+local:
+        *;
+} LIBMCRX_1;
diff --git a/third_party/libmcrx/src/native.c b/third_party/libmcrx/src/native.c
new file mode 100644
index 000000000000..408274fec1c5
--- /dev/null
+++ b/third_party/libmcrx/src/native.c
@@ -0,0 +1,1364 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <ifaddrs.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#include <mcrx/libmcrx.h>
+#include "./libmcrx-private.h"
+
+/*
+ * platform macros:
+ * https://stackoverflow.com/questions/142508/how-do-i-check-os-with-a-preprocessor-directive
+ * https://sourceforge.net/p/predef/wiki/OperatingSystems/
+ */
+
+#ifdef __linux__
+#define USE_JOIN_STRATEGY_FILTER 0
+#define USE_JOIN_STRATEGY_ADDMEM 0
+#define USE_JOIN_STRATEGY_MCAST_JOIN 1
+#elif defined(__APPLE__)
+#define USE_JOIN_STRATEGY_FILTER 0
+#define USE_JOIN_STRATEGY_ADDMEM 1
+#define BROKEN_ADD_MEMBERSHIP_V6
+#define USE_JOIN_STRATEGY_MCAST_JOIN 0
+#else
+suffering_and_woe_join_method_undefined;
+#endif
+
+void wrap_strerr(int eno, char* buf, int len) {
+#ifdef __linux__
+  const char* ret = strerror_r(eno, buf, len);
+  if (ret != buf) {
+    strncpy(buf, ret, len);
+  }
+#elif defined(__APPLE__)
+  int rc = strerror_r(eno, buf, len);
+  if (rc != 0) {
+    snprintf(buf, len, "strerror_r error on (%d)", eno);
+    buf[len-1] = 0;
+  }
+#else
+  // strerror_r is kind of a debacle, and wouldn't switch to
+  // the XSI version with a -D_BSD_SOURCE in linux as advertised:
+  // http://man7.org/linux/man-pages/man3/strerror_r.3.html
+  // http://man7.org/linux/man-pages/man7/feature_test_macros.7.html
+  // --jake 2019-06-17
+  UNUSED(eno);
+  UNUSED(buf);
+  UNUSED(len);
+  suffering_and_woe_strerror_unselected;
+#endif
+}
+
+MCRX_EXPORT void mcrx_ctx_set_wait_ms(
+    struct mcrx_ctx *ctx,
+    int timeout_ms) {
+  ctx->timeout_ms = timeout_ms;
+}
+
+// I isolated the handling of various system calls in case I
+// need to refine the error handling better.  At this point,
+// the only goal is to have enough breadcrumbs to debug it if
+// these errors get hit, but it's possible more refined error
+// reporting would become worthwhile.
+static enum mcrx_error_code handle_ntop_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "inet_ntop error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_NTOP;
+}
+#define handle_ntop_error(ctx) handle_ntop_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_socket_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "socket() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_SOCKET;
+}
+#define handle_socket_error(ctx) handle_socket_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_connect_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "connect() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_CONNECT;
+}
+#define handle_connect_error(ctx) handle_connect_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_getsockname_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "getsockname() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_GETSOCKNAME;
+}
+#define handle_getsockname_error(ctx) handle_getsockname_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+enum mcrx_error_code handle_close_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "close() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_CLOSE;
+}
+
+static enum mcrx_error_code handle_getifaddrs_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "getifaddrs() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_GETIFADDRS;
+}
+#define handle_getifaddrs_error(ctx) handle_getifaddrs_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_recvmsg_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "recvmsg() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_RECVMSG;
+}
+#define handle_recvmsg_error(ctx) handle_recvmsg_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_setsockopt_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "setsockopt() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_SETSOCKOPT;
+}
+#define handle_setsockopt_error(ctx) handle_setsockopt_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_bind_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "bind() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_BIND;
+}
+#define handle_bind_error(ctx) handle_bind_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+#if USE_JOIN_STRATEGY_FILTER
+static enum mcrx_error_code handle_setsourcefilter_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "setsourcefilter() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_SETSOURCEFILTER;
+}
+#define handle_setsourcefilter_error(ctx) handle_setsourcefilter_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+#endif
+
+static enum mcrx_error_code handle_fcntl_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "fcntl() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_FCNTL;
+}
+#define handle_fcntl_error(ctx) handle_fcntl_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+MCRX_EXPORT enum mcrx_error_code mcrx_subscription_ntop(
+    struct mcrx_subscription* sub,
+    char* buf,
+    int buflen) {
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  int af;
+  const void *src, *grp;
+  char src_buf[INET6_ADDRSTRLEN];
+  char grp_buf[INET6_ADDRSTRLEN];
+  switch (sub->input.addr_type) {
+    case MCRX_ADDR_TYPE_V4:
+      af = AF_INET;
+      src = &sub->input.addrs.v4.source;
+      grp = &sub->input.addrs.v4.group;
+      break;
+    case MCRX_ADDR_TYPE_V6:
+      af = AF_INET6;
+      src = &sub->input.addrs.v6.source;
+      grp = &sub->input.addrs.v6.group;
+      break;
+    default:
+      err(ctx, "unknown subscription addr_type %d (neither %d nor %d)\n",
+          (int)sub->input.addr_type, (int)MCRX_ADDR_TYPE_V4,
+          (int)MCRX_ADDR_TYPE_V6);
+      return MCRX_ERR_UNKNOWN_FAMILY;
+  }
+  const char* src_str = inet_ntop(af, src, src_buf, sizeof(src_buf));
+  if (src_str == NULL) {
+    return handle_ntop_error(ctx);
+  }
+  const char* grp_str = inet_ntop(af, grp, grp_buf, sizeof(grp_buf));
+  if (grp_str == NULL) {
+    return handle_ntop_error(ctx);
+  }
+  int wrotelen = snprintf(buf, buflen, "%s->%s(%u)",
+      src_str, grp_str, sub->input.port);
+  if (wrotelen >= buflen) {
+    err(ctx, "insufficient subscription_ntop space %d (needed %d)\n",
+        buflen, wrotelen);
+    buf[buflen-1] = 0;
+    return MCRX_ERR_NOSPACE;
+  }
+  return MCRX_ERR_OK;
+}
+
+// int
+// route_main(int argc, char **argv);
+
+static enum mcrx_error_code sockaddr_ntop(
+    struct mcrx_ctx* ctx,
+    const struct sockaddr* sa,
+    char* sbuf,
+    int buflen) {
+  const void* addr;
+  switch (sa->sa_family) {
+    case AF_INET: {
+      const struct sockaddr_in* sp = (const struct sockaddr_in*)sa;
+      addr = &sp->sin_addr;
+      const char* ret = inet_ntop(sa->sa_family, addr, sbuf, buflen);
+      if (ret == NULL) {
+        return handle_ntop_error(ctx);
+      }
+      return MCRX_ERR_OK;
+    }
+    case AF_INET6: {
+      const struct sockaddr_in6* sp = (const struct sockaddr_in6*)sa;
+      addr = &sp->sin6_addr;
+      const char* ret = inet_ntop(sa->sa_family, addr, sbuf, buflen);
+      if (ret == NULL) {
+        return handle_ntop_error(ctx);
+      }
+      return MCRX_ERR_OK;
+    }
+    default:
+      dbg(ctx, "sockaddr_ntop bad family %d (not %d or %d)\n",
+          sa->sa_family, AF_INET, AF_INET6);
+      return MCRX_ERR_UNKNOWN_FAMILY;
+  }
+}
+
+static enum mcrx_error_code mcrx_find_interface(
+    struct mcrx_subscription* sub,
+    int* if_indexp,
+    void* if_addr) {
+  /*
+   * It's unreasonably difficult to extract the correct interface
+   * addr or interface index (one of which is needed, depending
+   * on whether we're using IP_ADD_SOURCE_MEMBERSHIP or a different
+   * api for joining.
+   *
+   * getsockopt(SIOCGIFINDEX) and SIOCGIFADDR on a udp socket
+   * after connect are adequate for linux, but for mac those are
+   * unavailable, so instead we getsockname and walk the ifaddrs
+   * looking for a match.  Either way, we pick the interface that
+   * would be used if opening a socket to the source, as a first
+   * pass.
+   *
+   * really could use an api that gives me the list of viable
+   * interface indexes and/or addresses...
+   * -jake 2019-06-18
+   */
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+
+#if 0
+  // if (RTA_DST == 0) if getaddr(RTAX_DST), nrflags |= F_ISHOST
+  // RTM_RESOLVE messages give "Invalid argument" errno on mac.
+  // RTM_GET messages give "Invalid argument" errno on mac.
+  *if_indexp = 3;
+  inet_pton(AF_INET, "192.168.56.1", if_addr);
+
+  int addr_len;
+  struct {
+    struct rt_msghdr rt_msg;
+    struct sockaddr_storage dst_addr;
+  } rt_msg_buf;
+  memset(&rt_msg_buf, 0, sizeof(rt_msg_buf));
+  void* dst_addrp = &rt_msg_buf.dst_addr;
+  int family = AF_UNSPEC;
+  switch (sub->input.addr_type) {
+    case MCRX_ADDR_TYPE_V4:
+      family = AF_INET;
+      ((struct sockaddr_in*) dst_addrp)->sin_family = AF_INET;
+      ((struct sockaddr_in*) dst_addrp)->sin_addr =
+       sub->input.addrs.v4.source;
+      addr_len = sizeof(struct sockaddr_in);
+      break;
+    case MCRX_ADDR_TYPE_V6:
+      family = AF_INET6;
+      ((struct sockaddr_in6*) dst_addrp)->sin6_family = AF_INET6;
+      ((struct sockaddr_in6*) dst_addrp)->sin6_addr =
+       sub->input.addrs.v6.source;
+      addr_len = sizeof(struct sockaddr_in6);
+      break;
+    default:
+      err(ctx, "sub %p internal error: unknown type\n", (void*)sub);
+      return -EINVAL;
+  }
+
+  int nlfd = socket(AF_ROUTE, SOCK_RAW, family);
+  if (nlfd < 0) {
+    char buf[1024];
+    wrap_strerr(errno, buf, sizeof(buf));
+    err(ctx, "sub %p failed to open netlink socket: %s\n", (void*)sub, buf);
+    return -EINVAL;
+  }
+  int seq = 1;
+  int pid = getpid();
+  struct rt_msghdr *rt_msg = &rt_msg_buf.rt_msg;
+  rt_msg->rtm_msglen = sizeof(*rt_msg) + addr_len;
+  rt_msg->rtm_version = RTM_VERSION;
+  rt_msg->rtm_addrs = RTA_DST | RTA_IFP;
+  rt_msg->rtm_flags = RTF_HOST | RTF_UP;
+  rt_msg->rtm_type = RTM_GET;
+  rt_msg->rtm_seq = seq;
+  rt_msg->rtm_pid = pid;
+
+  int rc;
+  rc = write(nlfd, &rt_msg, rt_msg->rtm_msglen);
+  if (rc != rt_msg->rtm_msglen) {
+    char buf[1024];
+    wrap_strerr(errno, buf, sizeof(buf));
+    err(ctx, "sub %p write=%d (not %d) for rt_msg to netlink socket: %s\n",
+        (void*)sub, rc, rt_msg->rtm_msglen, buf);
+    close(nlfd);
+    return -EINVAL;
+  }
+
+  int msg_idx = 0;
+  do {
+    msg_idx += 1;
+    rc = read(nlfd, &rt_msg_buf, sizeof(rt_msg_buf));
+    if (rc < (int)sizeof(struct rt_msghdr)) {
+      char buf[1024];
+      wrap_strerr(errno, buf, sizeof(buf));
+      err(ctx, "sub %p read=%d (header %d) for addr to netlink socket: %s\n",
+          (void*)sub, rc, (int)sizeof(struct rt_msghdr), buf);
+      close(nlfd);
+      return -EINVAL;
+    }
+    if (rc < rt_msg->rtm_msglen) {
+      char buf[1024];
+      wrap_strerr(errno, buf, sizeof(buf));
+      err(ctx, "sub %p read=%d (len %d) for addr to netlink socket: %s\n",
+          (void*)sub, rc, (int)sizeof(struct rt_msghdr), buf);
+      close(nlfd);
+      return -EINVAL;
+    }
+    int skip = 0;
+    if (rt_msg->rtm_type != RTM_GET) {
+      info(ctx, "%d: skipping non-resolve\n", msg_idx);
+      skip = 1;
+    }
+    if (rt_msg->rtm_seq != seq) {
+      info(ctx, "%d: skipping seq\n", msg_idx);
+      skip = 1;
+    }
+    if (rt_msg->rtm_pid != pid) {
+      info(ctx, "%d: skipping pid\n", msg_idx);
+      skip = 1;
+    }
+    if (!skip) {
+      break;
+    }
+  } while (1);
+
+  struct sockaddr* sa = (struct sockaddr*)dst_addrp;
+  info(ctx, "family: %d (v4=%d, v6=%d)\n", sa->sa_family, AF_INET, AF_INET6);
+#endif
+
+#if 0
+  // tried copying the freebsd /sbin/route/route.c and making it compile,
+  // but it also failed with: "Address family not supported by protocol family"
+  // in netlink write.
+  const char* rargv[4] = {"blah", "get", "192.168.56.2", 0};
+  int rargc = sizeof(rargv) / sizeof(rargv[0]) - 1;
+  route_main(rargc, rargv);
+#endif
+
+  int rc;
+  int addr_len = 0;
+  void* addr_p = 0;
+  int family = AF_UNSPEC;
+
+  struct sockaddr_storage ss;
+  struct sockaddr* sp = (struct sockaddr*)&ss;
+  int sa_len = 0;
+  int addr_offset = 0;
+  switch (sub->input.addr_type) {
+    case MCRX_ADDR_TYPE_V4: {
+      family = AF_INET;
+      struct sockaddr_in* sp4 = (struct sockaddr_in*)sp;
+      sp4->sin_family = AF_INET;
+      sp4->sin_addr = sub->input.addrs.v4.source;
+      // NB: no packets are generated or received on this socket, so the
+      // port doesn't ever appear on the network.  But it still must be
+      // a user-space port, so the socket can be created.
+      sp4->sin_port = htons(5001);
+      sa_len = sizeof(struct sockaddr_in);
+      // ((struct sockaddr_in*)sp)->sin_len = sa_len;
+      addr_p = &sp4->sin_addr;
+      addr_offset = (((uint8_t*)addr_p)-((uint8_t*)sp));
+      addr_len = sizeof(sp4->sin_addr);
+      break;
+    }
+    case MCRX_ADDR_TYPE_V6: {
+      family = AF_INET6;
+      struct sockaddr_in6* sp6 = (struct sockaddr_in6*)sp;
+      sp6->sin6_family = AF_INET6;
+      sp6->sin6_addr = sub->input.addrs.v6.source;
+      // NB: no packets are generated or received on this socket, so the
+      // port doesn't ever appear on the network.  But it still must be
+      // a user-space port, so the socket can be created.
+      sp6->sin6_port = htons(5001);
+      sa_len = sizeof(struct sockaddr_in6);
+      // ((struct sockaddr_in6*)sp)->sin6_len = sa_len;
+      addr_p = &sp6->sin6_addr;
+      addr_offset = (((uint8_t*)addr_p)-((uint8_t*)sp));
+      addr_len = sizeof(sp6->sin6_addr);
+      break;
+    }
+    default:
+      err(ctx, "sub %p internal error: unknown address family\n", (void*)sub);
+      return MCRX_ERR_UNKNOWN_FAMILY;
+  }
+
+  if (!sub->override_ifname) {
+    // extract the local interface by connecting a udp socket to the
+    // source and checking its local address.
+    int check_sock = socket(family, SOCK_DGRAM, IPPROTO_UDP);
+    if (check_sock < 0) {
+      err(ctx, "sub %p socket() failed\n", (void*)sub);
+      return handle_socket_error(ctx);
+    }
+    info(ctx, "sub %p interface lookup socket created: %d\n",
+        (void*)sub, check_sock);
+
+    rc = connect(check_sock, sp, sa_len);
+    if (rc < 0) {
+      err(ctx, "sub %p connect() failed\n", (void*)sub);
+      return handle_connect_error(ctx);
+    }
+
+    socklen_t got_len = sizeof(ss);
+    rc = getsockname(check_sock, sp, &got_len);
+    if (rc < 0) {
+      enum mcrx_error_code ret = handle_getsockname_error(ctx);
+      int prev_errno = errno;
+      if (close(check_sock) < 0) {
+        handle_close_error(ctx);
+      }
+      errno = prev_errno;  // suppress close error, if present.
+      return ret;
+    }
+
+    if (got_len != (socklen_t)sa_len) {
+      err(ctx, "sub %p getsockname addrlen got %d not %d\n",
+          (void*)sub, got_len, sa_len);
+      if (close(check_sock) < 0) {
+        handle_close_error(ctx);
+      }
+      return MCRX_ERR_INTERNAL_ERROR;
+    }
+    rc = close(check_sock);
+    if (rc < 0) {
+      char buf[1024];
+      wrap_strerr(errno, buf, sizeof(buf));
+      // we ignore this error because sometimes we're handed fd=0, as the
+      // socket fd, which produces a close error on mac. --jake 2019-06-28
+      warn(ctx, "sub %p ignoring source-if socket close(%d) error: %s\n",
+          (void*)sub, check_sock, buf);
+    }
+
+    // now sp is the local address for a socket that could send to
+    // the source, so use that to find the interface index (and for
+    // ipv6, a link-local address, since the MLD packets MUST be from a
+    // link-local address, failing this the message is silently ignored
+    // by a linux next-hop, as required at the top of:
+    // https://tools.ietf.org/html/rfc3810#section-5
+
+    char addr_buf[INET6_ADDRSTRLEN];
+    const char* loc_addr_str = inet_ntop(family, addr_p, addr_buf,
+        sizeof(addr_buf));
+    if (!loc_addr_str) {
+      return handle_ntop_error(ctx);
+    }
+
+    info(ctx, "got local sockaddr: %s\n", loc_addr_str);
+  }
+
+  struct ifaddrs* all_addrs = 0;
+  rc = getifaddrs(&all_addrs);
+  if (rc < 0) {
+    return handle_getifaddrs_error(ctx);
+  }
+
+  struct ifaddrs* cur_ifa;
+  struct ifaddrs* match_ifa = NULL;
+  unsigned int matching_idx = 0;
+  for (cur_ifa = all_addrs; cur_ifa; cur_ifa = cur_ifa->ifa_next) {
+    if (cur_ifa->ifa_addr) {
+      if (cur_ifa->ifa_addr->sa_family == family) {
+        void* check_addr = (void*)(((uint8_t*)cur_ifa->ifa_addr)+addr_offset);
+        if (sub->override_ifname) {
+          rc = strcmp(sub->override_ifname, cur_ifa->ifa_name);
+        } else {
+          // in this case, addr_p (pointing inside the memory for ss/sp)
+          // got overwritten with the local socket address by getsockname
+          // after a udp "connect" to the source ip.
+          rc = memcmp(addr_p, check_addr, addr_len);
+        }
+        if (rc == 0) {
+          unsigned int idx = if_nametoindex(cur_ifa->ifa_name);
+          if (idx == 0) {
+            err(ctx, "failed if_nametoindex(%s)\n", cur_ifa->ifa_name);
+          } else {
+            if (!match_ifa || matching_idx != idx) {
+              if (!match_ifa) {
+                info(ctx, "found matching interface: %s(base)\n",
+                    cur_ifa->ifa_name);
+              } else {
+                warn(ctx,
+                  "found alternate matching interface(%s replaces %s)\n",
+                  match_ifa->ifa_name, cur_ifa->ifa_name);
+              }
+              match_ifa = cur_ifa;
+              matching_idx = idx;
+              if (if_indexp) {
+                *if_indexp = idx;
+              }
+            }
+          }
+        }
+      }
+    }
+
+    if (mcrx_ctx_get_log_priority(ctx) >= MCRX_LOGLEVEL_DEBUG) {
+      char ifa_buf[INET6_ADDRSTRLEN];
+      const char* ifa_s = "null_addr";
+      if (cur_ifa->ifa_addr) {
+        rc = sockaddr_ntop(ctx, cur_ifa->ifa_addr, ifa_buf, sizeof(ifa_buf));
+        if (rc == MCRX_ERR_UNKNOWN_FAMILY) {
+          ifa_s = "unknown addr type";
+        } else {
+          ifa_s = &ifa_buf[0];
+          if (rc != 0) {
+            snprintf(ifa_buf, sizeof(ifa_buf),
+                "failed_sockntop(af=%d, vs. %d/%d)\n",
+                cur_ifa->ifa_addr->sa_family, AF_INET, AF_INET6);
+          }
+        }
+      }
+      dbg(ctx, "   ifa %s: %s\n",
+          cur_ifa->ifa_name, ifa_s);
+    }
+  }
+  int found = 0;
+  if (match_ifa) {
+    if (!if_addr) {
+      found = 1;
+    } else {
+      switch (family) {
+        case AF_INET: {
+          void* check_addr =
+            (void*)(((uint8_t*)match_ifa->ifa_addr)+addr_offset);
+          memcpy(if_addr, check_addr, addr_len);
+          found = 1;
+          break;
+        }
+        case AF_INET6: {
+          // V6 has to use a link-local address; find one on the same interface
+          for (cur_ifa = all_addrs; cur_ifa; cur_ifa = cur_ifa->ifa_next) {
+            if (strcmp(cur_ifa->ifa_name, match_ifa->ifa_name) != 0) {
+              continue;
+            }
+            if (cur_ifa->ifa_addr && cur_ifa->ifa_addr->sa_family != family) {
+              continue;
+            }
+            struct sockaddr_in6* sa6 =
+              ((struct sockaddr_in6*)cur_ifa->ifa_addr);
+            if (IN6_IS_ADDR_LINKLOCAL(&sa6->sin6_addr)) {
+              memcpy(if_addr, &sa6->sin6_addr, addr_len);
+              found = 1;
+              break;
+            }
+          }
+          break;
+        }
+      }
+    }
+  }
+  freeifaddrs(all_addrs);
+
+  if (!found) {
+    err(ctx, "failed to find suitable local address\n");
+    return 1;
+  } else {
+    char addr_sbuf[INET6_ADDRSTRLEN];
+    char sub_sbuf[MCRX_SUB_STRLEN];
+    const char* addr_str = "(unrequested_addr)";
+    int idx = -1;
+    if (if_addr) {
+      addr_str = inet_ntop(family, if_addr, addr_sbuf, sizeof(addr_sbuf));
+      if (!addr_str) {
+        err(ctx, "internal error sub %p: inet_ntop failed with found addr\n",
+            (void*)sub);
+      }
+    }
+    if (if_indexp) {
+      idx = *if_indexp;
+    }
+    if (mcrx_subscription_ntop(sub, sub_sbuf, sizeof(sub_sbuf)) != 0) {
+      err(ctx, "internal error sub %p: subscription_ntop failed\n",
+          (void*)sub);
+      strncpy(&sub_sbuf[0], "(failed sub_ntop)\n", sizeof(sub_sbuf));
+    }
+    info(ctx, "sub %p if_addr=%s, if_idx=%d for %s\n", (void*)sub, addr_str,
+        idx, sub_sbuf);
+  }
+
+  return MCRX_ERR_OK;
+}
+
+/**
+ * native_receive:
+ *
+ * Receives all pending packets for a subscription, unless the receive
+ * callback requests an early stop or there's a socket error.
+ *
+ * Returns value from mcrx_receive_cb_continuation, or whatever
+ * receive_cb returned (which should be that, but unchecked here.)
+ */
+static int native_receive(
+    intptr_t sub_handle,
+    int fd) {
+  struct mcrx_subscription* sub = (struct mcrx_subscription*)sub_handle;
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  dbg(ctx, "receiving on %d\n", fd);
+
+  int rc;
+  // keep subscription and ctx alive through callbacks even if unrefd.
+  mcrx_ctx_ref(ctx);
+  mcrx_subscription_ref(sub);
+  do {
+    struct mcrx_packet *pkt = (struct mcrx_packet*)calloc(1,
+        sizeof(struct mcrx_packet)+sub->max_payload_size);
+    if (!pkt) {
+      err(ctx, "out of memory allocating packet\n");
+      mcrx_subscription_unref(sub);
+      mcrx_ctx_unref(ctx);
+      return MCRX_RECEIVE_STOP_CTX;
+    }
+
+    struct sockaddr_storage ss;
+    struct iovec iov;
+    bzero(&iov, sizeof(iov));
+    iov.iov_base = &pkt->data;
+    iov.iov_len = sub->max_payload_size;
+    struct msghdr hdr;
+    bzero(&hdr, sizeof(hdr));
+    hdr.msg_iov = &iov;
+    hdr.msg_iovlen = 1;
+    hdr.msg_name = &ss;
+    hdr.msg_namelen = sizeof(ss);
+
+    rc = recvmsg(fd, &hdr, MSG_TRUNC | MSG_DONTWAIT);
+    if (rc < 0) {
+      switch (errno) {
+        case EINTR:
+        case EAGAIN:
+        // case EWOULDBLOCK:  (duplicate case value, EAGAIN is the same)
+          free(pkt);
+          mcrx_subscription_unref(sub);
+          mcrx_ctx_unref(ctx);
+          return MCRX_RECEIVE_STOP_FD;
+        default:
+          free(pkt);
+          err(ctx, "sub %p recvmsg failed\n", (void*)sub);
+          mcrx_subscription_unref(sub);
+          mcrx_ctx_unref(ctx);
+          handle_recvmsg_error(ctx);
+          return MCRX_RECEIVE_STOP_CTX;
+      }
+    }
+    pkt->sub = sub;
+    pkt->refcount = 1;
+    pkt->userdata = sub->userdata;
+    if (rc > sub->max_payload_size) {
+      // expect hdr.flags & MSG_TRUNC here.
+      pkt->size = sub->max_payload_size;
+    } else {
+      pkt->size = rc;
+    }
+
+    switch (sub->input.addr_type) {
+      case MCRX_ADDR_TYPE_V4: {
+        struct sockaddr_in* sin = (struct sockaddr_in*)&ss;
+        pkt->remote_port = htons(sin->sin_port);
+        break;
+      }
+      case MCRX_ADDR_TYPE_V6: {
+        struct sockaddr_in6* sin6 = (struct sockaddr_in6*)&ss;
+        pkt->remote_port = htons(sin6->sin6_port);
+        break;
+      }
+      default:
+        err(ctx, "sub %p internal error: unknown family while receiving\n",
+            (void*)sub);
+        return MCRX_RECEIVE_STOP_CTX;
+    }
+
+    TAILQ_INSERT_TAIL(&sub->pkts_head, pkt, pkt_entries);
+
+    int rcb_ret = sub->receive_cb(pkt);
+    if (rcb_ret != MCRX_RECEIVE_CONTINUE) {
+      mcrx_subscription_unref(sub);
+      mcrx_ctx_unref(ctx);
+      return rcb_ret;
+    }
+  } while (1);
+
+  mcrx_subscription_unref(sub);
+  mcrx_ctx_unref(ctx);
+  return MCRX_ERR_OK;
+}
+
+enum mcrx_error_code mcrx_subscription_native_join(
+    struct mcrx_subscription* sub) {
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  if (sub == NULL || ctx == NULL) {
+    err(ctx, "NULL sub(%p) or ctx(%p)\n", (void*)sub, (void*)ctx);
+    return MCRX_ERR_NULLARG;
+  }
+
+  char desc[MCRX_SUB_STRLEN];
+  enum mcrx_error_code ret;
+  ret = mcrx_subscription_ntop(sub, desc, sizeof(desc));
+  if (ret != MCRX_ERR_OK) {
+    err(ctx, "sub %p description gen mcrx_subscription_ntop failed\n",
+        (void*)sub);
+    return ret;
+  }
+
+  if (sub->joined) {
+    err(ctx, "sub %p (%s) already joined\n", (void*)sub, desc);
+    return MCRX_ERR_ALREADY_JOINED;
+  }
+
+  int family;
+  if (sub->input.addr_type != MCRX_ADDR_TYPE_V4 &&
+      sub->input.addr_type != MCRX_ADDR_TYPE_V6) {
+      err(ctx, "sub %p (%s) address type not set\n", (void*)sub, desc);
+      return MCRX_ERR_UNKNOWN_FAMILY;
+  } else if (sub->input.addr_type == MCRX_ADDR_TYPE_V4) {
+    family = AF_INET;
+  } else {
+    family = AF_INET6;
+  }
+
+  int rc;
+  int sock_fd = socket(family, SOCK_DGRAM, IPPROTO_UDP);
+  if (sock_fd < 0) {
+    err(ctx, "sub %p (%s) listening socket failed\n", (void*)sub, desc);
+    return handle_socket_error(ctx);
+  }
+  if (sock_fd == 0) {
+    // fd=0 usually is stdin, but in some apps that close stdin or reassign it,
+    // socket can return 0, and it's a non-error.
+    // However, unfortunately, this causes a close(0) call later, and that
+    // fails with strerror providing "Bad file descriptor".  It's not fully
+    // clear that all other functions work properly with a 0 fd.
+    // Therefore, insist on a nonzero socket by opening a new socket in the
+    // event of a 0 file descriptor. --jake 2019-06-24
+    int alt_fd = socket(family, SOCK_DGRAM, IPPROTO_UDP);
+    if (alt_fd < 0) {
+      err(ctx, "sub %p (%s) alt listening socket failed\n", (void*)sub, desc);
+      int prev_errno = errno;
+      ret = handle_socket_error(ctx);
+      if (close(sock_fd) < 0) {
+        handle_close_error(ctx);
+      }
+      errno = prev_errno;  // suppress close's errno
+      return ret;
+    }
+    rc = close(sock_fd);
+    if (rc < 0) {
+      char buf[1024];
+      wrap_strerr(errno, buf, sizeof(buf));
+      warn(ctx,
+          "sub %p (%s) ignoring socket=0 close fail (replaced with %d): %s\n",
+          (void*)sub, desc, alt_fd, buf);
+    }
+    if (alt_fd == 0) {
+      // our assumptions are violated here, we got another 0 value for
+      // fd while trying to insist on a nonzero fd, and a prior 0-valued
+      // fd was open.  Call it a socket failure.
+      err(ctx, "sub %p (%s) socket failed (re-zero after 0)\n",
+          (void*)sub, desc);
+      int prev_errno = errno;
+      ret = handle_socket_error(ctx);
+      if (close(alt_fd) < 0) {
+        handle_close_error(ctx);
+      }
+      errno = prev_errno;  // suppress close's errno
+      return ret;
+    }
+    sock_fd = alt_fd;
+  }
+  info(ctx, "sub %p (%s) socket created: %d\n", (void*)sub, desc, sock_fd);
+
+  int val;
+  int len;
+  val = true;
+  len = sizeof(val);
+  rc = setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &val, len);
+  if (rc < 0) {
+    err(ctx, "sub %p (%s) setsockopt(REUSEADDR) failed\n", (void*)sub,
+        desc);
+    int prev_errno = errno;
+    ret = handle_setsockopt_error(ctx);
+    if (close(sock_fd) < 0) {
+      handle_close_error(ctx);
+    }
+    errno = prev_errno;  // suppress close's errno
+    return ret;
+  }
+
+  /*
+   * All the multicast join functions need to specify an interface
+   * (most by index, some by address).
+   */
+  union {
+    struct in6_addr i6;
+    struct in_addr i4;
+  } if_addr;
+  void* if_addrp;
+  int if_idx = -1;
+  switch (sub->input.addr_type) {
+    case MCRX_ADDR_TYPE_V4:
+      if_addrp = &if_addr.i4;
+      break;
+    case MCRX_ADDR_TYPE_V6:
+      if_addrp = &if_addr.i4;
+      break;
+    default:
+      err(ctx,
+          "sub %p (%s) internal error: unknown family for source interface\n",
+          (void*)sub, desc);
+      if (close(sock_fd) < 0) {
+        handle_close_error(ctx);
+      }
+      return MCRX_ERR_UNKNOWN_FAMILY;
+  }
+
+  ret = mcrx_find_interface(sub, &if_idx, if_addrp);
+  if (ret != MCRX_ERR_OK) {
+    err(ctx, "sub %p (%s) could not find interface\n", (void*)sub, desc);
+    if (close(sock_fd) < 0) {
+      handle_close_error(ctx);
+    }
+    return ret;
+  }
+
+  /*
+   * choices for group management:
+   *
+   * 1.
+   * IP_ADD_SOURCE_MEMBERSHIP/IP_DROP_SOURCE_MEMBERSHIP
+   * http://man7.org/linux/man-pages/man7/ipv6.7.html
+   * http://man7.org/linux/man-pages/man7/ip.7.html
+   * (asm: IP_ADD_MEMBERSHIP/IP_DROP_MEMBERSHIP)
+   * (asm: IPV6_ADD_MEMBERSHIP/IPV6_DROP_MEMBERSHIP)
+   * - incredibly, there's no IPV6_ADD_SOURCE_MEMBERSHIP in linux
+   * - mac has no IPV6_ADD_MEMBERSHIP
+   *
+   * 2.
+   * MCAST_JOIN_SOURCE_GROUP/MCAST_LEAVE_SOURCE_GROUP
+   * https://tools.ietf.org/html/rfc3678#section-5.1.2
+   * (asm: MCAST_JOIN_GROUP/MCAST_LEAVE_GROUP)
+   * - compiles, but not functional on mac
+   *
+   * 3.
+   * MCAST_MSFILTER
+   * - probably the underlying mechanism for setsourcefilter, where
+   *   setsourcefilter is implemented.  Basically the same content.
+   * - freebsd has IPV6_MSFILTER and IP_MSFILTER.  They look the same?
+   * - IP_MSFILTER is similar but IP4-only, where MCAST_MSFILTER is v4 or v6
+   * - mac has IPV6_MSFILTER in netinet6/in6.h, but with a comment saying
+   *   "The following option is private; do not use it from user applications.",
+   *   and it doesn't compile.  IP_MSFILTER appears not to work.
+   *
+   * 4.
+   * SIOCSMSFILTER
+   * https://tools.ietf.org/html/rfc3678#section-8.2
+   * - appears not to be present in linux or mac
+   *
+   * 5. setsourcefilter  (https://tools.ietf.org/html/rfc3678#section-5.2.1)
+   * - there in mac, bsd, and linux? (in linux, not in kernel's netinet/in.h,
+   *   but it's there in userspace, presumably using MCAST_MSFILTER underneath)
+   * - however, everything I try on mac or linux always gives "Invalid argument".
+   *   Not sure if the socket or the interface index or the filter or one of the
+   *   sockbufs is the issue.  TBD: maybe debug this in-kernel to find out?
+   *   --jake 2019-06-17
+   *
+   * mac comments are regarding MacOSX10.12.sdk
+   * linux comments are regarding 4.15.0-48-generic
+   */
+
+  switch (sub->input.addr_type) {
+    case MCRX_ADDR_TYPE_V4: {
+      struct sockaddr_storage sinss_source = {0};
+      struct sockaddr_in *sin4_source = (struct sockaddr_in*)&sinss_source;
+
+      struct sockaddr_in sin4_group = {0};
+      sin4_group.sin_port = htons(sub->input.port);
+      sin4_group.sin_family = AF_INET;
+      sin4_group.sin_addr = sub->input.addrs.v4.group;
+
+      sin4_source->sin_family = AF_INET;
+      sin4_source->sin_addr = sub->input.addrs.v4.source;
+#if BSD
+      sin4_group.sin_len = sizeof(struct sockaddr_in);
+      sin4_source->sin_len = sizeof(struct sockaddr_in);
+#endif
+
+      // does it help rx to listen on any?
+      // bzero(&sin4_group.sin_addr, sizeof(struct in_addr));
+      rc = bind(sock_fd, (struct sockaddr*)(&sin4_group),
+          sizeof(struct sockaddr_in));
+      if (rc < 0) {
+        int prev_errno = errno;
+        ret = handle_bind_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+
+#if USE_JOIN_STRATEGY_FILTER
+      rc = setsourcefilter(sock_fd, if_idx, (struct sockaddr*)&sin4_group,
+          sizeof(struct sockaddr_in), MCAST_INCLUDE, 1, &sinss_source);
+      if (rc < 0) {
+        err(ctx, "sub %p (%s) setsourcefilter failed\n", (void*)sub,
+            desc);
+        int prev_errno = errno;
+        ret = handle_setsourcefilter_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+#elif USE_JOIN_STRATEGY_ADDMEM
+      struct ip_mreq_source mreq;
+      memset(&mreq, 0, sizeof(mreq));
+      mreq.imr_multiaddr = sub->input.addrs.v4.group;
+      mreq.imr_sourceaddr = sub->input.addrs.v4.source;
+      mreq.imr_interface = *((struct in_addr*)if_addrp);
+      rc = setsockopt(sock_fd, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP,
+          &mreq, sizeof(mreq));
+      if (rc < 0) {
+        err(ctx,
+            "sub %p (%s) setsockopt(IP_ADD_SOURCE_MEMBERSHIP) failed\n",
+            (void*)sub, desc);
+        int prev_errno = errno;
+        ret = handle_setsockopt_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+#elif USE_JOIN_STRATEGY_MCAST_JOIN
+      struct group_source_req gsreq;
+      bzero(&gsreq, sizeof(gsreq));
+      gsreq.gsr_interface = if_idx;
+      struct sockaddr_in* gsr_src = (struct sockaddr_in*)&gsreq.gsr_source;
+      struct sockaddr_in* gsr_grp = (struct sockaddr_in*)&gsreq.gsr_group;
+      gsr_src->sin_family = AF_INET;
+      gsr_src->sin_addr = sub->input.addrs.v4.source;
+      gsr_grp->sin_family = AF_INET;
+      gsr_grp->sin_addr = sub->input.addrs.v4.group;
+#if BSD
+      gsr_src->sin_len = sizeof(*gsr_src);
+      gsr_grp->sin_len = sizeof(*gsr_grp);
+#endif
+      rc = setsockopt(sock_fd, IPPROTO_IP, MCAST_JOIN_SOURCE_GROUP, &gsreq,
+          sizeof(gsreq));
+      if (rc < 0) {
+        err(ctx,
+            "sub %p (%s) setsockopt(MCAST_JOIN_SOURCE_GROUP) failed\n",
+            (void*)sub, desc);
+        int prev_errno = errno;
+        ret = handle_setsockopt_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+#endif
+      break;
+    }
+    case MCRX_ADDR_TYPE_V6: {
+      struct sockaddr_storage sinss_source = {0};
+      struct sockaddr_in6 *sin6_source = (struct sockaddr_in6*)&sinss_source;
+      struct sockaddr_in6 sin6_group = {0};
+      sin6_group.sin6_port = htons(sub->input.port);
+      sin6_group.sin6_family = AF_INET6;
+      sin6_group.sin6_addr = sub->input.addrs.v6.group;
+
+      sin6_source->sin6_family = AF_INET6;
+      sin6_source->sin6_addr = sub->input.addrs.v6.source;
+#if BSD
+      sin6_group.sin6_len = sizeof(struct sockaddr_in6);
+      sin6_source->sin6_len = sizeof(struct sockaddr_in6);
+#endif
+      rc = bind(sock_fd, (struct sockaddr*)(&sin6_group),
+          sizeof(struct sockaddr_in6));
+      if (rc < 0) {
+        int prev_errno = errno;
+        ret = handle_bind_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+
+#if USE_JOIN_STRATEGY_FILTER
+      rc = setsourcefilter(sock_fd, if_idx, (struct sockaddr*)&sin6_group,
+          sizeof(struct sockaddr_in6), MCAST_INCLUDE, 1, &sinss_source);
+      if (rc < 0) {
+        err(ctx, "sub %p (%s) setsourcefilter failed\n", (void*)sub,
+            desc);
+        int prev_errno = errno;
+        ret = handle_setsourcefilter_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+#elif USE_JOIN_STRATEGY_ADDMEM
+  #ifndef BROKEN_ADD_MEMBERSHIP_V6
+      // support for this seems present in freebsd but nowhere else?
+      struct ipv6_mreq_source mreq;
+      memset(&mreq, 0, sizeof(mreq));
+      mreq.ipv6mr_multiaddr = sub->input.addrs.v6.group;
+      mreq.ipv6mr_sourceaddr = sub->input.addrs.v6.source;
+      mreq.ipv6mr_interface = if_idx;
+      rc = setsockopt(sock_fd, IPPROTO_IP, IPV6_ADD_SOURCE_MEMBERSHIP,
+          &mreq, sizeof(mreq));
+      if (rc < 0) {
+        err(ctx,
+            "sub %p (%s) setsockopt(IPV6_ADD_SOURCE_MEMBERSHIP) failed: %s\n",
+            (void*)sub, desc);
+        int prev_errno = errno;
+        ret = handle_setsockopt_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+  #else
+      err(ctx, "sub %p (%s) unimplemented join(s,g)\n", (void*)sub, desc);
+      if (close(sock_fd) < 0) {
+        handle_close_error(ctx);
+      }
+      return MCRX_ERR_UNSUPPORTED;
+  #endif
+#elif USE_JOIN_STRATEGY_MCAST_JOIN
+      struct group_source_req gsreq;
+      bzero(&gsreq, sizeof(gsreq));
+      gsreq.gsr_interface = if_idx;
+      struct sockaddr_in6* gsr_src = (struct sockaddr_in6*)&gsreq.gsr_source;
+      struct sockaddr_in6* gsr_grp = (struct sockaddr_in6*)&gsreq.gsr_group;
+      gsr_src->sin6_family = AF_INET6;
+      gsr_src->sin6_addr = sub->input.addrs.v6.source;
+      gsr_grp->sin6_family = AF_INET6;
+      gsr_grp->sin6_addr = sub->input.addrs.v6.group;
+#if BSD
+      gsr_src->sin6_len = sizeof(*gsr_src);
+      gsr_grp->sin6_len = sizeof(*gsr_grp);
+#endif
+      rc = setsockopt(sock_fd, IPPROTO_IPV6, MCAST_JOIN_SOURCE_GROUP, &gsreq,
+          sizeof(gsreq));
+      if (rc < 0) {
+        err(ctx,
+            "sub %p (%s) setsockopt(MCAST_JOIN_SOURCE_GROUP) failed\n",
+            (void*)sub, desc);
+        int prev_errno = errno;
+        ret = handle_setsockopt_error(ctx);
+        if (close(sock_fd) < 0) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;  // suppress close's errno
+        return ret;
+      }
+#endif
+      break;
+    }
+    default:
+      err(ctx, "sub %p (%s) internal error, invalid addr_type\n", (void*)sub,
+          desc);
+      if (close(sock_fd) < 0) {
+        handle_close_error(ctx);
+      }
+      return MCRX_ERR_UNKNOWN_FAMILY;
+  }
+/*
+  char bound_ifname[IFNAMSZ];
+  socklen_t bound_ifname_len = sizeof(bound_ifname);
+  rc = getsockopt(sock_fd, SOL_SOCKET, SO_BINDTODEVICE, &bound_ifname[0],
+      &bound_ifname_len);
+  if (rc < 0) {
+    char buf[1024];
+    wrap_strerr(errno, buf, sizeof(buf));
+    err(ctx, "sub %p getsockopt(BINDTODEVICE) failed: %s\n", (void*)sub, buf);
+    close(sock_fd);
+    return -EBADF;
+  }
+  info(ctx, "sub %p socket bound to %s\n", bound_ifname);
+  */
+
+  val = fcntl(sock_fd, F_GETFL, 0);
+  if (val < 0) {
+    err(ctx, "sub %p (%s) fcntl(F_GETFL) failed\n", (void*)sub, desc);
+    int prev_errno = errno;
+    ret = handle_fcntl_error(ctx);
+    if (close(sock_fd) < 0) {
+      handle_close_error(ctx);
+    }
+    errno = prev_errno;  // suppress close's errno
+    return ret;
+  }
+
+  rc = fcntl(sock_fd, F_SETFL, val | O_NONBLOCK);
+  if (rc < 0) {
+    err(ctx, "sub %p (%s) fcntl(F_SETFL) failed\n", (void*)sub, desc);
+    int prev_errno = errno;
+    ret = handle_fcntl_error(ctx);
+    if (close(sock_fd) < 0) {
+      handle_close_error(ctx);
+    }
+    errno = prev_errno;  // suppress close's errno
+    return ret;
+  }
+
+  if (!ctx->add_socket_cb) {
+    err(ctx, "sub %p (%s) no add_socket_cb\n", (void*)sub, desc);
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  sub->sock_fd = sock_fd;
+  sub->joined = 1;
+
+  info(ctx, "calling add_socket_cb\n");
+
+  // keep ctx and sub alive if callback unrefs
+  mcrx_ctx_ref(ctx);
+  mcrx_subscription_ref(sub);
+  rc = ctx->add_socket_cb(ctx, (intptr_t)sub, sock_fd, native_receive);
+  if (rc != 0) {
+    err(ctx, "sub %p (%s) add_socket_cb() failed\n",
+        (void*)sub, desc);
+    int prev_errno = errno;
+    if (close(sock_fd) < 0) {
+      handle_close_error(ctx);
+    }
+    errno = prev_errno;  // suppress close error
+    sub->sock_fd = -1;
+    sub->joined = 0;
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return MCRX_ERR_CALLBACK_FAILED;
+  }
+  mcrx_subscription_unref(sub);
+  mcrx_ctx_unref(ctx);
+
+  return MCRX_ERR_OK;
+}
+
+enum mcrx_error_code mcrx_subscription_native_leave(
+    struct mcrx_subscription* sub) {
+  struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+  if (!sub || !ctx) {
+    if (!sub) {
+      err(ctx, "mcrx_subscription_leave with null sub\n");
+    } else {
+      err(ctx, "mcrx_subscription_leave with detached sub\n");
+    }
+    return MCRX_ERR_NULLARG;
+  }
+  if (!sub->joined) {
+    err(ctx, "mcrx_subscription_leave with unjoined subscription %p\n",
+        (void*)sub);
+    return MCRX_ERR_ALREADY_NOTJOINED;
+  }
+  if (sub->sock_fd < 0) {
+    err(ctx, "mcrx_subscription_leave with bad socket %d\n",
+        sub->sock_fd);
+    return MCRX_ERR_INTERNAL_ERROR;  // should only be possible when not joined
+  }
+  char desc[MCRX_SUB_STRLEN];
+  if (mcrx_subscription_ntop(sub, desc, sizeof(desc)) != 0) {
+    snprintf(desc, sizeof(desc), "unknown");
+  }
+  if (!ctx->remove_socket_cb) {
+    err(ctx, "sub %p (%s) no remove_socket_cb\n", (void*)sub, desc);
+    if (close(sub->sock_fd) < 0) {
+      handle_close_error(ctx);
+    }
+    sub->sock_fd = -1;
+    sub->joined = 0;
+    return MCRX_ERR_INTERNAL_ERROR;  // api should enforce non-null cb
+  }
+  // keep ctx alive if callback unrefs
+  mcrx_ctx_ref(ctx);
+  mcrx_subscription_ref(sub);
+  ctx->remove_socket_cb(ctx, sub->sock_fd);
+
+  int rc = close(sub->sock_fd);
+  if (rc < 0) {
+    err(ctx, "sub %p (%s) close(%d) failed\n", (void*)sub, desc,
+        sub->sock_fd);
+    handle_close_error(ctx);
+    sub->sock_fd = -1;
+    sub->joined = 0;
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return MCRX_ERR_SYSCALL_CLOSE;
+  }
+  sub->sock_fd = -1;
+  sub->joined = 0;
+  info(ctx, "sub %p (%s) unsubscribed\n", (void*)sub, desc);
+  mcrx_subscription_unref(sub);
+  mcrx_ctx_unref(ctx);
+  return MCRX_ERR_OK;
+}
+
+/**
+ * mcrx_subscription_config_ntop:
+ * @config: a subscription config object
+ * @source: a string with an IPv4 or IPv6 address
+ * @group: a string with an IPv4 or IPv6 address
+ *
+ * Fill config addresses and addr_type, ensure the address families match.
+ *
+ * Returns: MCRX_ERR_UNKNOWN_FAMILY on error.  errno may or may not be
+ * instructive, because both v4 and v6 are tried.
+ **/
+MCRX_EXPORT enum mcrx_error_code mcrx_subscription_config_pton(
+    struct mcrx_subscription_config* config,
+    const char* source,
+    const char* group) {
+  int ret;
+  ret = inet_pton(AF_INET, source, &config->addrs.v4.source);
+  if (ret > 0) {
+    ret = inet_pton(AF_INET, group, &config->addrs.v4.group);
+    if (ret > 0) {
+      config->addr_type = MCRX_ADDR_TYPE_V4;
+      return MCRX_ERR_OK;
+    }
+  }
+
+  ret = inet_pton(AF_INET6, source, &config->addrs.v6.source);
+  if (ret > 0) {
+    ret = inet_pton(AF_INET6, group, &config->addrs.v6.group);
+    if (ret > 0) {
+      config->addr_type = MCRX_ADDR_TYPE_V6;
+      return MCRX_ERR_OK;
+    }
+  }
+
+  config->addr_type = MCRX_ADDR_TYPE_UNKNOWN;
+  return MCRX_ERR_UNKNOWN_FAMILY;
+}
diff --git a/third_party/libmcrx/src/wait.c b/third_party/libmcrx/src/wait.c
new file mode 100644
index 000000000000..599192f1a761
--- /dev/null
+++ b/third_party/libmcrx/src/wait.c
@@ -0,0 +1,692 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <ctype.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+#include <mcrx/libmcrx.h>
+#include "./libmcrx-private.h"
+
+struct mcrx_fd_handle {
+  int magic;
+  struct mcrx_ctx* ctx;
+  intptr_t handle;
+  int fd;
+  int (*handle_cb)(intptr_t handle, int fd);
+};
+#define MCRX_FD_HANDLE_MAGIC 0x74
+
+#if MCRX_PRV_USE_KEVENT
+#include <sys/event.h>
+
+// I isolated the handling of various system calls in case I
+// need to refine the error handling better.  At this point,
+// the only goal is to have enough breadcrumbs to debug it if
+// these errors get hit, but it's possible more refined error
+// reporting would become worthwhile.
+static enum mcrx_error_code handle_kevent_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "kevent error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_KEVENT;
+}
+#define handle_kevent_error(ctx) handle_kevent_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_kqueue_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "kqueue error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_KQUEUE;
+}
+#define handle_kqueue_error(ctx) handle_kqueue_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+/**
+ * mcrx_ctx_receive_packets
+ * @ctx: mcrx library context
+ * @timeout_mx: timeout in milliseconds.
+ *
+ * receive_cb calls happen only from inside this function.  Provide
+ * timeout_ms = -1 to timeout never, or timeout_ms=0 to return
+ * immediately even if there were no packets.
+ *
+ * Applications that use this function cannot use
+ * mcrx_ctx_set_receive_socket_handlers.
+ *
+ * Returns: error code on problem, EAGAIN if timeout reached
+ */
+MCRX_EXPORT enum mcrx_error_code mcrx_ctx_receive_packets(
+    struct mcrx_ctx *ctx) {
+  if (ctx->nevents == 0) {
+    if (ctx->triggered != NULL) {
+      free(ctx->triggered);
+      ctx->triggered = NULL;
+      ctx->ntriggered = 0;
+      if (ctx->wait_fd != -1) {
+        close(ctx->wait_fd);
+        ctx->wait_fd = -1;
+      }
+      return MCRX_ERR_NOTHING_JOINED;
+    } else {
+      warn(ctx, "waiting again for packets with no listeners\n");
+      if (ctx->timeout_ms > 0) {
+        usleep(1000*ctx->timeout_ms);
+      } else {
+        // much friendlier to other threads when there's a bug...
+        usleep(1000);
+      }
+    }
+    return MCRX_ERR_NOTHING_JOINED;
+  }
+  if (ctx->wait_fd == -1) {
+    int fd = kqueue();
+    if (fd < 0) {
+      return handle_kqueue_error(ctx);
+    }
+    dbg(ctx, "created kqueue fd=%d\n", fd);
+    ctx->wait_fd = fd;
+  }
+  if (ctx->nevents != ctx->ntriggered) {
+    if (ctx->triggered == NULL) {
+      ctx->triggered = (struct kevent*)calloc(ctx->nevents,
+          sizeof(struct kevent));
+      if (!ctx->triggered) {
+        err(ctx, "failed to alloc %d events\n", ctx->nevents);
+        return MCRX_ERR_NOMEM;
+      }
+      ctx->ntriggered = ctx->nevents;
+    } else {
+      struct kevent* new_triggers = (struct kevent*)realloc(ctx->triggered,
+          sizeof(struct kevent)*ctx->nevents);
+      if (!new_triggers) {
+        warn(ctx, "failed to realloc %d events from %d\n", ctx->nevents,
+            ctx->ntriggered);
+      } else {
+        ctx->ntriggered = ctx->nevents;
+        ctx->triggered = new_triggers;
+      }
+    }
+  }
+
+  struct timespec tm;
+  struct timespec* ptm;
+  if (ctx->timeout_ms < 0) {
+    ptm = NULL;
+  } else {
+    tm.tv_sec = ctx->timeout_ms / 1000;
+    tm.tv_nsec = (ctx->timeout_ms % 1000) * 1000000;
+    ptm = &tm;
+  }
+  dbg(ctx, "waiting, trigger space=%u event space=%u\n",
+      ctx->ntriggered, ctx->nevents);
+  int nevents = kevent(ctx->wait_fd, ctx->events, ctx->nevents,
+      ctx->triggered, ctx->ntriggered, ptm);
+  dbg(ctx, "%d events from %u changes, %u trigger space\n",
+      nevents, ctx->nevents, ctx->ntriggered);
+
+  if (nevents < 0) {
+    if (errno == EINTR) {
+      // treat interrupts like a timeout (and don't report error)
+      return MCRX_ERR_TIMEDOUT;
+    }
+
+    err(ctx, "ctx %p failed kevent(%d)\n", (void*)ctx, ctx->wait_fd);
+    return handle_kevent_error(ctx);
+  }
+
+  u_int idx;
+  if (ctx->nadded != 0) {
+    u_int tot_events = ctx->nevents;
+    for (idx = 0; idx < tot_events; idx++) {
+      struct kevent* evt = &ctx->events[idx];
+      if (evt->flags & EV_ADD) {
+        evt->flags = EV_ENABLE;
+      }
+    }
+    ctx->nadded = 0;
+  }
+
+  if (nevents == 0) {
+    dbg(ctx, "no events fired--timed out? %d\n", ctx->timeout_ms);
+    return MCRX_ERR_TIMEDOUT;
+  }
+
+  // keep ctx alive regardless of what happens during callbacks.
+  mcrx_ctx_ref(ctx);
+  for (idx = 0; idx < (u_int)nevents; ++idx) {
+    struct kevent* evt = &ctx->triggered[idx];
+    struct mcrx_fd_handle* handle = (struct mcrx_fd_handle*)evt->udata;
+    if (!handle) {
+      err(ctx, "event with no handle (%u)\n", (unsigned int)evt->ident);
+      continue;
+    }
+    if (handle->magic != MCRX_FD_HANDLE_MAGIC) {
+      err(ctx, "event with improper handle (%u)\n", (unsigned int)evt->ident);
+      continue;
+    }
+    int fd = evt->ident;
+    if (handle->fd != fd) {
+      err(ctx, "event handle fd mismatch (%d != %d)\n", handle->fd, fd);
+      continue;
+    }
+    if (handle->ctx != ctx) {
+      err(ctx, "event handle ctx mismatch (%p != %p)\n", (void*)handle->ctx,
+          (void*)ctx);
+      continue;
+    }
+    dbg(ctx, "fired event, fd=%d, flags=%x, fflags=%x\n", fd, evt->flags,
+        evt->fflags);
+    int rc = handle->handle_cb(handle->handle, fd);
+    if (rc != MCRX_RECEIVE_CONTINUE) {
+      if (rc == MCRX_RECEIVE_STOP_CTX) {
+        break;
+      }
+    }
+  }
+  mcrx_ctx_unref(ctx);
+  return MCRX_ERR_OK;
+}
+
+int mcrx_prv_add_socket_cb(
+    struct mcrx_ctx* ctx,
+    intptr_t handle,
+    int fd,
+    int (*handle_cb)(intptr_t handle, int fd)) {
+  u_int idx;
+  struct kevent* evt;
+  if (!ctx) {
+    errno = EINVAL;
+    err(ctx, "add_socket_cb with no ctx\n");
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  if (!handle_cb) {
+    errno = EINVAL;
+    err(ctx, "add_socket_cb with no callback\n");
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  if (fd < 0) {
+    errno = EINVAL;
+    err(ctx, "add_socket_cb with bad fd (%d)\n", fd);
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  struct mcrx_fd_handle* new_cb = (struct mcrx_fd_handle*)calloc(1,
+      sizeof(struct mcrx_fd_handle));
+  if (new_cb == NULL) {
+    errno = ENOMEM;
+    err(ctx, "failed to alloc fd handle, oom\n");
+    return MCRX_ERR_NOMEM;
+  }
+  new_cb->magic = MCRX_FD_HANDLE_MAGIC;
+  new_cb->ctx = ctx;
+  new_cb->fd = fd;
+  new_cb->handle = handle;
+  new_cb->handle_cb = handle_cb;
+
+  for (idx = 0; idx < ctx->nevents; idx++) {
+    evt = &ctx->events[idx];
+    if (evt->filter == EVFILT_READ && evt->ident == (uintptr_t)fd) {
+      struct mcrx_fd_handle *old_cb = (struct mcrx_fd_handle*)evt->udata;
+      warn(ctx, "fd=%d  already in event list flags=%x->%x handle=%p->%p\n",
+          fd, evt->flags, (EV_ADD|EV_ENABLE), (void*)old_cb->handle,
+          (void*)new_cb->handle);
+      evt->udata = new_cb;
+      if (!(evt->flags & EV_ADD)) {
+        ctx->nadded += 1;
+      }
+      evt->flags = EV_ADD | EV_ENABLE;
+      free(old_cb);
+      return MCRX_ERR_OK;
+    }
+  }
+  if (ctx->events == NULL) {
+    info(ctx, "allocd read event for %d\n", fd);
+    ctx->events = calloc(1, sizeof(struct kevent));
+    if (!ctx->events) {
+      err(ctx, "failed to alloc 1-entry event list, oom\n");
+      errno = ENOMEM;
+      free(new_cb);
+      return MCRX_ERR_NOMEM;
+    }
+    dbg(ctx, "allocd 1-entry event list\n");
+    evt = &ctx->events[0];
+  } else {
+    struct kevent* new_evt = (struct kevent*)realloc(ctx->events,
+        (ctx->nevents+1)*sizeof(struct kevent));
+    if (!new_evt) {
+      err(ctx, "failed to realloc %u-entry event list, oom\n",
+          ctx->nevents + 1);
+      errno = ENOMEM;
+      free(new_cb);
+      return MCRX_ERR_NOMEM;
+    }
+    dbg(ctx, "reallocd %u-entry eventl list\n", ctx->nevents + 1);
+    ctx->events = new_evt;
+    evt = &ctx->events[ctx->nevents];
+  }
+  ctx->nevents += 1;
+  ctx->nadded += 1;
+  EV_SET(evt, fd, EVFILT_READ, EV_ADD, 0, 0, (void*)new_cb);
+  return 0;
+}
+
+int mcrx_prv_remove_socket_cb(
+    struct mcrx_ctx* ctx,
+    int fd) {
+  if (!ctx) {
+    errno = EINVAL;
+    err(ctx, "remove_socket_cb with no ctx\n");
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  if (fd < 0) {
+    errno = EINVAL;
+    err(ctx, "remove_socket_cb with bad fd (%d)\n", fd);
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+
+  u_int idx;
+  for (idx = 0; idx < ctx->nevents; idx++) {
+    struct kevent* evt;
+    evt = &ctx->events[idx];
+    if (evt->filter == EVFILT_READ && evt->ident == (uintptr_t)fd) {
+      struct mcrx_fd_handle *old_cb = (struct mcrx_fd_handle*)evt->udata;
+      if (!old_cb) {
+        err(ctx, "internal error: no udata set on event for %d\n", fd);
+        errno = EINVAL;
+        return MCRX_ERR_INTERNAL_ERROR;
+      }
+      if (old_cb->ctx != ctx) {
+        err(ctx, "ctx %p internal error: wrong ctx(%p) on %d\n", (void*)ctx,
+            (void*)old_cb->ctx, fd);
+      }
+      if (old_cb->fd != fd) {
+        err(ctx, "internal error: wrong fd (%d) on %d\n", fd, old_cb->fd);
+      }
+      dbg(ctx, "removing fd %d from wait events\n", fd);
+      evt->udata = 0;
+      if (evt->flags & EV_ADD) {
+        if (ctx->nadded < 1) {
+          err(ctx,
+              "internal error: number added under 1 when removing an add %d\n",
+              fd);
+        } else {
+          ctx->nadded -= 1;
+        }
+      }
+      ctx->nevents -= 1;
+      // as long as the fd is closed, which we do after this call, the
+      // event is removed from the kernel list.
+      if (ctx->nevents == 0) {
+        free(ctx->events);
+        ctx->events = 0;
+        close(ctx->wait_fd);
+        ctx->wait_fd = -1;
+      } else {
+        ctx->events = (struct kevent*)realloc(ctx->events,
+            sizeof(struct kevent)*ctx->nevents);
+      }
+
+      free(old_cb);
+      return 0;
+    }
+  }
+
+  err(ctx, "internal error: did not find fd to remove\n");
+  errno = EBADF;
+  return MCRX_ERR_INTERNAL_ERROR;
+}
+
+#endif  // MCRX_PRV_USE_KEVENT
+
+#if MCRX_PRV_USE_EPOLL
+#include <sys/epoll.h>
+
+// I isolated the handling of various system calls in case I
+// need to refine the error handling better.  At this point,
+// the only goal is to have enough breadcrumbs to debug it if
+// these errors get hit, but it's possible more refined error
+// reporting would become worthwhile.
+static enum mcrx_error_code handle_epollcreate_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "epoll_create1 error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_EPOLLCREATE;
+}
+#define handle_epollcreate_error(ctx) handle_epollcreate_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_epolladd_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "epoll_ctl(ADD) error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_EPOLLADD;
+}
+#define handle_epolladd_error(ctx) handle_epolladd_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_epolldel_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "epoll_ctl(DEL) error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_EPOLLDEL;
+}
+#define handle_epolldel_error(ctx) handle_epolldel_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+static enum mcrx_error_code handle_epollwait_error_impl(
+    struct mcrx_ctx* ctx,
+    const char* file,
+    int line,
+    const char* func) {
+  char buf[1024];
+  wrap_strerr(errno, buf, sizeof(buf));
+  err_passthru(ctx, file, line, func,
+      "epoll_wait() error: %s\n", buf);
+  return MCRX_ERR_SYSCALL_EPOLLWAIT;
+}
+#define handle_epollwait_error(ctx) handle_epollwait_error_impl(\
+    (ctx), __FILE__, __LINE__, __func__)
+
+MCRX_EXPORT enum mcrx_error_code mcrx_ctx_receive_packets(
+    struct mcrx_ctx *ctx) {
+  if (ctx->nevents == 0) {
+    if (ctx->triggered != NULL) {
+      free(ctx->triggered);
+      ctx->triggered = NULL;
+      ctx->ntriggered = 0;
+      if (ctx->wait_fd != -1) {
+        close(ctx->wait_fd);
+        ctx->wait_fd = -1;
+      }
+      return MCRX_ERR_NOTHING_JOINED;
+    } else {
+      warn(ctx, "waiting again for packets with no listeners\n");
+      if (ctx->timeout_ms > 0) {
+        usleep(1000*ctx->timeout_ms);
+      } else {
+        // if caller improperly spins on this call, it's much friendlier
+        // to other threads to inject a 1ms sleep. --jake 2019-06-28
+        usleep(1000);
+      }
+    }
+    return MCRX_ERR_NOTHING_JOINED;
+  }
+  if (ctx->wait_fd == -1) {
+    err(ctx, "no wait_fd ctx %p on entry to receive_packets\n", (void*)ctx);
+    // shouldn't ever get here.  should make this fatal, or keep going?
+    // --jake 2019-06-21
+    int fd = epoll_create1(EPOLL_CLOEXEC);
+    if (fd < 0) {
+      return handle_epollcreate_error(ctx);
+    }
+    u_int idx;
+    for (idx = 0; idx < ctx->nevents; idx++) {
+      struct epoll_event* evt = &ctx->events[idx];
+      struct mcrx_fd_handle* cur_cb = (struct mcrx_fd_handle*)evt->data.ptr;
+      int rc = epoll_ctl(ctx->wait_fd, EPOLL_CTL_ADD, cur_cb->fd, evt);
+      if (rc < 0) {
+        enum mcrx_error_code ret = handle_epolladd_error(ctx);
+        int prev_errno = errno;
+        if (close(fd)) {
+          handle_close_error(ctx);
+        }
+        errno = prev_errno;
+        return ret;
+      }
+    }
+    ctx->wait_fd = fd;
+  }
+  if (ctx->nevents != ctx->ntriggered) {
+    if (ctx->triggered == NULL) {
+      ctx->triggered = (struct epoll_event*)calloc(ctx->nevents,
+          sizeof(struct epoll_event));
+      if (!ctx->triggered) {
+        err(ctx, "failed to alloc %d events\n", ctx->nevents);
+        return MCRX_ERR_NOMEM;
+      }
+      ctx->ntriggered = ctx->nevents;
+    } else {
+      struct epoll_event* new_triggers = (struct epoll_event*)
+        realloc(ctx->triggered, sizeof(struct epoll_event)*ctx->nevents);
+      if (!new_triggers) {
+        warn(ctx, "failed to realloc %d events from %d\n", ctx->nevents,
+            ctx->ntriggered);
+      } else {
+        ctx->ntriggered = ctx->nevents;
+        ctx->triggered = new_triggers;
+      }
+    }
+  }
+
+  int nevents = epoll_wait(ctx->wait_fd, ctx->triggered, ctx->ntriggered,
+      ctx->timeout_ms);
+  dbg(ctx, "%d events from %u changes, %u trigger space\n",
+      nevents, ctx->nevents, ctx->ntriggered);
+
+  if (nevents < 0) {
+    if (errno == EINTR) {
+      // treat interrupts like a timeout (and don't report error)
+      return MCRX_ERR_TIMEDOUT;
+    }
+    return handle_epollwait_error(ctx);
+  }
+
+  if (nevents == 0) {
+    dbg(ctx, "no events fired--timed out, hopefully %d\n", ctx->timeout_ms);
+    return MCRX_ERR_TIMEDOUT;
+  }
+
+  // keep ctx alive regardless of what happens during callbacks.
+  mcrx_ctx_ref(ctx);
+  u_int idx;
+  for (idx = 0; idx < (u_int)nevents; ++idx) {
+    struct epoll_event* evt = &ctx->triggered[idx];
+    struct mcrx_fd_handle* handle = (struct mcrx_fd_handle*)evt->data.ptr;
+    if (!handle) {
+      err(ctx, "event with no handle (%u)\n", (unsigned int)idx);
+      continue;
+    }
+    if (handle->magic != MCRX_FD_HANDLE_MAGIC) {
+      err(ctx, "event with improper handle (%u)\n", (unsigned int)idx);
+      continue;
+    }
+    if (handle->ctx != ctx) {
+      err(ctx, "event handle ctx mismatch (%p != %p)\n", (void*)handle->ctx,
+          (void*)ctx);
+      continue;
+    }
+    dbg(ctx, "receive_cb handle=%"PRIxPTR"x fd=%d cb=%p\n",
+        handle->handle, handle->fd, (void*)handle);
+    int rc = handle->handle_cb(handle->handle, handle->fd);
+    if (rc != MCRX_RECEIVE_CONTINUE) {
+      if (rc == MCRX_RECEIVE_STOP_CTX) {
+        break;
+      }
+    }
+  }
+  mcrx_ctx_unref(ctx);
+
+  return MCRX_ERR_OK;
+}
+
+int mcrx_prv_add_socket_cb(
+    struct mcrx_ctx* ctx,
+    intptr_t handle,
+    int fd,
+    int (*handle_cb)(intptr_t handle, int fd)) {
+  if (!ctx) {
+    err(ctx, "add_socket_cb with no ctx\n");
+    errno = EINVAL;
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  if (!handle_cb) {
+    err(ctx, "add_socket_cb with no callback\n");
+    errno = EINVAL;
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  if (fd < 0) {
+    err(ctx, "add_socket_cb with bad fd (%d)\n", fd);
+    errno = EINVAL;
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  if (ctx->wait_fd == -1) {
+    int wait_fd = epoll_create1(EPOLL_CLOEXEC);
+    if (wait_fd < 0) {
+      handle_epollcreate_error(ctx);
+      errno = EINVAL;
+      return MCRX_ERR_INTERNAL_ERROR;
+    }
+    ctx->wait_fd = wait_fd;
+  }
+
+  struct mcrx_fd_handle* new_cb = (struct mcrx_fd_handle*)calloc(1,
+      sizeof(struct mcrx_fd_handle));
+  if (new_cb == NULL) {
+    errno = ENOMEM;
+    err(ctx, "failed to alloc fd handle, oom\n");
+    return MCRX_ERR_NOMEM;
+  }
+  new_cb->magic = MCRX_FD_HANDLE_MAGIC;
+  new_cb->ctx = ctx;
+  new_cb->fd = fd;
+  new_cb->handle = handle;
+  new_cb->handle_cb = handle_cb;
+  dbg(ctx, "add_socket_cb handle=%"PRIxPTR"x fd=%d cb=%p\n",
+      handle, fd, (void*)new_cb);
+
+  if (ctx->events == NULL) {
+    ctx->events = (struct epoll_event*)calloc(1,
+        sizeof(struct epoll_event));
+    if (!ctx->events) {
+      errno = ENOMEM;
+      err(ctx, "failed to alloc space for new fd handle, oom\n");
+      free(new_cb);
+      return MCRX_ERR_NOMEM;
+    }
+  } else {
+    struct epoll_event *new_holders = (struct epoll_event*)realloc(
+        ctx->events, sizeof(struct epoll_event)*(ctx->nevents+1));
+    if (!new_holders) {
+      errno = ENOMEM;
+      err(ctx, "failed to realloc space for new fd handle, oom\n");
+      free(new_cb);
+      return MCRX_ERR_NOMEM;
+    }
+    ctx->events = new_holders;
+  }
+  memset(&ctx->events[ctx->nevents], 0, sizeof(struct epoll_event));
+  ctx->events[ctx->nevents].data.ptr = new_cb;
+  ctx->events[ctx->nevents].events = EPOLLIN;
+
+  int rc = epoll_ctl(ctx->wait_fd, EPOLL_CTL_ADD, fd,
+      &ctx->events[ctx->nevents]);
+  if (rc < 0) {
+    enum mcrx_error_code ret = handle_epolladd_error(ctx);
+    free(new_cb);
+    return ret;
+  }
+  ctx->nevents += 1;
+
+  return 0;
+}
+
+int mcrx_prv_remove_socket_cb(
+    struct mcrx_ctx* ctx,
+    int fd) {
+  if (!ctx) {
+    errno = EINVAL;
+    err(ctx, "remove_socket_cb with no ctx\n");
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+  if (fd < 0) {
+    errno = EINVAL;
+    err(ctx, "remove_socket_cb with bad fd (%d)\n", fd);
+    return MCRX_ERR_INTERNAL_ERROR;
+  }
+
+  u_int idx;
+  for (idx = 0; idx < ctx->nevents; idx++) {
+    struct epoll_event* evt;
+    evt = &ctx->events[idx];
+    struct mcrx_fd_handle* cur_cb = (struct mcrx_fd_handle*)evt->data.ptr;
+    if (cur_cb->ctx != ctx) {
+      err(ctx, "internal error: wrong ctx on %d\n", fd);
+    }
+    dbg(ctx, "remove_socket_cb handle=%"PRIxPTR"x fd=%d cb=%p\n",
+        cur_cb->handle, fd, (void*)cur_cb);
+    ctx->nevents -= 1;
+    if (ctx->wait_fd != -1) {
+      int rc = epoll_ctl(ctx->wait_fd, EPOLL_CTL_DEL, fd, evt);
+      if (rc < 0) {
+        handle_epolldel_error(ctx);
+      }
+    }
+    if (idx < ctx->nevents) {
+      memmove(&ctx->events[idx], &ctx->events[idx+1],
+          (ctx->nevents-idx)*sizeof(struct epoll_event));
+    }
+    if (ctx->nevents == 0) {
+      free(ctx->events);
+      ctx->events = 0;
+      close(ctx->wait_fd);
+      ctx->wait_fd = -1;
+    } else {
+      ctx->events = (struct epoll_event*)realloc(ctx->events,
+          sizeof(struct epoll_event)*ctx->nevents);
+    }
+
+    free(cur_cb);
+    return 0;
+  }
+
+  err(ctx, "internal error: did not find fd to remove\n");
+  errno = EBADF;
+  return MCRX_ERR_INTERNAL_ERROR;
+}
+
+#endif  // MCRX_PRV_USE_EPOLL
diff --git a/third_party/libmcrx/test/.gitignore b/third_party/libmcrx/test/.gitignore
new file mode 100644
index 000000000000..97831e12b345
--- /dev/null
+++ b/third_party/libmcrx/test/.gitignore
@@ -0,0 +1,9 @@
+.dirstamp
+.deps/
+.libs/
+*.la
+*.lo
+libmcrx.pc
+test1-libmcrx
+.*.sw?
+*~
diff --git a/third_party/libmcrx/test/mcrx-check.c b/third_party/libmcrx/test/mcrx-check.c
new file mode 100644
index 000000000000..0cab4ca9c417
--- /dev/null
+++ b/third_party/libmcrx/test/mcrx-check.c
@@ -0,0 +1,316 @@
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <errno.h>
+#include <unistd.h>
+#include <time.h>
+#include <getopt.h>
+#include <signal.h>
+
+#include <mcrx/libmcrx.h>
+
+static volatile int stopping = 0;
+static void
+stopping_sighandler(int sig, siginfo_t *si, void *unused) {
+  (void)sig;
+  (void)si;
+  (void)unused;
+  printf("mcrx-check: stopping from signal\n");
+  stopping = 1;
+}
+
+struct sub_info {
+  int target_packets;
+  unsigned int got_packets;
+  unsigned long long got_bytes;
+  time_t start_time;
+  double target_duration;
+};
+static unsigned int dummy_data_check = 0;
+
+static int receive_cb(struct mcrx_packet* pkt) {
+  uint8_t* data = 0;
+  unsigned int length = mcrx_packet_get_contents(pkt, &data);
+  struct mcrx_subscription* sub = mcrx_packet_get_subscription(pkt);
+  struct sub_info* info = (struct sub_info*)mcrx_subscription_get_userdata(sub);
+  int done = 0;
+  info->got_packets += 1;
+  info->got_bytes += length;
+  if (info->target_packets > 0 && info->got_packets >= (unsigned int)info->target_packets) {
+    done = 1;
+  }
+  if (info->target_duration) {
+    time_t now = time(0);
+    double since = difftime(now, info->start_time);
+    if (since >= info->target_duration) {
+      done = 1;
+    }
+  }
+  if (stopping) {
+    done=1;
+  }
+  // a bounds-check so valgrind will complain if it's bad:
+  if (length > 0 && data) {
+    dummy_data_check += data[0];
+    dummy_data_check += data[length-1];
+  }
+  mcrx_packet_unref(pkt);
+  pkt = NULL;
+
+  if (done) {
+    mcrx_subscription_leave(sub);
+    return MCRX_RECEIVE_STOP_FD;
+  }
+  return MCRX_RECEIVE_CONTINUE;
+}
+
+int
+main(int argc, char *argv[]) {
+  int ch, rc = 0;
+
+  struct option long_options[] = {
+    { "source", required_argument, 0, 's' },
+    { "group", required_argument, 0, 'g' },
+    { "port", required_argument, 0, 'p' },
+    { "interface", required_argument, 0, 'i' },
+    { "count", required_argument, 0, 'c' },
+    { "duration", required_argument, 0, 'd' },
+    { "verbose", no_argument, 0, 'v' },
+    { "help", no_argument, 0, 'h' },
+    { 0, 0, 0, 0 }
+  };
+  const char* source = 0;
+  const char* group = 0;
+  const char* port_str = 0;
+  const char* count_str = 0;
+  const char* duration_str = 0;
+  int verbose = 0;
+  int fail = 0;
+  int port=0, count=5;
+  double target_duration=5.;
+  const char* override_ifname = NULL;
+
+  while ((ch =
+      getopt_long(argc, argv, "s:g:p:c:d:i:vh", long_options, NULL)) != EOF) {
+    switch (ch) {
+        case 's': {
+          source = optarg;
+          break;
+        }
+        case 'g': {
+          group = optarg;
+          break;
+        }
+        case 'p': {
+          port_str = optarg;
+          break;
+        }
+        case 'i': {
+          override_ifname = optarg;
+          break;
+        }
+        case 'c': {
+          count_str = optarg;
+          break;
+        }
+        case 'd': {
+          duration_str = optarg;
+          break;
+        }
+        case 'v': {
+          verbose += 1;
+          break;
+        }
+        case 'h': {
+          printf("usage: %s -s <source> -g <group> -p <port> [-c <packet count>] [-d <seconds>] [-i ifname] [-v]\n"
+             "  -s, --source:    source IP of (S,G)\n"
+             "  -g, --group:     group IP of (S,G)\n"
+             "  -p, --port:      UDP port to listen on\n"
+             "  -c, --count:     <count> packets to stop+succeed (0 for infinite, def=5)\n"
+             "  -d, --duration:  stop after <duration> seconds (0 for infinite, def=5)\n"
+             "  -i, --interface: override the normal interface (toward the source) with this interface name\n"
+             "  -v, --verbose:  increase verbosity (show libmcrx function calls)\n"
+             "  -h, --help:     show this usage message\n",
+              argv[0]);
+          return 0;
+        }
+    }
+  }
+
+  if (!port_str) {
+    fprintf(stderr, "port (-p/--port <num>) is required\n");
+    fail = 1;
+  } else {
+    rc = sscanf(port_str, "%d", &port);
+    if (rc != 1) {
+      fprintf(stderr, "failed to read port from %s\n", port_str);
+      fail = 1;
+    } else {
+      if (port < 1 || port > 0xffff) {
+        fprintf(stderr, "port %d not a valid port (1-%d)\n", port, 0xffff);
+        fail = 1;
+      }
+    }
+  }
+
+  count = 5;
+  if (count_str) {
+    rc = sscanf(count_str, "%d", &count);
+    if (rc != 1) {
+      fprintf(stderr, "failed to read count from %s\n", count_str);
+      fail = 1;
+    }
+  }
+
+  target_duration = 5.;
+  if (duration_str) {
+    rc = sscanf(duration_str, "%lf", &target_duration);
+    if (rc != 1) {
+      fprintf(stderr, "failed to read duration from %s\n", duration_str);
+      fail = 1;
+    }
+  }
+
+  struct mcrx_ctx *ctx;
+  struct mcrx_subscription *sub = NULL;
+  int err;
+  struct sub_info info = {
+    .target_packets=count,
+    .got_packets=0,
+    .start_time=time(0),
+    .target_duration=target_duration
+  };
+
+  struct mcrx_subscription_config cfg = MCRX_SUBSCRIPTION_CONFIG_INIT;
+  err = mcrx_subscription_config_pton(&cfg, source, group);
+  if (err != 0) {
+    fprintf(stderr, "subscription_config_pton failed: %s\n", mcrx_strerror(err));
+    fail = 1;
+  }
+
+  if (fail) {
+    return EXIT_FAILURE;
+  }
+
+  struct sigaction sa;
+  sa.sa_flags = SA_SIGINFO;
+  sigemptyset(&sa.sa_mask);
+  sa.sa_sigaction = stopping_sighandler;
+  if (sigaction(SIGTERM, &sa, NULL) == -1) {
+    perror("sigaction(SIGTERM) failed");
+    return EXIT_FAILURE;
+  }
+  if (sigaction(SIGHUP, &sa, NULL) == -1) {
+    perror("sigaction(SIGHUP) failed");
+    return EXIT_FAILURE;
+  }
+  if (sigaction(SIGINT, &sa, NULL) == -1) {
+    perror("sigaction(SIGINT) failed");
+    return EXIT_FAILURE;
+  }
+  if (sigaction(SIGQUIT, &sa, NULL) == -1) {
+    perror("sigaction(SIGQUIT) failed");
+    return EXIT_FAILURE;
+  }
+
+  err = mcrx_ctx_new(&ctx);
+  if (err != 0) {
+    fprintf(stderr, "ctx_new failed: %s %s\n", mcrx_strerror(err), mcrx_is_system_error(err)?strerror(errno):"");
+    return EXIT_FAILURE;
+  }
+  int level = MCRX_LOGLEVEL_WARNING;
+  if (verbose > 2) {
+    level = MCRX_LOGLEVEL_DEBUG;
+  } else if (verbose > 1) {
+    level = MCRX_LOGLEVEL_INFO;
+  }
+  mcrx_ctx_set_log_priority(ctx, level);
+
+  cfg.port = port;
+
+  err = mcrx_subscription_new(ctx, &cfg, &sub);
+  if (err != 0) {
+    fprintf(stderr, "new subscription failed: %s %s\n", mcrx_strerror(err), mcrx_is_system_error(err)?strerror(errno):"");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  if (override_ifname) {
+    mcrx_subscription_override_ifname(sub, override_ifname);
+  }
+
+  int timeout_milliseconds=500;
+  /*
+  if (target_duration >= 0) {
+    timeout_milliseconds = (int)(target_duration*1000 + 0.5);
+  }
+  */
+  mcrx_subscription_set_userdata(sub, (intptr_t)&info);
+  mcrx_subscription_set_receive_cb(sub, receive_cb);
+  mcrx_ctx_set_wait_ms(ctx, timeout_milliseconds);
+
+  err = mcrx_subscription_join(sub);
+  if (err != 0) {
+    fprintf(stderr, "subscription join failed: %s %s\n", mcrx_strerror(err), mcrx_is_system_error(err)?strerror(errno):"");
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  int msg_period = 1;
+  time_t last_msg_time = time(0);
+  time_t now;
+  do {
+    err = mcrx_ctx_receive_packets(ctx);
+    now = time(0);
+    if (target_duration) {
+      double dur = difftime(now, info.start_time);
+      if (dur > target_duration) {
+        break;
+      }
+    }
+    if (stopping) {
+      int leave_err = mcrx_subscription_leave(sub);
+      if (leave_err != 0) {
+        fprintf(stderr, "subscription leave failed: %s %s\n", mcrx_strerror(leave_err), mcrx_is_system_error(leave_err)?strerror(errno):"");
+      }
+      break;
+    }
+    double msg_gap = difftime(now, last_msg_time);
+    if (msg_gap > msg_period) {
+      double total_dur = difftime(now, info.start_time);
+      struct tm *loc_time;
+      last_msg_time = now;
+      if (verbose > 0) {
+        char tbuf[80];
+        loc_time = localtime(&now);
+        strftime(tbuf,sizeof(tbuf),"%m-%d %H:%M:%S", loc_time);
+        printf("%s: joined to %s->%s:%d for %gs, %u pkts received\n",
+            tbuf, source, group, (int)port, total_dur, info.got_packets);
+      }
+    }
+  } while (!err || err == MCRX_ERR_TIMEDOUT);
+
+  if (err && err != MCRX_ERR_NOTHING_JOINED && err != MCRX_ERR_TIMEDOUT) {
+    fprintf(stderr, "subscription receive failed: %s %s\n", mcrx_strerror(err), mcrx_is_system_error(err)?strerror(errno):"");
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  mcrx_subscription_unref(sub);
+  mcrx_ctx_unref(ctx);
+  now = time(0);
+  double dur = difftime(now, info.start_time);
+  if (info.target_packets && info.got_packets >= (unsigned int)info.target_packets) {
+    printf("passed (%u/%d packets in %lgs)\n", info.got_packets, count, dur);
+    return EXIT_SUCCESS;
+  } else {
+    printf("failed (%u/%d packets in %lgs)\n", info.got_packets, count, dur);
+    return EXIT_FAILURE;
+  }
+}
+
diff --git a/third_party/libmcrx/test/test-logstr.c b/third_party/libmcrx/test/test-logstr.c
new file mode 100644
index 000000000000..225a650fb23f
--- /dev/null
+++ b/third_party/libmcrx/test/test-logstr.c
@@ -0,0 +1,147 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <mcrx/libmcrx.h>
+
+struct sub_info {
+  int npackets;
+  int got_5;
+  int log_callbacks;
+};
+
+static int receive_cb(struct mcrx_packet* pkt) {
+  unsigned int length = mcrx_packet_get_contents(pkt, 0);
+  printf("got packet, length=%u\n", length);
+  struct mcrx_subscription* sub = mcrx_packet_get_subscription(pkt);
+  struct sub_info* info = (struct sub_info*)mcrx_subscription_get_userdata(sub);
+  info->npackets += 1;
+  mcrx_packet_unref(pkt);
+  pkt = NULL;
+
+  if (info->npackets > 5) {
+    printf("unsubscribing\n");
+    struct mcrx_ctx* ctx = mcrx_subscription_get_ctx(sub);
+    mcrx_ctx_set_log_string_fn(ctx, NULL);
+    mcrx_subscription_leave(sub);
+    info->got_5 = 1;
+  }
+  if (info->npackets > 100) {
+    fprintf(stderr, "did not stop at 5 packets\n");
+    exit(1);
+    return MCRX_RECEIVE_STOP_CTX;
+  }
+  return MCRX_RECEIVE_CONTINUE;
+}
+
+static void string_log_fn(
+    struct mcrx_ctx *ctx,
+    int priority,
+    const char *file,
+    int line,
+    const char *fn,
+    const char *str) {
+  (void)priority;
+  struct sub_info *info = (struct sub_info*)mcrx_ctx_get_userdata(ctx);
+  info->log_callbacks += 1;
+  fprintf(stderr, "string_cb(%s:%d(%s)): %s", file, line, fn, str);
+}
+
+int
+main(int argc, char *argv[])
+{
+  (void)(argc);
+  (void)(argv);
+
+  struct mcrx_ctx *ctx;
+  struct mcrx_subscription *sub = NULL;
+  int err;
+  struct sub_info info = { .npackets=0 };
+
+  err = mcrx_ctx_new(&ctx);
+  if (err < 0) {
+    fprintf(stderr, "ctx_new failed\n");
+    return EXIT_FAILURE;
+  }
+  mcrx_ctx_set_userdata(ctx, (intptr_t)&info);
+  mcrx_ctx_set_log_priority(ctx, MCRX_LOGLEVEL_DEBUG);
+  mcrx_ctx_set_log_string_fn(ctx, string_log_fn);
+  mcrx_ctx_log_msg(ctx, MCRX_LOGLEVEL_INFO, __FILE__, __LINE__, __func__,
+      "checking log err capability\n");
+  if (info.log_callbacks < 1) {
+    fprintf(stderr, "log_err failed\n");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  struct mcrx_subscription_config cfg = MCRX_SUBSCRIPTION_CONFIG_INIT;
+  err = mcrx_subscription_config_pton(&cfg, "23.212.185.5", "232.1.1.1");
+  if (err != 0) {
+    fprintf(stderr, "subscription_config_pton failed\n");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  cfg.port = 5001;
+
+  err = mcrx_subscription_new(ctx, &cfg, &sub);
+  if (err != 0) {
+    fprintf(stderr, "new subscription failed\n");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  mcrx_subscription_set_userdata(sub, (intptr_t)&info);
+  mcrx_subscription_set_receive_cb(sub, receive_cb);
+  mcrx_ctx_set_wait_ms(ctx, 5000);
+
+  err = mcrx_subscription_join(sub);
+  if (err != 0) {
+    fprintf(stderr, "subscription join failed\n");
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  do {
+    err = mcrx_ctx_receive_packets(ctx);
+  } while (!err || err == MCRX_ERR_TIMEDOUT);
+
+  if (err != MCRX_ERR_NOTHING_JOINED) {
+    fprintf(stderr, "subscription receive failed: %s\n", strerror(err));
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  mcrx_subscription_unref(sub);
+  mcrx_ctx_unref(ctx);
+  if (info.log_callbacks > 3) {
+    return EXIT_SUCCESS;
+  } else {
+    return EXIT_FAILURE;
+  }
+}
diff --git a/third_party/libmcrx/test/test-rejoin-same.c b/third_party/libmcrx/test/test-rejoin-same.c
new file mode 100644
index 000000000000..451aacf95683
--- /dev/null
+++ b/third_party/libmcrx/test/test-rejoin-same.c
@@ -0,0 +1,137 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <mcrx/libmcrx.h>
+
+struct sub_info {
+  int npackets;
+  int got_5;
+};
+
+static int receive_cb(struct mcrx_packet* pkt) {
+  unsigned int length = mcrx_packet_get_contents(pkt, 0);
+  printf("got packet, length=%u\n", length);
+  struct mcrx_subscription* sub = mcrx_packet_get_subscription(pkt);
+  struct sub_info* info = (struct sub_info*)mcrx_subscription_get_userdata(sub);
+  info->npackets += 1;
+  mcrx_packet_unref(pkt);
+  pkt = NULL;
+
+  if (info->npackets > 5) {
+    printf("unsubscribing\n");
+    mcrx_subscription_leave(sub);
+    info->got_5 = 1;
+  }
+  if (info->npackets > 100) {
+    fprintf(stderr, "did not stop at 5 packets\n");
+    exit(1);
+    return MCRX_RECEIVE_STOP_CTX;
+  }
+  return MCRX_RECEIVE_CONTINUE;
+}
+
+int
+main(int argc, char *argv[])
+{
+  (void)(argc);
+  (void)(argv);
+
+  struct mcrx_ctx *ctx;
+  struct mcrx_subscription *sub = NULL;
+  int err;
+  struct sub_info info = { .npackets=0 };
+
+  err = mcrx_ctx_new(&ctx);
+  if (err < 0) {
+    fprintf(stderr, "ctx_new failed\n");
+    return EXIT_FAILURE;
+  }
+  mcrx_ctx_set_log_priority(ctx, MCRX_LOGLEVEL_INFO);
+
+  struct mcrx_subscription_config cfg = MCRX_SUBSCRIPTION_CONFIG_INIT;
+  err = mcrx_subscription_config_pton(&cfg, "23.212.185.5", "232.1.1.1");
+  if (err != 0) {
+    fprintf(stderr, "subscription_config_pton failed\n");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  cfg.port = 5001;
+
+  err = mcrx_subscription_new(ctx, &cfg, &sub);
+  if (err != 0) {
+    fprintf(stderr, "new subscription failed\n");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  mcrx_subscription_set_userdata(sub, (intptr_t)&info);
+  mcrx_subscription_set_receive_cb(sub, receive_cb);
+  mcrx_ctx_set_wait_ms(ctx, 5000);
+
+  err = mcrx_subscription_join(sub);
+  if (err != 0) {
+    fprintf(stderr, "subscription join failed\n");
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  do {
+    err = mcrx_ctx_receive_packets(ctx);
+  } while (!err || err == MCRX_ERR_TIMEDOUT);
+
+  if (err != MCRX_ERR_NOTHING_JOINED) {
+    fprintf(stderr, "subscription receive failed: %s\n", strerror(err));
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  info.npackets = 0;
+  info.got_5 = 0;
+  sleep(5);
+  err = mcrx_subscription_join(sub);
+  if (err != 0) {
+    fprintf(stderr, "subscription join failed\n");
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  do {
+    err = mcrx_ctx_receive_packets(ctx);
+  } while (!err || err == MCRX_ERR_TIMEDOUT);
+
+  mcrx_subscription_unref(sub);
+  mcrx_ctx_unref(ctx);
+  if (info.got_5) {
+    return EXIT_SUCCESS;
+  } else {
+    return EXIT_FAILURE;
+  }
+}
diff --git a/third_party/libmcrx/test/test1-libmcrx.c b/third_party/libmcrx/test/test1-libmcrx.c
new file mode 100644
index 000000000000..9a45a893547a
--- /dev/null
+++ b/third_party/libmcrx/test/test1-libmcrx.c
@@ -0,0 +1,123 @@
+/*
+ * libmcrx - multicast receiving library
+ *
+ * Copyright (C) 2019 by Akamai Technologies
+ *    Jake Holland <jakeholland.net@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <mcrx/libmcrx.h>
+
+struct sub_info {
+  int npackets;
+  int got_5;
+};
+
+static int receive_cb(struct mcrx_packet* pkt) {
+  unsigned int length = mcrx_packet_get_contents(pkt, 0);
+  printf("got packet, length=%u\n", length);
+  struct mcrx_subscription* sub = mcrx_packet_get_subscription(pkt);
+  struct sub_info* info = (struct sub_info*)mcrx_subscription_get_userdata(sub);
+  info->npackets += 1;
+  mcrx_packet_unref(pkt);
+  pkt = NULL;
+
+  if (info->npackets > 5) {
+    printf("unsubscribing\n");
+    mcrx_subscription_leave(sub);
+    info->got_5 = 1;
+    return MCRX_RECEIVE_STOP_FD;
+  }
+  if (info->npackets > 100) {
+    fprintf(stderr, "did not stop at 5 packets\n");
+    exit(1);
+    return MCRX_RECEIVE_STOP_CTX;
+  }
+  return MCRX_RECEIVE_CONTINUE;
+}
+
+int
+main(int argc, char *argv[])
+{
+  (void)(argc);
+  (void)(argv);
+
+  struct mcrx_ctx *ctx;
+  struct mcrx_subscription *sub = NULL;
+  int err;
+  struct sub_info info = { .npackets=0 };
+
+  err = mcrx_ctx_new(&ctx);
+  if (err != 0) {
+    fprintf(stderr, "ctx_new failed\n");
+    return EXIT_FAILURE;
+  }
+  mcrx_ctx_set_log_priority(ctx, MCRX_LOGLEVEL_DEBUG);
+
+  struct mcrx_subscription_config cfg = MCRX_SUBSCRIPTION_CONFIG_INIT;
+  err = mcrx_subscription_config_pton(&cfg, "23.212.185.5", "232.1.1.1");
+  if (err != 0) {
+    fprintf(stderr, "subscription_config_pton failed\n");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  cfg.port = 5001;
+
+  err = mcrx_subscription_new(ctx, &cfg, &sub);
+  if (err != 0) {
+    fprintf(stderr, "new subscription failed\n");
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  mcrx_subscription_set_userdata(sub, (intptr_t)&info);
+  mcrx_subscription_set_receive_cb(sub, receive_cb);
+  mcrx_ctx_set_wait_ms(ctx, 5000);
+
+  err = mcrx_subscription_join(sub);
+  if (err != 0) {
+    fprintf(stderr, "subscription join failed\n");
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  do {
+    err = mcrx_ctx_receive_packets(ctx);
+  } while (!err || err == MCRX_ERR_TIMEDOUT);
+
+  if (err != MCRX_ERR_NOTHING_JOINED) {
+    fprintf(stderr, "subscription receive failed: %s\n", strerror(errno));
+    mcrx_subscription_unref(sub);
+    mcrx_ctx_unref(ctx);
+    return EXIT_FAILURE;
+  }
+
+  mcrx_subscription_unref(sub);
+  mcrx_ctx_unref(ctx);
+  if (info.got_5) {
+    return EXIT_SUCCESS;
+  } else {
+    return EXIT_FAILURE;
+  }
+}
diff --git a/chrome/installer/linux/common/chromium-browser/chromium-browser.info b/chrome/installer/linux/common/chromium-browser/chromium-browser.info
index 6f67b06166f0..8fb3209d0a63 100644
--- a/chrome/installer/linux/common/chromium-browser/chromium-browser.info
+++ b/chrome/installer/linux/common/chromium-browser/chromium-browser.info
@@ -6,10 +6,10 @@
 # chromium-browser packages for various platforms.
 
 # Base name of the package.
-PACKAGE="chromium-browser"
+PACKAGE="chromium-browser-mc"
 
 # Base name of the snap package
-SNAPNAME="chromium"
+SNAPNAME="chromium-mc"
 
 # Filename of the main executable (for generating launcher scripts, etc.)
 PROGNAME=chrome
@@ -18,16 +18,16 @@ PROGNAME=chrome
 INSTALLDIR=/opt/chromium.org/chromium
 
 # Display string for desktop menu/icon.
-MENUNAME="Chromium Web Browser"
+MENUNAME="Chromium Web Browser with multicast"
 
 # Brief package description.
-SHORTDESC="The web browser from Chromium.org"
+SHORTDESC="The web browser from Chromium.org with multicast"
 
 # Detailed package description.
-FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier."
+FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier. This version is an independent fork containing an experimental multicast API."
 
 # Package maintainer information.
 # TODO(mmoss) Setup a mailbox for this address
-MAINTNAME="Chromium Linux Team"
+MAINTNAME="Jake Holland"
 MAINTMAIL="chromium-linux-packager@chromium.org"
-PRODUCTURL="http://www.chromium.org/"
+PRODUCTURL="https://github.com/GrumpyOldTroll/chromium"
